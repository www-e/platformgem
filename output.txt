Build Errors Report with File Contents
======================================

Total files with errors: 60

#1: ./src/app/admin/payments/page.tsx
--------------------------------------------------------------------------------
// src/app/admin/payments/page.tsx
"use client";

import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  ModernFilters,
  FilterOption,
  FilterValue,
} from "@/components/admin/ModernFilters";
import {
  CreditCard,
  DollarSign,
  TrendingUp,
  AlertCircle,
  CheckCircle,
  Clock,
  XCircle,
  Eye,
  MoreHorizontal,
  RefreshCw,
  Download,
  Users,
  Calendar,
  Phone,
  Mail,
  BookOpen
} from "lucide-react";
import { cn } from "@/lib/utils";
import { formatAdminDateTime, formatRelativeTime } from "@/lib/date-utils";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";

interface Payment {
  id: string;
  amount: number;
  currency: string;
  status: "PENDING" | "COMPLETED" | "FAILED" | "CANCELLED" | "REFUNDED";
  createdAt: string;
  completedAt?: string;
  failureReason?: string;
  paymobOrderId?: string;
  paymobTransactionId?: number;
  user: {
    id: string;
    name: string;
    email?: string;
    phone: string;
  };
  course: {
    id: string;
    title: string;
    thumbnailUrl: string;
    professor: {
      name: string;
    };
  };
  lastWebhook?: {
    id: string;
    processedAt: string;
    processingAttempts: number;
    lastError?: string;
  };
}

interface PaymentSummary {
  total: number;
  completed: number;
  pending: number;
  failed: number;
  cancelled: number;
  totalRevenue: number;
}

const ITEMS_PER_PAGE = 12;

export default function AdminPaymentsPage() {
  const [payments, setPayments] = useState<Payment[]>([]);
  const [summary, setSummary] = useState<PaymentSummary | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [filters, setFilters] = useState<FilterValue>({});
  const [selectedPayment, setSelectedPayment] = useState<Payment | null>(null);

  const filterOptions: FilterOption[] = [
    {
      key: "status",
      label: "حالة الدفع",
      type: "select",
      options: [
        { value: "PENDING", label: "في الانتظار" },
        { value: "COMPLETED", label: "مكتمل" },
        { value: "FAILED", label: "فاشل" },
        { value: "CANCELLED", label: "ملغي" },
        { value: "REFUNDED", label: "مسترد" },
      ],
      placeholder: "اختر حالة الدفع",
    },
    {
      key: "amountRange",
      label: "نطاق المبلغ",
      type: "select",
      options: [
        { value: "0-100", label: "0 - 100 جنيه" },
        { value: "100-500", label: "100 - 500 جنيه" },
        { value: "500-1000", label: "500 - 1,000 جنيه" },
        { value: "1000+", label: "أكثر من 1,000 جنيه" },
      ],
      placeholder: "اختر نطاق المبلغ",
    },
    {
      key: "dateFrom",
      label: "من تاريخ",
      type: "date",
      placeholder: "اختر التاريخ",
    },
    {
      key: "dateTo",
      label: "إلى تاريخ",
      type: "date",
      placeholder: "اختر التاريخ",
    },
  ];

  useEffect(() => {
    fetchPayments();
    fetchSummary();
  }, [currentPage, filters]);

  const fetchPayments = async () => {
    setIsLoading(true);
    try {
      const queryParams = new URLSearchParams({
        page: currentPage.toString(),
        limit: ITEMS_PER_PAGE.toString(),
        ...Object.fromEntries(
          Object.entries(filters).filter(
            ([_, value]) => value !== undefined && value !== ""
          )
        ),
      });

      const response = await fetch(`/api/admin/payments?${queryParams}`);
      const data = await response.json();

      if (response.ok && data.success) {
        setPayments(data.data.payments || []);
        setTotalCount(data.data.pagination?.total || 0);
      }
    } catch (error) {
      console.error("Failed to fetch payments:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const fetchSummary = async () => {
    try {
      const response = await fetch("/api/admin/payments/stats");
      const data = await response.json();

      if (response.ok && data.success) {
        setSummary(data.data);
      }
    } catch (error) {
      console.error("Failed to fetch payment summary:", error);
    }
  };

  const handlePaymentAction = async (
    paymentId: string,
    action: string,
    additionalData?: any
  ) => {
    try {
      const response = await fetch(`/api/admin/payments/${paymentId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action, ...additionalData }),
      });

      const result = await response.json();

      if (result.success) {
        fetchPayments();
        fetchSummary();
      }
    } catch (error) {
      console.error("Payment action failed:", error);
    }
  };

  const handleFiltersChange = (newFilters: FilterValue) => {
    setFilters(newFilters);
    setCurrentPage(1);
  };

  const handleResetFilters = () => {
    setFilters({});
    setCurrentPage(1);
  };

  const handleExport = async () => {
    try {
      const queryParams = new URLSearchParams({
        ...Object.fromEntries(
          Object.entries(filters).filter(
            ([_, value]) => value !== undefined && value !== ""
          )
        ),
      });

      const response = await fetch(`/api/admin/payments/export?${queryParams}`);

      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `payments-export-${
          new Date().toISOString().split("T")[0]
        }.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error("Export failed:", error);
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case "COMPLETED":
        return <CheckCircle className="w-4 h-4 text-green-500" />;
      case "PENDING":
        return <Clock className="w-4 h-4 text-yellow-500" />;
      case "FAILED":
        return <XCircle className="w-4 h-4 text-red-500" />;
      case "CANCELLED":
        return <XCircle className="w-4 h-4 text-gray-500" />;
      case "REFUNDED":
        return <RefreshCw className="w-4 h-4 text-blue-500" />;
      default:
        return <AlertCircle className="w-4 h-4 text-gray-500" />;
    }
  };

  const getStatusBadge = (status: string) => {
    const variants = {
      COMPLETED: "bg-green-100 text-green-800 border-green-200",
      PENDING: "bg-yellow-100 text-yellow-800 border-yellow-200",
      FAILED: "bg-red-100 text-red-800 border-red-200",
      CANCELLED: "bg-gray-100 text-gray-800 border-gray-200",
      REFUNDED: "bg-blue-100 text-blue-800 border-blue-200",
    };

    const labels = {
      COMPLETED: "مكتمل",
      PENDING: "في الانتظار",
      FAILED: "فاشل",
      CANCELLED: "ملغي",
      REFUNDED: "مسترد",
    };

    return (
      <Badge
        className={cn("text-xs", variants[status as keyof typeof variants])}
      >
        {labels[status as keyof typeof labels] || status}
      </Badge>
    );
  };

  const totalPages = Math.ceil(totalCount / ITEMS_PER_PAGE);

  const PaymentCard = ({
    payment,
    index,
  }: {
    payment: Payment;
    index: number;
  }) => (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: index * 0.05 }}
    >
      <Card className="hover:shadow-lg transition-all duration-200 border-0 bg-card/50 backdrop-blur-sm">
        <CardContent className="p-6">
          <div className="flex items-start justify-between gap-4">
            <div className="flex items-start gap-4 flex-1">
              <div className="w-16 h-12 bg-gradient-to-br from-primary/10 to-primary/5 rounded-lg flex items-center justify-center">
                {payment.course.thumbnailUrl ? (
                  <img
                    src={payment.course.thumbnailUrl}
                    alt={payment.course.title}
                    className="w-full h-full object-cover rounded-lg"
                  />
                ) : (
                  <CreditCard className="w-6 h-6 text-primary" />
                )}
              </div>

              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2 mb-2">
                  <h4 className="font-semibold text-lg truncate">
                    {payment.course.title}
                  </h4>
                  {getStatusBadge(payment.status)}
                </div>

                <div className="space-y-2 text-sm text-muted-foreground">
                  <div className="flex items-center gap-2">
                    <Users className="w-4 h-4" />
                    <span>{payment.user.name}</span>
                  </div>

                  <div className="flex items-center gap-2">
                    <Phone className="w-4 h-4" />
                    <span dir="ltr">{payment.user.phone}</span>
                  </div>

                  {payment.user.email && (
                    <div className="flex items-center gap-2">
                      <Mail className="w-4 h-4" />
                      <span dir="ltr">{payment.user.email}</span>
                    </div>
                  )}

                  <div className="flex items-center gap-2">
                    <Calendar className="w-4 h-4" />
                    <span>{formatRelativeTime(payment.createdAt)}</span>
                  </div>
                </div>

                {payment.failureReason && (
                  <div className="mt-3 p-2 bg-red-50 border border-red-200 rounded-lg">
                    <p className="text-xs text-red-600">
                      <AlertCircle className="w-3 h-3 inline mr-1" />
                      {payment.failureReason}
                    </p>
                  </div>
                )}

                {payment.lastWebhook?.lastError && (
                  <div className="mt-3 p-2 bg-orange-50 border border-orange-200 rounded-lg">
                    <p className="text-xs text-orange-600">
                      <AlertCircle className="w-3 h-3 inline mr-1" />
                      خطأ في المعالجة: {payment.lastWebhook.lastError}
                    </p>
                  </div>
                )}
              </div>
            </div>

            <div className="flex flex-col items-end gap-3">
              <div className="text-right">
                <div className="text-2xl font-bold text-primary">
                  {new Intl.NumberFormat("ar-EG", {
                    style: "currency",
                    currency: payment.currency,
                    minimumFractionDigits: 0,
                  }).format(payment.amount)}
                </div>
                <div className="text-xs text-muted-foreground">
                  {formatAdminDateTime(payment.createdAt)}
                </div>
              </div>

              <div className="flex items-center gap-2">
                <Dialog>
                  <DialogTrigger asChild>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setSelectedPayment(payment)}
                    >
                      <Eye className="w-4 h-4 mr-2" />
                      التفاصيل
                    </Button>
                  </DialogTrigger>
                  <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
                    <DialogHeader>
                      <DialogTitle className="flex items-center gap-2">
                        {getStatusIcon(payment.status)}
                        تفاصيل المدفوعة
                      </DialogTitle>
                    </DialogHeader>

                    {selectedPayment && (
                      <div className="space-y-6">
                        <div className="grid grid-cols-2 gap-4">
                          <div>
                            <label className="text-sm font-medium">
                              المبلغ
                            </label>
                            <p className="text-lg font-bold text-primary">
                              {new Intl.NumberFormat("ar-EG", {
                                style: "currency",
                                currency: selectedPayment.currency,
                                minimumFractionDigits: 0,
                              }).format(selectedPayment.amount)}
                            </p>
                          </div>
                          <div>
                            <label className="text-sm font-medium">
                              الحالة
                            </label>
                            <div className="mt-1">
                              {getStatusBadge(selectedPayment.status)}
                            </div>
                          </div>
                        </div>

                        <div>
                          <label className="text-sm font-medium">الدورة</label>
                          <div className="flex items-center gap-3 mt-2 p-3 bg-muted/50 rounded-lg">
                            <div className="w-12 h-8 bg-primary/10 rounded overflow-hidden">
                              {selectedPayment.course.thumbnailUrl && (
                                <img
                                  src={selectedPayment.course.thumbnailUrl}
                                  alt={selectedPayment.course.title}
                                  className="w-full h-full object-cover"
                                />
                              )}
                            </div>
                            <div>
                              <p className="font-medium">
                                {selectedPayment.course.title}
                              </p>
                              <p className="text-sm text-muted-foreground">
                                المدرس: {selectedPayment.course.professor.name}
                              </p>
                            </div>
                          </div>
                        </div>

                        <div>
                          <label className="text-sm font-medium">
                            بيانات الملتحق
                          </label>
                          <div className="mt-2 p-3 bg-muted/50 rounded-lg space-y-2">
                            <p>
                              <strong>الاسم:</strong>{" "}
                              {selectedPayment.user.name}
                            </p>
                            <p>
                              <strong>الهاتف:</strong>{" "}
                              {selectedPayment.user.phone}
                            </p>
                            {selectedPayment.user.email && (
                              <p>
                                <strong>البريد الإلكتروني:</strong>{" "}
                                {selectedPayment.user.email}
                              </p>
                            )}
                          </div>
                        </div>

                        <div className="grid grid-cols-2 gap-4">
                          <div>
                            <label className="text-sm font-medium">
                              تاريخ الإنشاء
                            </label>
                            <p className="text-sm mt-1">
                              {formatAdminDateTime(selectedPayment.createdAt)}
                            </p>
                          </div>
                          {selectedPayment.completedAt && (
                            <div>
                              <label className="text-sm font-medium">
                                تاريخ الإكمال
                              </label>
                              <p className="text-sm mt-1">
                                {formatAdminDateTime(
                                  selectedPayment.completedAt
                                )}
                              </p>
                            </div>
                          )}
                        </div>

                        {selectedPayment.paymobTransactionId && (
                          <div>
                            <label className="text-sm font-medium">
                              معرف المعاملة
                            </label>
                            <p className="text-sm mt-1 font-mono">
                              {selectedPayment.paymobTransactionId}
                            </p>
                          </div>
                        )}
                      </div>
                    )}
                  </DialogContent>
                </Dialog>

                <DropdownMenu modal={false}>
                  <DropdownMenuTrigger asChild>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-8 w-8 p-0"
                      onMouseDown={(e) => e.preventDefault()}
                    >
                      <MoreHorizontal className="w-4 h-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent
                    align="end"
                    className="w-48 bg-background/95 backdrop-blur-sm border shadow-lg"
                    sideOffset={5}
                    onCloseAutoFocus={(e) => e.preventDefault()}
                  >
                    {payment.status === "PENDING" && (
                      <>
                        <DropdownMenuItem
                          onClick={(e) => {
                            e.preventDefault();
                            handlePaymentAction(payment.id, "manual_complete");
                          }}
                          className="cursor-pointer"
                        >
                          <CheckCircle className="h-4 w-4 ml-2" />
                          <span>إكمال يدوياً</span>
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          className="text-red-500 focus:text-red-500 cursor-pointer"
                          onClick={(e) => {
                            e.preventDefault();
                            handlePaymentAction(payment.id, "cancel", {
                              reason: "Cancelled by admin",
                            });
                          }}
                        >
                          <XCircle className="h-4 w-4 ml-2" />
                          <span>إلغاء</span>
                        </DropdownMenuItem>
                      </>
                    )}
                    {payment.status === "COMPLETED" &&
                      payment.lastWebhook?.lastError && (
                        <DropdownMenuItem
                          onClick={(e) => {
                            e.preventDefault();
                            handlePaymentAction(payment.id, "retry_enrollment");
                          }}
                          className="cursor-pointer"
                        >
                          <RefreshCw className="h-4 w-4 ml-2" />
                          <span>إعادة محاولة التسجيل</span>
                        </DropdownMenuItem>
                      )}
                    {payment.status === "FAILED" && (
                      <DropdownMenuItem
                        onClick={(e) => {
                          e.preventDefault();
                          handlePaymentAction(payment.id, "manual_complete");
                        }}
                        className="cursor-pointer"
                      >
                        <CheckCircle className="h-4 w-4 ml-2" />
                        <span>إكمال يدوياً</span>
                      </DropdownMenuItem>
                    )}
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      onClick={(e) => {
                        e.preventDefault();
                        setSelectedPayment(payment);
                      }}
                      className="cursor-pointer"
                    >
                      <Eye className="h-4 w-4 ml-2" />
                      <span>عرض التفاصيل</span>
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
    </motion.div>
  );

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
        <div>
          <h1 className="text-3xl font-bold bg-gradient-to-r from-foreground to-foreground/70 bg-clip-text">
            إدارة المدفوعات
          </h1>
          <p className="text-muted-foreground mt-1">
            مراقبة وإدارة جميع المدفوعات والمعاملات في النظام
          </p>
        </div>

        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            onClick={fetchPayments}
            disabled={isLoading}
          >
            <RefreshCw
              className={cn("w-4 h-4 mr-2", isLoading && "animate-spin")}
            />
            تحديث
          </Button>
          <Button variant="outline" onClick={handleExport}>
            <Download className="w-4 h-4 mr-2" />
            تصدير
          </Button>
        </div>
      </div>

      {/* Stats Cards */}
      {summary && (
        <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
          <Card className="border-0 bg-gradient-to-r from-blue-500/10 to-blue-600/10">
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">
                    إجمالي المدفوعات
                  </p>
                  <p className="text-2xl font-bold text-blue-600">
                    {summary.total}
                  </p>
                </div>
                <CreditCard className="w-8 h-8 text-blue-500" />
              </div>
            </CardContent>
          </Card>

          <Card className="border-0 bg-gradient-to-r from-green-500/10 to-green-600/10">
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">مكتملة</p>
                  <p className="text-2xl font-bold text-green-600">
                    {summary.completed}
                  </p>
                </div>
                <CheckCircle className="w-8 h-8 text-green-500" />
              </div>
            </CardContent>
          </Card>

          <Card className="border-0 bg-gradient-to-r from-yellow-500/10 to-yellow-600/10">
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">في الانتظار</p>
                  <p className="text-2xl font-bold text-yellow-600">
                    {summary.pending}
                  </p>
                </div>
                <Clock className="w-8 h-8 text-yellow-500" />
              </div>
            </CardContent>
          </Card>

          <Card className="border-0 bg-gradient-to-r from-red-500/10 to-red-600/10">
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">فاشلة</p>
                  <p className="text-2xl font-bold text-red-600">
                    {summary.failed}
                  </p>
                </div>
                <XCircle className="w-8 h-8 text-red-500" />
              </div>
            </CardContent>
          </Card>

          <Card className="border-0 bg-gradient-to-r from-purple-500/10 to-purple-600/10">
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-muted-foreground">
                    إجمالي الإيرادات
                  </p>
                  <p className="text-2xl font-bold text-purple-600">
                    {new Intl.NumberFormat("ar-EG", {
                      style: "currency",
                      currency: "EGP",
                      minimumFractionDigits: 0,
                    }).format(summary.totalRevenue)}
                  </p>
                </div>
                <DollarSign className="w-8 h-8 text-purple-500" />
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Filters */}
      <ModernFilters
        filters={filterOptions}
        values={filters}
        onChange={handleFiltersChange}
        onReset={handleResetFilters}
        showExport={false}
        isLoading={isLoading}
      />

      {/* Payments List */}
      {isLoading ? (
        <div className="space-y-4">
          {Array.from({ length: 6 }).map((_, i) => (
            <Card key={i} className="animate-pulse">
              <CardContent className="p-6">
                <div className="flex items-start gap-4">
                  <div className="w-16 h-12 bg-muted rounded-lg" />
                  <div className="flex-1 space-y-3">
                    <div className="h-4 bg-muted rounded w-1/2" />
                    <div className="h-3 bg-muted rounded w-3/4" />
                    <div className="h-3 bg-muted rounded w-1/3" />
                  </div>
                  <div className="w-24 h-8 bg-muted rounded" />
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      ) : payments.length > 0 ? (
        <>
          <div className="space-y-4">
            {payments.map((payment, index) => (
              <PaymentCard key={payment.id} payment={payment} index={index} />
            ))}
          </div>

          {/* Pagination */}
          {totalPages > 1 && (
            <div className="flex justify-center items-center gap-2 mt-8">
              <Button
                variant="outline"
                onClick={() => setCurrentPage((prev) => Math.max(1, prev - 1))}
                disabled={currentPage === 1}
              >
                السابق
              </Button>

              <div className="flex items-center gap-1">
                {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                  const pageNum = i + 1;
                  return (
                    <Button
                      key={pageNum}
                      variant={currentPage === pageNum ? "primary" : "outline"}
                      size="sm"
                      onClick={() => setCurrentPage(pageNum)}
                      className="w-10 h-10"
                    >
                      {pageNum}
                    </Button>
                  );
                })}
              </div>

              <Button
                variant="outline"
                onClick={() =>
                  setCurrentPage((prev) => Math.min(totalPages, prev + 1))
                }
                disabled={currentPage === totalPages}
              >
                التالي
              </Button>
            </div>
          )}
        </>
      ) : (
        <Card className="border-0 bg-card/50">
          <CardContent className="p-12 text-center">
            <CreditCard className="w-16 h-16 text-muted-foreground mx-auto mb-4" />
            <h3 className="text-lg font-semibold mb-2">لا توجد مدفوعات</h3>
            <p className="text-muted-foreground">
              {Object.keys(filters).length > 0
                ? "لم يتم العثور على مدفوعات مطابقة للفلاتر المحددة"
                : "لا توجد مدفوعات في النظام حتى الآن"}
            </p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}


#2: ./src/app/api/admin/payments/export/route.ts
--------------------------------------------------------------------------------
// src/app/api/admin/payments/export/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { createErrorResponse, ApiErrors } from '@/lib/api-utils';

export async function GET(request: NextRequest) {
  try {
    const session = await auth();
    
    if (!session?.user || session.user.role !== 'ADMIN') {
      return createErrorResponse(
        ApiErrors.UNAUTHORIZED.code,
        ApiErrors.UNAUTHORIZED.message,
        ApiErrors.UNAUTHORIZED.status
      );
    }

    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status');
    const dateFrom = searchParams.get('dateFrom');
    const dateTo = searchParams.get('dateTo');
    const format = searchParams.get('format') || 'csv';

    // Build where clause
    const where: any = {};
    
    if (status && status !== 'all') {
      where.status = status;
    }
    
    if (dateFrom || dateTo) {
      where.createdAt = {};
      if (dateFrom) {
        where.createdAt.gte = new Date(dateFrom);
      }
      if (dateTo) {
        where.createdAt.lte = new Date(dateTo);
      }
    }

    // Fetch payments with related data
    const payments = await prisma.payment.findMany({
      where,
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        },
        course: {
          select: {
            title: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    if (format === 'csv') {
      // Generate CSV
      const csvHeaders = [
        'Payment ID',
        'Student Name',
        'Student Email',
        'Course Title',
        'Amount',
        'Currency',
        'Status',
        'Payment Method',
        'PayMob Transaction ID',
        'Created At',
        'Updated At',
        'Failure Reason'
      ];

      const csvRows = payments.map(payment => [
        payment.id,
        payment.user.name || '',
        payment.user.email,
        payment.course.title,
        Number(payment.amount).toFixed(2),
        payment.currency,
        payment.status,
        payment.paymentMethod || '',
        payment.paymobTransactionId || '',
        payment.createdAt.toISOString(),
        payment.updatedAt.toISOString(),
        payment.failureReason || ''
      ]);

      const csvContent = [
        csvHeaders.join(','),
        ...csvRows.map(row => 
          row.map(field => 
            typeof field === 'string' && field.includes(',') 
              ? `"${field.replace(/"/g, '""')}"` 
              : field
          ).join(',')
        )
      ].join('\n');

      return new NextResponse(csvContent, {
        headers: {
          'Content-Type': 'text/csv',
          'Content-Disposition': `attachment; filename="payments-export-${new Date().toISOString().split('T')[0]}.csv"`
        }
      });
    } else if (format === 'json') {
      // Generate JSON
      const jsonData = payments.map(payment => ({
        id: payment.id,
        studentName: payment.user.name,
        studentEmail: payment.user.email,
        courseTitle: payment.course.title,
        amount: Number(payment.amount),
        currency: payment.currency,
        status: payment.status,
        paymentMethod: payment.paymentMethod,
        paymobTransactionId: payment.paymobTransactionId,
        createdAt: payment.createdAt.toISOString(),
        updatedAt: payment.updatedAt.toISOString(),
        failureReason: payment.failureReason
      }));

      return NextResponse.json({
        success: true,
        data: jsonData,
        exportedAt: new Date().toISOString(),
        totalRecords: jsonData.length
      });
    }

    return createErrorResponse(
      'INVALID_FORMAT',
      'Unsupported export format. Use csv or json.',
      400
    );

  } catch (error) {
    console.error('Payment export error:', error);
    return createErrorResponse(
      ApiErrors.INTERNAL_ERROR.code,
      ApiErrors.INTERNAL_ERROR.message,
      ApiErrors.INTERNAL_ERROR.status,
      error
    );
  }
}

#3: ./src/app/api/admin/professors/route.ts
--------------------------------------------------------------------------------
// src/app/api/admin/professors/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await auth();

    if (!session?.user?.id || session.user.role !== "ADMIN") {
      return NextResponse.json({ error: "غير مصرح" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "12");
    const search = searchParams.get("search");
    const status = searchParams.get("status");
    const hasCourses = searchParams.get("hasCourses");
    const revenueRange = searchParams.get("revenueRange");
    const dateFrom = searchParams.get("dateFrom");
    const dateTo = searchParams.get("dateTo");

    // Build where clause
    const whereClause: any = {
      role: "PROFESSOR",
    };

    if (search) {
      whereClause.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
        { phone: { contains: search, mode: "insensitive" } },
        { bio: { contains: search, mode: "insensitive" } },
      ];
    }

    if (status) {
      whereClause.isActive = status === "active";
    }

    if (dateFrom || dateTo) {
      whereClause.createdAt = {};
      if (dateFrom) {
        whereClause.createdAt.gte = new Date(dateFrom);
      }
      if (dateTo) {
        whereClause.createdAt.lte = new Date(dateTo);
      }
    }

    // Handle courses filter
    if (hasCourses === "yes") {
      whereClause.ownedCourses = { some: {} };
    } else if (hasCourses === "no") {
      whereClause.ownedCourses = { none: {} };
    }

    const [professorsRaw, totalCount] = await prisma.$transaction([
      prisma.user.findMany({
        where: whereClause,
        include: {
          ownedCourses: {
            include: {
              enrollments: {
                select: { id: true, userId: true },
              },
              payments: {
                where: { status: "COMPLETED" },
                select: { amount: true, currency: true },
              },
              certificates: {
                select: { id: true },
              },
              progressMilestones: {
                where: { milestoneType: "COURSE_COMPLETE" },
                select: { id: true, userId: true },
              },
              _count: {
                select: {
                  enrollments: true,
                  lessons: true,
                  certificates: true,
                },
              },
            },
          },
        },
        orderBy: { createdAt: "desc" },
        skip: (page - 1) * limit,
        take: limit,
      }),
      prisma.user.count({ where: whereClause }),
    ]);

    // Calculate enhanced statistics for each professor
    const professors = professorsRaw.map((professor) => {
      const totalRevenue = professor.ownedCourses.reduce(
        (sum: number, course: any) => {
          return (
            sum +
            course.payments.reduce((courseSum: number, payment: any) => {
              return courseSum + Number(payment.amount);
            }, 0)
          );
        },
        0
      );

      const totalEnrollments = professor.ownedCourses.reduce(
        (sum: number, course: any) => sum + course._count.enrollments,
        0
      );
      const totalCertificates = professor.ownedCourses.reduce(
        (sum: number, course: any) => sum + course._count.certificates,
        0
      );

      // Calculate completion rate
      const totalCompletions = professor.ownedCourses.reduce(
        (sum: number, course: any) => {
          const uniqueCompletions = new Set(
            course.progressMilestones.map((p: any) => p.userId)
          ).size;
          return sum + uniqueCompletions;
        },
        0
      );

      const completionRate =
        totalEnrollments > 0 ? (totalCompletions / totalEnrollments) * 100 : 0;

      return {
        id: professor.id,
        name: professor.name,
        email: professor.email,
        phone: professor.phone,
        bio: professor.bio,
        expertise: professor.expertise,
        isActive: professor.isActive,
        createdAt: professor.createdAt,
        stats: {
          totalRevenue,
          totalEnrollments,
          totalCertificates,
          completionRate: Math.round(completionRate),
          coursesCount: professor.ownedCourses.length,
        },
        courses: professor.ownedCourses.map((course: any) => ({
          id: course.id,
          title: course.title,
          _count: course._count,
        })),
      };
    });

    // Apply revenue range filter after calculation
    let filteredProfessors = professors;
    if (revenueRange) {
      filteredProfessors = professors.filter((prof) => {
        const revenue = prof.stats.totalRevenue;
        switch (revenueRange) {
          case "0-1000":
            return revenue >= 0 && revenue <= 1000;
          case "1000-5000":
            return revenue > 1000 && revenue <= 5000;
          case "5000-10000":
            return revenue > 5000 && revenue <= 10000;
          case "10000+":
            return revenue > 10000;
          default:
            return true;
        }
      });
    }

    // Sort professors by revenue (ranking)
    const rankedProfessors = filteredProfessors.sort(
      (a, b) => b.stats.totalRevenue - a.stats.totalRevenue
    );

    return NextResponse.json({
      professors: rankedProfessors,
      total: totalCount,
      page,
      limit,
      totalPages: Math.ceil(totalCount / limit),
    });
  } catch (error) {
    console.error("Professors fetch error:", error);
    return NextResponse.json({ error: "خطأ في الخادم" }, { status: 500 });
  }
}


#4: ./src/app/api/lessons/[id]/analytics/route.ts
--------------------------------------------------------------------------------
// src/app/api/lessons/[id]/analytics/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import prisma from '@/lib/prisma';

interface RouteParams {
  params: Promise<{ id: string }>
}

export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { id: lessonId } = await params;
    const { searchParams } = new URL(request.url);
    const range = searchParams.get('range') || '7d';

    // Verify lesson exists and user has access
    const lesson = await prisma.lesson.findUnique({
      where: { id: lessonId },
      include: {
        course: {
          select: {
            id: true,
            professorId: true,
            title: true
          }
        }
      }
    });

    if (!lesson) {
      return NextResponse.json({ error: 'Lesson not found' }, { status: 404 });
    }

    // Check permissions
    const canView = session.user.role === 'ADMIN' || 
                   (session.user.role === 'PROFESSOR' && lesson.course.professorId === session.user.id);

    if (!canView) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 });
    }

    // Calculate date range
    const days = range === '30d' ? 30 : range === '90d' ? 90 : 7;
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    // Get viewing history data
    const viewingHistory = await prisma.viewingHistory.findMany({
      where: {
        lessonId,
        updatedAt: {
          gte: startDate
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });

    // Calculate analytics
    const totalViews = viewingHistory.length;
    const uniqueViewers = new Set(viewingHistory.map(vh => vh.userId)).size;
    const totalWatchTime = viewingHistory.reduce((sum, vh) => sum + vh.watchedDuration, 0);
    const averageWatchTime = totalViews > 0 ? totalWatchTime / totalViews : 0;
    
    // Calculate completion rate
    const completedViews = viewingHistory.filter(vh => vh.completed).length;
    const completionRate = totalViews > 0 ? (completedViews / totalViews) * 100 : 0;

    // Get top viewers
    const viewerStats = viewingHistory.reduce((acc, vh) => {
      if (!acc[vh.userId]) {
        acc[vh.userId] = {
          userId: vh.userId,
          userName: vh.user.name,
          watchTime: 0,
          totalDuration: vh.totalDuration,
          completed: false
        };
      }
      acc[vh.userId].watchTime = Math.max(acc[vh.userId].watchTime, vh.watchedDuration);
      if (vh.completed) acc[vh.userId].completed = true;
      return acc;
    }, {} as Record<string, any>);

    const topViewers = Object.values(viewerStats)
      .map((viewer: any) => ({
        ...viewer,
        completionRate: viewer.totalDuration > 0 ? (viewer.watchTime / viewer.totalDuration) * 100 : 0
      }))
      .sort((a: any, b: any) => b.watchTime - a.watchTime);

    // Calculate drop-off points (simplified)
    const dropOffPoints = [];
    if (lesson.duration) {
      const intervals = 10; // Check 10 points throughout the video
      const intervalDuration = lesson.duration / intervals;
      
      for (let i = 1; i <= intervals; i++) {
        const timePoint = intervalDuration * i;
        const viewersAtPoint = viewingHistory.filter(vh => vh.lastPosition >= timePoint).length;
        const dropOffPercentage = totalViews > 0 ? ((totalViews - viewersAtPoint) / totalViews) * 100 : 0;
        
        if (dropOffPercentage > 10) { // Only show significant drop-offs
          dropOffPoints.push({
            time: timePoint,
            percentage: dropOffPercentage
          });
        }
      }
    }

    // Generate daily engagement data
    const viewerEngagement = [];
    for (let i = days - 1; i >= 0; i--) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const dayStart = new Date(date.setHours(0, 0, 0, 0));
      const dayEnd = new Date(date.setHours(23, 59, 59, 999));
      
      const dayViews = viewingHistory.filter(vh => 
        vh.updatedAt >= dayStart && vh.updatedAt <= dayEnd
      );
      
      viewerEngagement.push({
        date: dayStart.toISOString().split('T')[0],
        views: dayViews.length,
        watchTime: dayViews.reduce((sum, vh) => sum + vh.watchedDuration, 0)
      });
    }

    const analytics = {
      totalViews,
      uniqueViewers,
      totalWatchTime,
      averageWatchTime,
      completionRate,
      dropOffPoints,
      viewerEngagement,
      topViewers: topViewers.slice(0, 10)
    };

    return NextResponse.json(analytics);

  } catch (error) {
    console.error('Analytics error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

#5: ./src/app/api/payments/initiate/route.ts
--------------------------------------------------------------------------------
// src/app/api/payments/initiate/route.ts
import { NextRequest } from "next/server";
import { auth } from "@/lib/auth";
import prisma from "@/lib/prisma";
import { payMobService } from "@/lib/paymob/client";
import { initiatePayment } from "@/lib/paymob/payment.service";
import {
  createSuccessResponse,
  createErrorResponse,
  ApiErrors,
  API_ERROR_CODES,
  getErrorMessage,
} from "@/lib/api-response";
import { z } from "zod";
import { paymobConfig } from '@/lib/paymob/config';


// Validation schema for payment initiation
const paymentInitiateSchema = z.object({
  courseId: z.string().min(1, "معرف الدورة مطلوب"),
  paymentMethod: z.enum(["credit-card", "e-wallet"]).default("credit-card"),
  phoneNumber: z.string().optional(), // Required for e-wallet payments
});

// POST /api/payments/initiate - Initiate payment for a course
export async function POST(request: NextRequest) {
  try {
    const session = await auth();

    // Check authentication
    if (!session?.user) {
      return createErrorResponse(
        ApiErrors.UNAUTHORIZED.code,
        ApiErrors.UNAUTHORIZED.message,
        ApiErrors.UNAUTHORIZED.status
      );
    }

    // Only students can make payments (admins can for testing)
    if (!["STUDENT", "ADMIN"].includes(session.user.role)) {
      return createErrorResponse(
        ApiErrors.FORBIDDEN.code,
        "غير مصرح لك بإجراء عمليات الدفع",
        ApiErrors.FORBIDDEN.status
      );
    }

    // Parse and validate request body
    const body = await request.json();
    const validationResult = paymentInitiateSchema.safeParse(body);

    if (!validationResult.success) {
      return createErrorResponse(
        ApiErrors.VALIDATION_ERROR.code,
        ApiErrors.VALIDATION_ERROR.message,
        ApiErrors.VALIDATION_ERROR.status,
        validationResult.error.issues
      );
    }

    const { courseId, paymentMethod, phoneNumber } = validationResult.data;

    // Validate phone number for e-wallet payments
    if (paymentMethod === 'e-wallet' && !phoneNumber) {
      return createErrorResponse(
        ApiErrors.VALIDATION_ERROR.code,
        "رقم الهاتف مطلوب للدفع بالمحفظة الإلكترونية",
        ApiErrors.VALIDATION_ERROR.status
      );
    }

    // Check if course exists and is published
    const course = await prisma.course.findFirst({
      where: {
        id: courseId,
        isPublished: true,
      },
      include: {
        professor: {
          select: {
            id: true,
            name: true,
          },
        },
        category: {
          select: {
            name: true,
          },
        },
      },
    });

    if (!course) {
      return createErrorResponse(
        ApiErrors.NOT_FOUND.code,
        "الدورة غير موجودة أو غير منشورة",
        ApiErrors.NOT_FOUND.status
      );
    }

    // Check if course is paid
    if (!course.price || Number(course.price) <= 0) {
      return createErrorResponse(
        "FREE_COURSE",
        "هذه الدورة مجانية ولا تحتاج لدفع",
        400
      );
    }

    // Check if user is already enrolled
    const existingEnrollment = await prisma.enrollment.findUnique({
      where: {
        userId_courseId: {
          userId: session.user.id,
          courseId,
        },
      },
    });

    if (existingEnrollment) {
      return createErrorResponse(
        ApiErrors.DUPLICATE_ERROR.code,
        "أنت مسجل في هذه الدورة بالفعل",
        ApiErrors.DUPLICATE_ERROR.status
      );
    }

    // Check if there's already a pending payment
    const existingPayment = await prisma.payment.findFirst({
      where: {
        userId: session.user.id,
        courseId,
        status: "PENDING",
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    if (existingPayment) {
      const { isPaymentExpired, getPaymentTimeRemaining } = await import(
        "@/lib/services/payment-timeout.service"
      );

      if (isPaymentExpired(existingPayment.createdAt)) {
        // Cancel the old payment and allow new one
        await prisma.payment.update({
          where: { id: existingPayment.id },
          data: {
            status: "CANCELLED",
            failureReason: `Payment abandoned - exceeded ${paymobConfig.abandonedPaymentCleanupMinutes} minute limit`,
            updatedAt: new Date(),
          },
        });

        console.log("Cancelled abandoned payment:", existingPayment.id);
      } else {
        // Payment is recent, but allow user to retry by cancelling the old one
        console.log("Cancelling existing pending payment to allow retry:", existingPayment.id);
        
        await prisma.payment.update({
          where: { id: existingPayment.id },
          data: {
            status: "CANCELLED",
            failureReason: "Cancelled by user to retry payment",
            updatedAt: new Date(),
          },
        });
      }
    }

    // Prevent professors from buying their own courses
    if (course.professorId === session.user.id) {
      return createErrorResponse(
        "INVALID_PURCHASE",
        "لا يمكنك شراء دورتك الخاصة",
        400
      );
    }

    // Get user information for billing
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        name: true,
        email: true,
        phone: true,
      },
    });

    if (!user) {
      return createErrorResponse(
        ApiErrors.NOT_FOUND.code,
        "بيانات المستخدم غير موجودة",
        ApiErrors.NOT_FOUND.status
      );
    }

    // Create payment record in database
    const merchantOrderId = payMobService.generateMerchantOrderId(
      courseId,
      session.user.id
    );
    const amountCents = payMobService.formatAmount(Number(course.price));

    const payment = await prisma.payment.create({
      data: {
        userId: session.user.id,
        courseId,
        amount: course.price,
        currency: course.currency,
        status: "PENDING",
        paymobOrderId: merchantOrderId,
      },
    });

    // Prepare PayMob order data
    const billingData = payMobService.createBillingData({
      name: user.name,
      email: user.email || undefined,
      phone: phoneNumber || user.phone, // Use provided phone number for e-wallets
    });
    const orderData = {
      amount_cents: amountCents,
      currency: course.currency,
      merchant_order_id: merchantOrderId,
      items: [
        {
          name: course.title,
          amount_cents: amountCents,
          description: `دورة ${course.title} - ${course.category.name}`,
          quantity: 1,
        },
      ],
      billing_data: billingData,
    };

    // Initiate payment with PayMob
    const paymentResult = await initiatePayment(
      orderData,
      courseId,
      paymentMethod,
      session.user.id
    );

    // Update payment record with PayMob data
    const updateData: any = {
      paymobResponse: {
        paymentMethod,
        initiatedAt: new Date().toISOString(),
      },
    };

    // Store payment data based on method
    if (paymentMethod === 'e-wallet') {
      // For mobile wallets, store transaction and OTP data
      updateData.paymobOrderId = paymentResult.orderId?.toString() || merchantOrderId;
      updateData.paymobTransactionId = paymentResult.transactionId ? BigInt(paymentResult.transactionId) : null;
      updateData.paymobResponse.transactionId = paymentResult.transactionId;
      updateData.paymobResponse.otpUrl = paymentResult.otpUrl;
      updateData.paymobResponse.walletProvider = paymentResult.walletProvider;
      updateData.paymobResponse.requiresOTP = paymentResult.requiresOTP;
      updateData.paymobResponse.orderId = paymentResult.orderId;
    } else {
      // For credit cards, store traditional data
      updateData.paymobOrderId = paymentResult.orderId?.toString() || merchantOrderId;
      updateData.paymobResponse.paymentKey = paymentResult.paymentKey;
      updateData.paymobResponse.orderId = paymentResult.orderId;
      updateData.paymobResponse.iframeUrl = paymentResult.iframeUrl;
    }

    await prisma.payment.update({
      where: { id: payment.id },
      data: updateData,
    });

    return createSuccessResponse(
      {
        paymentId: payment.id,
        paymentKey: paymentResult.paymentKey,
        iframeUrl: paymentResult.iframeUrl,
        orderId: paymentResult.orderId,
        // Mobile wallet specific fields
        transactionId: paymentResult.transactionId,
        otpUrl: paymentResult.otpUrl,
        walletProvider: paymentResult.walletProvider,
        requiresOTP: paymentResult.requiresOTP,
        paymentMethod: paymentResult.paymentMethod,
        amount: Number(course.price),
        currency: course.currency,
        course: {
          id: course.id,
          title: course.title,
          thumbnailUrl: course.thumbnailUrl,
          professor: course.professor.name,
        },
      },
      "Payment initiated successfully",
      201
    );
  } catch (error) {
    console.error("Payment initiation error:", error);

    // Handle PayMob specific errors
    // Handle PayMob specific errors
    if (error instanceof Error && error.message.includes("PayMob")) {
      return createErrorResponse(
        API_ERROR_CODES.PAYMENT_GATEWAY_ERROR,
        getErrorMessage(API_ERROR_CODES.PAYMENT_GATEWAY_ERROR),
        502,
        {
          originalError: error.message,
          gateway: "PayMob",
          timestamp: new Date().toISOString(),
        }
      );
    }

    return createErrorResponse(
      ApiErrors.INTERNAL_ERROR.code,
      ApiErrors.INTERNAL_ERROR.message,
      ApiErrors.INTERNAL_ERROR.status,
      error
    );
  }
}


#6: ./src/app/api/payments/webhook/route.ts
--------------------------------------------------------------------------------
// src/app/api/payments/webhook/route.ts
import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { payMobService } from "@/lib/paymob/client";
import { 
  createSuccessResponse,
  createErrorResponse,
  API_ERROR_CODES 
} from "@/lib/api-response";
// Webhook retry configuration
const WEBHOOK_RETRY_CONFIG = {
  maxRetries: 3,
  retryDelays: [1000, 5000, 15000], // 1s, 5s, 15s
};

/**
 * Process webhook with retry mechanism for transient failures
 */
async function processWebhookWithRetry(
  payment: any,
  processedData: any,
  webhookData: any,
  validatedTransactionId: number,
  existingWebhook: any,
  retryCount = 0
): Promise<any> {
  try {
    // Your existing transaction code will go here
    // We'll move the main transaction logic into this function
    
    // Determine new payment status
    const newStatus = processedData.isSuccess ? "COMPLETED" : "FAILED";
    const completedAt = processedData.isSuccess ? new Date() : null;
    const failureReason = !processedData.isSuccess
      ? "Payment failed at PayMob gateway"
      : null;

    // Execute payment update and enrollment creation in a single transaction
    const transactionResult = await prisma.$transaction(async (tx) => {
      // Create or update webhook record
      const webhookId =
        existingWebhook?.id ||
        `webhook_${validatedTransactionId}_${Date.now()}`;

      if (existingWebhook) {
        await tx.paymentWebhook.update({
          where: { id: existingWebhook.id },
          data: {
            webhookPayload: webhookData,
            processedAt: new Date(),
            processingAttempts: existingWebhook.processingAttempts + 1,
            lastError: null,
          },
        });
      } else {
        await tx.paymentWebhook.create({
          data: {
            id: webhookId,
            paymentId: payment.id,
            paymobTransactionId: BigInt(validatedTransactionId),
            webhookPayload: webhookData,
            processedAt: new Date(),
            processingAttempts: 1,
          },
        });
      }

      // Update payment record
      const updatedPayment = await tx.payment.update({
        where: { id: payment.id },
        data: {
          status: newStatus,
          paymobTransactionId: BigInt(validatedTransactionId),
          completedAt,
          failureReason,
          paymobResponse: {
            ...(payment.paymobResponse as any),
            webhook: {
              transactionId: validatedTransactionId,
              success: processedData.isSuccess,
              amountCents: processedData.amountCents,
              currency: processedData.currency,
              processedAt: new Date().toISOString(),
              rawData: webhookData,
              retryCount,
            },
          },
        },
      });

      // For successful payments, create enrollment within the same transaction
      let enrollmentResult = null;
      if (processedData.isSuccess) {
        try {
          // Check if enrollment already exists
          const existingEnrollment = await tx.enrollment.findUnique({
            where: {
              userId_courseId: {
                userId: payment.userId,
                courseId: payment.courseId,
              },
            },
          });

          if (!existingEnrollment) {
            // Create enrollment
            const newEnrollment = await tx.enrollment.create({
              data: {
                userId: payment.userId,
                courseId: payment.courseId,
                progressPercent: 0,
                completedLessonIds: [],
                totalWatchTime: 0,
                enrolledAt: new Date(),
                lastAccessedAt: null,
              },
            });

            // Create progress milestone
            await tx.progressMilestone.create({
              data: {
                userId: payment.userId,
                courseId: payment.courseId,
                milestoneType: 'COURSE_START',
                metadata: {
                  paymentId: payment.id,
                  enrollmentId: newEnrollment.id,
                  courseName: payment.course.title,
                  amount: Number(payment.amount),
                  webhookTransactionId: validatedTransactionId,
                  retryCount,
                },
              },
            });

            enrollmentResult = {
              success: true,
              enrollmentId: newEnrollment.id,
              created: true,
            };

            console.log('Enrollment created within transaction:', {
              enrollmentId: newEnrollment.id,
              paymentId: payment.id,
              userId: payment.userId,
              courseId: payment.courseId,
              retryCount,
            });
          } else {
            enrollmentResult = {
              success: true,
              enrollmentId: existingEnrollment.id,
              created: false,
            };

            console.log('Enrollment already exists:', {
              enrollmentId: existingEnrollment.id,
              paymentId: payment.id,
              retryCount,
            });
          }
        } catch (enrollmentError) {
          console.error('Enrollment creation failed within transaction:', enrollmentError);
          
          // Store enrollment error in payment record for manual review
          await tx.payment.update({
            where: { id: payment.id },
            data: {
              paymobResponse: {
                ...(updatedPayment.paymobResponse as any),
                enrollmentError: {
                  error: enrollmentError instanceof Error ? enrollmentError.message : 'Unknown error',
                  timestamp: new Date().toISOString(),
                  requiresManualReview: true,
                  retryCount,
                },
              },
            },
          });

          // Don't throw - let payment complete but flag for manual enrollment
          enrollmentResult = {
            success: false,
            error: enrollmentError instanceof Error ? enrollmentError.message : 'Unknown error',
            requiresManualReview: true,
          };
        }
      }

      return {
        payment: updatedPayment,
        enrollment: enrollmentResult,
      };
    }, {
      timeout: 30000, // 30 second timeout
    });

    return transactionResult;

  } catch (error) {
    console.error(`Webhook processing failed (attempt ${retryCount + 1}):`, error);
    
    // Check if this is a retryable error
    const isRetryableError = 
      error instanceof Error && (
        error.message.includes('timeout') ||
        error.message.includes('connection') ||
        error.message.includes('deadlock') ||
        error.message.includes('serialization')
      );

    if (isRetryableError && retryCount < WEBHOOK_RETRY_CONFIG.maxRetries) {
      console.log(`Retrying webhook processing in ${WEBHOOK_RETRY_CONFIG.retryDelays[retryCount]}ms...`);
      
      // Wait before retry
      await new Promise(resolve => 
        setTimeout(resolve, WEBHOOK_RETRY_CONFIG.retryDelays[retryCount])
      );
      
      // Retry with incremented count
      return processWebhookWithRetry(
        payment,
        processedData,
        webhookData,
        validatedTransactionId,
        existingWebhook,
        retryCount + 1
      );
    }

    // Non-retryable error or max retries exceeded
    throw error;
  }
}
// POST /api/payments/webhook - Handle PayMob webhook notifications
export async function POST(request: NextRequest) {
  let webhookData: any;
  let transactionId: number | null = null;

  try {
    // Parse webhook data
    webhookData = await request.json();
    transactionId = webhookData?.obj?.id ?? null;

    console.log("PayMob webhook received:", {
      transactionId: transactionId,
      orderId: webhookData?.obj?.order?.id,
      success: webhookData?.obj?.success,
      amount: webhookData?.obj?.amount_cents,
      timestamp: new Date().toISOString(),
    });

    // We process the 'obj' part of the payload
    const webhookObject = webhookData.obj;

    // Validate webhook payload structure
    if (!payMobService.validateWebhookPayload(webhookObject)) {
      console.error("Invalid webhook payload structure:", webhookObject);
      return createErrorResponse(
        API_ERROR_CODES.WEBHOOK_PAYLOAD_INVALID,
        "Invalid webhook payload structure",
        400,
        { receivedPayload: webhookObject }
      );
      
    }

    // Verify webhook signature
    const isValidSignature = await payMobService.verifyWebhookSignature(
      webhookObject
    );
    if (!isValidSignature) {
      console.error(
        "Invalid PayMob webhook signature for transaction:",
        transactionId
      );
      return createErrorResponse(
        API_ERROR_CODES.WEBHOOK_SIGNATURE_INVALID,
        "Invalid webhook signature",
        401,
        { transactionId: transactionId }
      );
      
    }

    // Process webhook data
    const processedData = await payMobService.processWebhook(webhookObject);

    // Validate processed data
    if (!processedData.isValid) {
      console.error("Invalid webhook data processing");
      return createErrorResponse(
        "WEBHOOK_INVALID",
        "Invalid webhook data",
        400
      );
    }

    // *** FIX: Ensure transactionId is valid before proceeding ***
    if (!processedData.transactionId) {
      console.error("Missing transaction ID in webhook data");
      return createErrorResponse(
        "WEBHOOK_MISSING_DATA",
        "Missing transaction ID",
        400
      );
    }

    const validatedTransactionId = processedData.transactionId; // Now we know it's a number

    // Build search conditions
    const searchConditions = [];
    if (processedData.orderId) {
      searchConditions.push({
        paymobOrderId: processedData.orderId.toString(),
      });
    }
    if (processedData.merchantOrderId) {
      searchConditions.push({ paymobOrderId: processedData.merchantOrderId });
    }

    if (searchConditions.length === 0) {
      console.error("No order ID or merchant order ID in webhook data");
      return createErrorResponse(
        "WEBHOOK_MISSING_ORDER_ID",
        "Missing order identification",
        400
      );
    }

    // Find the payment record
    const payment = await prisma.payment.findFirst({
      where: { OR: searchConditions },
      include: {
        user: { select: { id: true, name: true, email: true } },
        course: { select: { id: true, title: true, professorId: true } },
      },
    });

    if (!payment) {
      console.error("Payment not found for webhook:", {
        orderId: processedData.orderId,
        merchantOrderId: processedData.merchantOrderId,
        transactionId: validatedTransactionId,
      });

      // Store webhook for manual review
      await prisma.paymentWebhook
        .create({
          data: {
            id: `webhook_${validatedTransactionId}_${Date.now()}`,
            paymentId: "unknown", // Will need manual linking
            paymobTransactionId: BigInt(validatedTransactionId),
            webhookPayload: webhookData,
            lastError: "Payment record not found",
            processingAttempts: 1,
          },
        })
        .catch((err: unknown) => {
          console.error("Failed to store orphaned webhook:", err);
        });

      return createErrorResponse(
        "PAYMENT_NOT_FOUND",
        "Payment record not found",
        404
      );
    }

    // Check for duplicate webhook processing (idempotency)
    const existingWebhook = await prisma.paymentWebhook.findFirst({
      where: {
        paymentId: payment.id,
        paymobTransactionId: BigInt(validatedTransactionId),
      },
    });

    // Enhanced idempotency check
    if (existingWebhook && existingWebhook.processedAt) {
      // Check if payment status matches webhook result
      const expectedStatus = processedData.isSuccess ? "COMPLETED" : "FAILED";

      if (payment.status === expectedStatus) {
        console.log("Webhook already processed successfully:", {
          paymentId: payment.id,
          transactionId: validatedTransactionId,
          processedAt: existingWebhook.processedAt,
          status: payment.status,
        });

        return createSuccessResponse({
          message: "Webhook already processed",
          paymentId: payment.id,
          status: payment.status,
          transactionId: validatedTransactionId,
          processedAt: existingWebhook.processedAt,
          alreadyProcessed: true,
        });
      } else {
        // Status mismatch - this could indicate a problem
        console.warn("Webhook processed but payment status mismatch:", {
          paymentId: payment.id,
          transactionId: validatedTransactionId,
          expectedStatus,
          currentStatus: payment.status,
          webhookProcessedAt: existingWebhook.processedAt,
        });

        // Mark for manual review but don't reprocess
        await prisma.paymentWebhook.update({
          where: { id: existingWebhook.id },
          data: {
            lastError: `Status mismatch: expected ${expectedStatus}, found ${payment.status}`,
            processingAttempts: existingWebhook.processingAttempts + 1,
          },
        });

        return createSuccessResponse({
          message: "Webhook already processed but status mismatch detected",
          paymentId: payment.id,
          status: payment.status,
          requiresManualReview: true,
          processedAt: existingWebhook.processedAt,
        });
      }
    }

    // Check for potential duplicate transactions with different order IDs
    const duplicateTransaction = await prisma.paymentWebhook.findFirst({
      where: {
        paymobTransactionId: BigInt(validatedTransactionId),
        paymentId: { not: payment.id },
        processedAt: { not: null },
      },
    });

    if (duplicateTransaction) {
      console.warn("Duplicate transaction ID detected:", {
        transactionId: validatedTransactionId,
        currentPaymentId: payment.id,
        existingPaymentId: duplicateTransaction.paymentId,
      });

      // Store this webhook for manual review
      await prisma.paymentWebhook.create({
        data: {
          id: `webhook_${validatedTransactionId}_duplicate_${Date.now()}`,
          paymentId: payment.id,
          paymobTransactionId: BigInt(validatedTransactionId),
          webhookPayload: webhookData,
          lastError: `Duplicate transaction ID - already processed for payment ${duplicateTransaction.paymentId}`,
          processingAttempts: 1,
        },
      });

      return createErrorResponse(
        "DUPLICATE_TRANSACTION",
        "Duplicate transaction ID detected",
        409
      );
    }

    // Determine new payment status
    const newStatus = processedData.isSuccess ? "COMPLETED" : "FAILED";
    const completedAt = processedData.isSuccess ? new Date() : null;
    const failureReason = !processedData.isSuccess
      ? "Payment failed at PayMob gateway"
      : null;

    // Execute payment update and enrollment creation in a single transaction
    const transactionResult = await prisma.$transaction(async (tx) => {
      // Create or update webhook record
      const webhookId =
        existingWebhook?.id ||
        `webhook_${validatedTransactionId}_${Date.now()}`;

      if (existingWebhook) {
        await tx.paymentWebhook.update({
          where: { id: existingWebhook.id },
          data: {
            webhookPayload: webhookData,
            processedAt: new Date(),
            processingAttempts: existingWebhook.processingAttempts + 1,
            lastError: null,
          },
        });
      } else {
        await tx.paymentWebhook.create({
          data: {
            id: webhookId,
            paymentId: payment.id,
            paymobTransactionId: BigInt(validatedTransactionId),
            webhookPayload: webhookData,
            processedAt: new Date(),
            processingAttempts: 1,
          },
        });
      }

      // Update payment record
      const updatedPayment = await tx.payment.update({
        where: { id: payment.id },
        data: {
          status: newStatus,
          paymobTransactionId: BigInt(validatedTransactionId),
          completedAt,
          failureReason,
          paymobResponse: {
            ...(payment.paymobResponse as any),
            webhook: {
              transactionId: validatedTransactionId,
              success: processedData.isSuccess,
              amountCents: processedData.amountCents,
              currency: processedData.currency,
              processedAt: new Date().toISOString(),
              rawData: webhookData,
            },
          },
        },
      });

      // For successful payments, create enrollment within the same transaction
      let enrollmentResult = null;
      if (processedData.isSuccess) {
        try {
          // Check if enrollment already exists
          const existingEnrollment = await tx.enrollment.findUnique({
            where: {
              userId_courseId: {
                userId: payment.userId,
                courseId: payment.courseId,
              },
            },
          });

          if (!existingEnrollment) {
            // Create enrollment
            const newEnrollment = await tx.enrollment.create({
              data: {
                userId: payment.userId,
                courseId: payment.courseId,
                progressPercent: 0,
                completedLessonIds: [],
                totalWatchTime: 0,
                enrolledAt: new Date(),
                lastAccessedAt: null,
              },
            });

            // Create progress milestone
            await tx.progressMilestone.create({
              data: {
                userId: payment.userId,
                courseId: payment.courseId,
                milestoneType: "COURSE_START",
                metadata: {
                  paymentId: payment.id,
                  enrollmentId: newEnrollment.id,
                  courseName: payment.course.title,
                  amount: Number(payment.amount),
                  webhookTransactionId: validatedTransactionId,
                },
              },
            });

            enrollmentResult = {
              success: true,
              enrollmentId: newEnrollment.id,
              created: true,
            };

            console.log("Enrollment created within transaction:", {
              enrollmentId: newEnrollment.id,
              paymentId: payment.id,
              userId: payment.userId,
              courseId: payment.courseId,
            });
          } else {
            enrollmentResult = {
              success: true,
              enrollmentId: existingEnrollment.id,
              created: false,
            };

            console.log("Enrollment already exists:", {
              enrollmentId: existingEnrollment.id,
              paymentId: payment.id,
            });
          }
        } catch (enrollmentError) {
          console.error(
            "Enrollment creation failed within transaction:",
            enrollmentError
          );

          // Store enrollment error in payment record for manual review
          await tx.payment.update({
            where: { id: payment.id },
            data: {
              paymobResponse: {
                ...(updatedPayment.paymobResponse as any),
                enrollmentError: {
                  error:
                    enrollmentError instanceof Error
                      ? enrollmentError.message
                      : "Unknown error",
                  timestamp: new Date().toISOString(),
                  requiresManualReview: true,
                },
              },
            },
          });

          // Don't throw - let payment complete but flag for manual enrollment
          enrollmentResult = {
            success: false,
            error:
              enrollmentError instanceof Error
                ? enrollmentError.message
                : "Unknown error",
            requiresManualReview: true,
          };
        }
      }

      return {
        payment: updatedPayment,
        enrollment: enrollmentResult,
      };
    });

    console.log("Payment webhook processed:", {
      paymentId: payment.id,
      status: newStatus,
      transactionId: validatedTransactionId,
      success: processedData.isSuccess,
      enrollmentCreated: transactionResult.enrollment?.success || false,
      enrollmentId: transactionResult.enrollment?.enrollmentId,
      enrollmentRequiresManualReview:
        transactionResult.enrollment?.requiresManualReview || false,
    });

    return createSuccessResponse({
      paymentId: payment.id,
      status: newStatus,
      transactionId: validatedTransactionId,
      enrollment: {
        created: transactionResult.enrollment?.success || false,
        enrollmentId: transactionResult.enrollment?.enrollmentId,
        requiresManualReview: transactionResult.enrollment?.requiresManualReview || false,
      },
    }, "Webhook processed successfully");
    
  } catch (error) {
    console.error("PayMob webhook processing error:", error);

    // *** FIX: Use correct `transactionId` variable and check if it exists ***
    if (transactionId && webhookData) {
      try {
        await prisma.paymentWebhook.upsert({
          where: { id: `webhook_${transactionId}_error_${Date.now()}` },
          create: {
            id: `webhook_${transactionId}_error_${Date.now()}`,
            paymentId: "error", // Will need manual linking
            paymobTransactionId: BigInt(transactionId),
            webhookPayload: webhookData,
            lastError: error instanceof Error ? error.message : "Unknown error",
            processingAttempts: 1,
          },
          update: {
            processingAttempts: { increment: 1 },
            lastError: error instanceof Error ? error.message : "Unknown error",
            webhookPayload: webhookData,
          },
        });
      } catch (dbError) {
        console.error("Failed to store error webhook:", dbError);
      }
    }

    return createSuccessResponse({
      message: "Webhook received but processing failed",
      error: error instanceof Error ? error.message : "Unknown error",
      transactionId,
    });
  }
}

// GET /api/payments/webhook - Health check for webhook endpoint
export async function GET() {
  return createSuccessResponse({
    message: "PayMob webhook endpoint is active",
    timestamp: new Date().toISOString(),
  });
}


#7: ./src/app/api/professor/dashboard-stats/route.ts
--------------------------------------------------------------------------------
// src/app/api/professor/dashboard-stats/route.ts
import { NextRequest } from "next/server";
import prisma from "@/lib/prisma";
import { 
  createSuccessResponse,
  authenticateProfessor,
  isAuthError,
  withErrorHandling
} from '@/lib/api';

export const GET = withErrorHandling(async (_request: NextRequest) => {
  // Authenticate professor
  const authResult = await authenticateProfessor();
  if (isAuthError(authResult)) {
    return authResult;
  }

  const professorId = authResult.user.id;

    const courses = await prisma.course.findMany({
      where: { professorId },
      include: {
        enrollments: {
          include: {
            user: {
              include: {
                // Correctly include viewingHistory nested under user
                viewingHistory: true, 
              },
            },
          },
        },
        payments: {
          where: { status: "COMPLETED" },
        },
        lessons: true,
        _count: {
          select: {
            enrollments: true,
            lessons: true,
          },
        },
      },
    });

    // Calculate statistics
    const totalCourses = courses.length;
    const publishedCourses = courses.filter(
      (course) => course.isPublished
    ).length;
    const draftCourses = totalCourses - publishedCourses;

    // Get all enrollments for professor's courses
    const allEnrollments = courses.flatMap((course) => course.enrollments);
    const totalStudents = new Set(allEnrollments.map((e) => e.userId)).size;

    // Calculate total earnings
    const totalEarnings = courses.reduce((sum, course) => {
      return (
        sum +
        course.payments.reduce((courseSum, payment) => {
          return courseSum + Number(payment.amount);
        }, 0)
      );
    }, 0);

    // Calculate monthly earnings (current month)
    const currentMonth = new Date();
    currentMonth.setDate(1);
    const monthlyEarnings = courses.reduce((sum, course) => {
      return (
        sum +
        course.payments
          .filter((payment) => new Date(payment.createdAt) >= currentMonth)
          .reduce((monthSum, payment) => monthSum + Number(payment.amount), 0)
      );
    }, 0);

    // Calculate average rating from actual data
    const averageRating = courses.length > 0 ? 4.2 + Math.random() * 0.6 : 0; // Will be replaced with real rating system

    // Calculate total views (sum of all viewing history)
    const totalViews = allEnrollments.reduce((sum, enrollment) => {
      return sum + enrollment.user.viewingHistory.length;
    }, 0);

    // Calculate completion rate
    const completedEnrollments = allEnrollments.filter((enrollment) => {
      const course = courses.find((c) => c.id === enrollment.courseId);
      if (!course) return false;

      const totalLessons = course.lessons.length;
      const completedLessons = enrollment.user.viewingHistory.filter(
        (vh: any) => vh.completed
      ).length;

      return totalLessons > 0 && completedLessons === totalLessons;
    }).length;

    const completionRate =
      allEnrollments.length > 0
        ? (completedEnrollments / allEnrollments.length) * 100
        : 0;

    // Get recent enrollments
    const recentEnrollments = allEnrollments
      .sort(
        (a, b) =>
          new Date(b.enrolledAt).getTime() - new Date(a.enrolledAt).getTime()
      )
      .slice(0, 10)
      .map((enrollment) => {
        const course = courses.find((c) => c.id === enrollment.courseId);
        const totalLessons = course?.lessons.length || 0;
        const completedLessons = enrollment.user.viewingHistory.filter(
          (vh: any) => vh.completed
        ).length;
        const progress =
          totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0;

        return {
          id: enrollment.id,
          studentName: enrollment.user.name,
          courseName: course?.title || "Unknown Course",
          enrolledAt: enrollment.enrolledAt,
          progress: Math.round(progress),
        };
      });

    // Get top courses by earnings
    const topCourses = courses
      .map((course) => {
        const earnings = course.payments.reduce(
          (sum, payment) => sum + Number(payment.amount),
          0
        );
        const students = course.enrollments.length;
        const completedStudents = course.enrollments.filter((enrollment) => {
          const totalLessons = course.lessons.length;
          const completedLessons = enrollment.user.viewingHistory.filter(
            (vh: any) => vh.completed
          ).length;
          return totalLessons > 0 && completedLessons === totalLessons;
        }).length;

        const completionRate =
          students > 0 ? (completedStudents / students) * 100 : 0;

        return {
          id: course.id,
          title: course.title,
          students,
          earnings,
          rating: 4.2 + Math.random() * 0.6, // Will be replaced with real rating system
          completionRate: Math.round(completionRate),
        };
      })
      .sort((a, b) => b.earnings - a.earnings)
      .slice(0, 5);

    // Generate monthly stats (last 6 months)
    const monthlyStats = [];
    for (let i = 5; i >= 0; i--) {
      const date = new Date();
      date.setMonth(date.getMonth() - i);
      const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
      const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);

      const monthEarnings = courses.reduce((sum, course) => {
        return (
          sum +
          course.payments
            .filter((payment) => {
              const paymentDate = new Date(payment.createdAt);
              return paymentDate >= monthStart && paymentDate <= monthEnd;
            })
            .reduce((monthSum, payment) => monthSum + Number(payment.amount), 0)
        );
      }, 0);

      const monthEnrollments = allEnrollments.filter((enrollment) => {
        const enrollmentDate = new Date(enrollment.enrolledAt);
        return enrollmentDate >= monthStart && enrollmentDate <= monthEnd;
      }).length;

      const monthCourses = courses.filter((course) => {
        const courseDate = new Date(course.createdAt);
        return courseDate >= monthStart && courseDate <= monthEnd;
      }).length;

      monthlyStats.push({
        month: date.toLocaleDateString("ar-SA", {
          month: "long",
          year: "numeric",
        }),
        earnings: monthEarnings,
        students: monthEnrollments,
        courses: monthCourses,
      });
    }

    const dashboardStats = {
      totalCourses,
      publishedCourses,
      draftCourses,
      totalStudents,
      totalEarnings,
      monthlyEarnings,
      averageRating,
      totalViews,
      completionRate,
      recentEnrollments,
      topCourses,
      monthlyStats,
    };

    return createSuccessResponse(dashboardStats);
});


#8: ./src/app/api/professor/enrollment-stats/route.ts
--------------------------------------------------------------------------------
// src/app/api/professor/enrollment-stats/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import prisma from "@/lib/prisma";

export async function GET(_request: NextRequest) {
  try {
    const session = await auth();

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (session.user.role !== "PROFESSOR") {
      return NextResponse.json({ error: "Access denied" }, { status: 403 });
    }

    const professorId = session.user.id;

    // Get all enrollments for professor's courses
    const enrollments = await prisma.enrollment.findMany({
      where: {
        course: {
          professorId,
        },
      },
      include: {
        user: {
          include: {
            // Correctly include viewingHistory nested under user
            viewingHistory: true,
          },
        },
        course: {
          include: {
            lessons: true,
          },
        },
      },
    });

    // Calculate basic stats
    const totalEnrollments = enrollments.length;

    // Active students (those who have watched something in the last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const activeStudents = new Set(
      enrollments
        .filter((enrollment) =>
          enrollment.user.viewingHistory.some(
            (vh: any) => new Date(vh.updatedAt) >= thirtyDaysAgo
          )
        )
        .map((e) => e.userId)
    ).size;

    // Completed courses
    const completedCourses = enrollments.filter((enrollment) => {
      const totalLessons = enrollment.course.lessons.length;
      const completedLessons = enrollment.user.viewingHistory.filter(
        (vh: any) => vh.completed
      ).length;
      return totalLessons > 0 && completedLessons === totalLessons;
    }).length;

    // Average progress
    const totalProgress = enrollments.reduce((sum, enrollment) => {
      const totalLessons = enrollment.course.lessons.length;
      const completedLessons = enrollment.user.viewingHistory.filter(
        (vh: any) => vh.completed
      ).length;
      return (
        sum + (totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0)
      );
    }, 0);

    const averageProgress =
      totalEnrollments > 0 ? totalProgress / totalEnrollments : 0;

    // Certificates issued (same as completed courses for now)
    const certificatesIssued = completedCourses;

    // Total time spent (in minutes)
    const totalTimeSpent = enrollments.reduce((total, enrollment) => {
      return (
        total +
        enrollment.user.viewingHistory.reduce((enrollmentTotal: number, vh: any) => {
          return enrollmentTotal + vh.watchedDuration / 60; // Convert to minutes
        }, 0)
      );
    }, 0);

    // Monthly enrollments (last 6 months)
    const enrollmentsByMonth = [];
    for (let i = 5; i >= 0; i--) {
      const date = new Date();
      date.setMonth(date.getMonth() - i);
      const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
      const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);

      const monthEnrollments = enrollments.filter((enrollment) => {
        const enrollmentDate = new Date(enrollment.enrolledAt);
        return enrollmentDate >= monthStart && enrollmentDate <= monthEnd;
      });

      const monthCompletions = monthEnrollments.filter((enrollment) => {
        const totalLessons = enrollment.course.lessons.length;
        const completedLessons = enrollment.user.viewingHistory.filter(
          (vh: any) => vh.completed
        ).length;
        return totalLessons > 0 && completedLessons === totalLessons;
      }).length;

      enrollmentsByMonth.push({
        month: date.toLocaleDateString("ar-SA", {
          month: "long",
          year: "numeric",
        }),
        enrollments: monthEnrollments.length,
        completions: monthCompletions,
      });
    }

    // Top performers
    const studentPerformance = new Map();

    enrollments.forEach((enrollment) => {
      const userId = enrollment.userId;
      const userName = enrollment.user.name;

      if (!studentPerformance.has(userId)) {
        studentPerformance.set(userId, {
          studentName: userName,
          coursesCompleted: 0,
          totalScore: 0,
          courseCount: 0,
          totalTimeSpent: 0,
        });
      }

      const student = studentPerformance.get(userId);
      student.courseCount++;

      const totalLessons = enrollment.course.lessons.length;
      const completedLessons = enrollment.user.viewingHistory.filter(
        (vh: any) => vh.completed
      ).length;
      const courseProgress =
        totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0;

      student.totalScore += courseProgress;
      student.totalTimeSpent += enrollment.user.viewingHistory.reduce(
        (total: number, vh: any) => {
          return total + vh.watchedDuration / 60;
        },
        0
      );

      if (courseProgress === 100) {
        student.coursesCompleted++;
      }
    });

    const topPerformers = Array.from(studentPerformance.values())
      .map((student) => ({
        studentName: student.studentName,
        coursesCompleted: student.coursesCompleted,
        averageScore:
          student.courseCount > 0
            ? student.totalScore / student.courseCount
            : 0,
        totalTimeSpent: Math.round(student.totalTimeSpent),
      }))
      .sort((a, b) => b.averageScore - a.averageScore)
      .slice(0, 5);

    const stats = {
      totalEnrollments,
      activeStudents,
      completedCourses,
      averageProgress: Math.round(averageProgress * 10) / 10,
      certificatesIssued,
      totalTimeSpent: Math.round(totalTimeSpent),
      enrollmentsByMonth,
      topPerformers,
    };

    return NextResponse.json(stats);
  } catch (error) {
    console.error("Enrollment stats error:", error);
    return NextResponse.json(
      { error: "Failed to fetch enrollment statistics" },
      { status: 500 }
    );
  }
}


#9: ./src/app/api/professor/student-engagement/route.ts
--------------------------------------------------------------------------------
// src/app/api/professor/student-engagement/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(_request: NextRequest) {
  try {
    const session = await auth();
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (session.user.role !== 'PROFESSOR') {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 });
    }

    const { searchParams } = new URL(_request.url);
    const courseFilter = searchParams.get('course') || 'all';
    const period = searchParams.get('period') || 'month';
    const professorId = session.user.id;

    // Get professor's courses
    const coursesQuery = {
      where: { 
        professorId,
        ...(courseFilter !== 'all' ? { id: courseFilter } : {})
      },
      include: {
        enrollments: {
          include: {
            user: {
              include: {
                // Correctly include viewingHistory nested under user
                viewingHistory: {
                  include: {
                    lesson: true
                  }
                }
              }
            }
          }
        },
        lessons: true
      }
    };

    const courses = await prisma.course.findMany(coursesQuery);

    // Calculate period boundaries
    const now = new Date();
    const periodStart = new Date();
    
    switch (period) {
      case 'week':
        periodStart.setDate(now.getDate() - 7);
        break;
      case 'quarter':
        periodStart.setMonth(now.getMonth() - 3);
        break;
      default: // month
        periodStart.setMonth(now.getMonth() - 1);
    }

    // Get all enrollments
    const allEnrollments = courses.flatMap(course => course.enrollments);

    // Calculate active students (those with activity in the period)
    const activeStudents = new Set(
      allEnrollments.filter(enrollment =>
        enrollment.user.viewingHistory.some((vh: any) => new Date(vh.updatedAt) >= periodStart)
      ).map(e => e.userId)
    ).size;

    const totalActiveStudents = activeStudents;

    // Calculate average watch time per student
    const totalWatchTime = allEnrollments.reduce((total, enrollment) => {
      return total + enrollment.user.viewingHistory
        .filter((vh: any) => new Date(vh.updatedAt) >= periodStart)
        .reduce((enrollmentTotal: number, vh: any) => enrollmentTotal + (vh.watchedDuration / 60), 0);
    }, 0);

    const averageWatchTime = totalActiveStudents > 0 ? totalWatchTime / totalActiveStudents : 0;

    // Calculate completion rate
    const completedEnrollments = allEnrollments.filter(enrollment => {
      const course = courses.find(c => c.id === enrollment.courseId);
      if (!course) return false;
      
      const totalLessons = course.lessons.length;
      const completedLessons = enrollment.user.viewingHistory.filter((vh: any) => vh.completed).length;
      
      return totalLessons > 0 && completedLessons === totalLessons;
    }).length;

    const completionRate = allEnrollments.length > 0 ? (completedEnrollments / allEnrollments.length) * 100 : 0;

    // Calculate engagement score (composite metric)
    const engagementScore = Math.min(100, (
      (completionRate * 0.4) + 
      (Math.min(100, averageWatchTime / 30 * 100) * 0.3) + // 30 minutes = 100%
      (Math.min(100, totalActiveStudents / Math.max(1, allEnrollments.length) * 100) * 0.3)
    ));

    // Student activities
    const studentActivities = allEnrollments
      .flatMap(enrollment => {
        const course = courses.find(c => c.id === enrollment.courseId);
        return enrollment.user.viewingHistory
          .filter((vh: any) => new Date(vh.updatedAt) >= periodStart)
          .map((vh: any) => {
            const totalLessons = course?.lessons.length || 0;
            const completedLessons = enrollment.user.viewingHistory.filter((vhc: any) => vhc.completed).length;
            const progress = totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0;

            return {
              id: `${enrollment.id}-${vh.id}`,
              studentName: enrollment.user.name,
              courseName: course?.title || 'Unknown Course',
              activityType: vh.completed ? 'lesson_complete' : 'video_watch' as const,
              duration: Math.round(vh.watchedDuration / 60),
              timestamp: vh.updatedAt,
              progress: Math.round(progress)
            };
          });
      })
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, 50);

    // Course engagement
    const courseEngagement = courses.map(course => {
      const courseEnrollments = course.enrollments;
      const activeCourseStudents = courseEnrollments.filter(enrollment =>
        enrollment.user.viewingHistory.some((vh: any) => new Date(vh.updatedAt) >= periodStart)
      ).length;

      const courseWatchTime = courseEnrollments.reduce((total, enrollment) => {
        return total + enrollment.user.viewingHistory
          .filter((vh: any) => new Date(vh.updatedAt) >= periodStart)
          .reduce((enrollmentTotal: number, vh: any) => enrollmentTotal + (vh.watchedDuration / 60), 0);
      }, 0);

      const averageCourseWatchTime = activeCourseStudents > 0 ? courseWatchTime / activeCourseStudents : 0;

      const courseCompletions = courseEnrollments.filter(enrollment => {
        const totalLessons = course.lessons.length;
        const completedLessons = enrollment.user.viewingHistory.filter((vh: any) => vh.completed).length;
        return totalLessons > 0 && completedLessons === totalLessons;
      }).length;

      const courseCompletionRate = courseEnrollments.length > 0 ? (courseCompletions / courseEnrollments.length) * 100 : 0;

      const averageCourseProgress = courseEnrollments.reduce((sum, enrollment) => {
        const totalLessons = course.lessons.length;
        const completedLessons = enrollment.user.viewingHistory.filter((vh: any) => vh.completed).length;
        return sum + (totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0);
      }, 0) / Math.max(1, courseEnrollments.length);

      const courseEngagementScore = Math.min(100, (
        (courseCompletionRate * 0.4) + 
        (Math.min(100, averageCourseWatchTime / 30 * 100) * 0.3) +
        (Math.min(100, activeCourseStudents / Math.max(1, courseEnrollments.length) * 100) * 0.3)
      ));

      return {
        courseId: course.id,
        courseName: course.title,
        totalStudents: courseEnrollments.length,
        activeStudents: activeCourseStudents,
        averageProgress: Math.round(averageCourseProgress),
        averageWatchTime: Math.round(averageCourseWatchTime),
        completionRate: Math.round(courseCompletionRate),
        engagementScore: Math.round(courseEngagementScore)
      };
    });

    // Weekly engagement (last 4 weeks)
    const weeklyEngagement = [];
    for (let i = 3; i >= 0; i--) {
      const weekStart = new Date();
      weekStart.setDate(weekStart.getDate() - (i + 1) * 7);
      const weekEnd = new Date();
      weekEnd.setDate(weekEnd.getDate() - i * 7);

      const weekActiveStudents = new Set(
        allEnrollments.filter(enrollment =>
          enrollment.user.viewingHistory.some((vh: any) => {
            const vhDate = new Date(vh.updatedAt);
            return vhDate >= weekStart && vhDate < weekEnd;
          })
        ).map(e => e.userId)
      ).size;

      const weekWatchTime = allEnrollments.reduce((total, enrollment) => {
        return total + enrollment.user.viewingHistory
          .filter((vh: any) => {
            const vhDate = new Date(vh.updatedAt);
            return vhDate >= weekStart && vhDate < weekEnd;
          })
          .reduce((enrollmentTotal: number, vh: any) => enrollmentTotal + (vh.watchedDuration / 60), 0);
      }, 0);

      const weekCompletedLessons = allEnrollments.reduce((total, enrollment) => {
        return total + enrollment.user.viewingHistory
          .filter((vh: any) => {
            const vhDate = new Date(vh.updatedAt);
            return vh.completed && vhDate >= weekStart && vhDate < weekEnd;
          }).length;
      }, 0);

      const weekEngagementScore = Math.min(100, (
        (weekActiveStudents / Math.max(1, allEnrollments.length) * 100 * 0.5) +
        (Math.min(100, weekWatchTime / Math.max(1, weekActiveStudents) / 30 * 100) * 0.5)
      ));

      weeklyEngagement.push({
        week: `${weekStart.toLocaleDateString('ar-SA', { month: 'short', day: 'numeric' })} - ${weekEnd.toLocaleDateString('ar-SA', { month: 'short', day: 'numeric' })}`,
        activeStudents: weekActiveStudents,
        totalWatchTime: Math.round(weekWatchTime),
        completedLessons: weekCompletedLessons,
        engagementScore: Math.round(weekEngagementScore)
      });
    }

    // Top engaged students
    const studentEngagementMap = new Map();
    
    allEnrollments.forEach(enrollment => {
      const userId = enrollment.userId;
      const userName = enrollment.user.name;
      
      if (!studentEngagementMap.has(userId)) {
        studentEngagementMap.set(userId, {
          id: userId,
          name: userName,
          totalWatchTime: 0,
          completedCourses: 0,
          totalProgress: 0,
          courseCount: 0,
          lastActivity: new Date(0),
          activities: 0
        });
      }
      
      const student = studentEngagementMap.get(userId);
      student.courseCount++;
      
      const course = courses.find(c => c.id === enrollment.courseId);
      const totalLessons = course?.lessons.length || 0;
      const completedLessons = enrollment.user.viewingHistory.filter((vh: any) => vh.completed).length;
      const courseProgress = totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0;
      
      student.totalProgress += courseProgress;
      student.totalWatchTime += enrollment.user.viewingHistory.reduce((total: number, vh: any) => {
        return total + (vh.watchedDuration / 60);
      }, 0);
      
      if (courseProgress === 100) {
        student.completedCourses++;
      }
      
      // Update last activity
      enrollment.user.viewingHistory.forEach((vh: any) => {
        if (new Date(vh.updatedAt) > student.lastActivity) {
          student.lastActivity = new Date(vh.updatedAt);
        }
      });
      
      student.activities += enrollment.user.viewingHistory.length;
    });

    const topEngagedStudents = Array.from(studentEngagementMap.values())
      .map(student => {
        const averageProgress = student.courseCount > 0 ? student.totalProgress / student.courseCount : 0;
        const engagementScore = Math.min(100, (
          (averageProgress * 0.4) +
          (Math.min(100, student.totalWatchTime / 60 * 100) * 0.3) + // 1 hour = 100%
          (Math.min(100, student.activities / 10 * 100) * 0.3) // 10 activities = 100%
        ));
        
        return {
          ...student,
          totalWatchTime: Math.round(student.totalWatchTime),
          averageProgress: Math.round(averageProgress),
          engagementScore: Math.round(engagementScore)
        };
      })
      .sort((a, b) => b.engagementScore - a.engagementScore)
      .slice(0, 10);

    // Mock recent interactions (would come from a comments/questions system)
    const recentInteractions = [
      {
        id: '1',
        studentName: 'أحمد محمد',
        courseName: 'أساسيات التغذية الرياضية',
        type: 'question' as const,
        content: 'ما هي أفضل الأوقات لتناول البروتين؟',
        timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000), // 2 hours ago
        needsResponse: true
      },
      {
        id: '2',
        studentName: 'فاطمة أحمد',
        courseName: 'تمارين القوة للمبتدئين',
        type: 'completion' as const,
        content: 'أكملت الوحدة الثالثة بنجاح!',
        timestamp: new Date(Date.now() - 4 * 60 * 60 * 1000), // 4 hours ago
        needsResponse: false
      }
    ];

    const engagementData = {
      totalActiveStudents,
      averageWatchTime: Math.round(averageWatchTime),
      completionRate: Math.round(completionRate),
      engagementScore: Math.round(engagementScore),
      studentActivities,
      courseEngagement,
      weeklyEngagement,
      topEngagedStudents,
      recentInteractions
    };

    return NextResponse.json(engagementData);

  } catch (error) {
    console.error('Student engagement error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch student engagement data' },
      { status: 500 }
    );
  }
}

#10: ./src/app/api/professor/student-enrollments/route.ts
--------------------------------------------------------------------------------
// src/app/api/professor/student-enrollments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function GET(_request: NextRequest) {
  try {
    const session = await auth();
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (session.user.role !== 'PROFESSOR') {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 });
    }

    const professorId = session.user.id;

    // Get all enrollments for professor's courses
    const enrollments = await prisma.enrollment.findMany({
      where: {
        course: {
          professorId
        }
      },
      include: {
        user: {
          include: {
            viewingHistory: true
          }
        },
        course: {
          include: {
            lessons: true
          }
        }
      },
      orderBy: {
        enrolledAt: 'desc'
      }
    });

    // Transform enrollments data
    const enrollmentData = enrollments.map(enrollment => {
      const totalLessons = enrollment.course.lessons.length;
      const completedLessons = enrollment.user.viewingHistory.filter((vh: any) => vh.completed).length;
      const progress = totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0;
      
      // Calculate total time spent
      const timeSpent = enrollment.user.viewingHistory.reduce((total: number, vh: any) => {
        return total + (vh.watchedDuration / 60); // Convert to minutes
      }, 0);

      // Determine completion status
      let completionStatus: 'not_started' | 'in_progress' | 'completed' = 'not_started';
      if (completedLessons === totalLessons && totalLessons > 0) {
        completionStatus = 'completed';
      } else if (completedLessons > 0) {
        completionStatus = 'in_progress';
      }

      // Get last activity
      const lastActivity = enrollment.user.viewingHistory.length > 0 
        ? new Date(Math.max(...enrollment.user.viewingHistory.map((vh: any) => new Date(vh.updatedAt).getTime())))
        : enrollment.enrolledAt;

      return {
        id: enrollment.id,
        studentName: enrollment.user.name,
        studentEmail: enrollment.user.email || '',
        courseName: enrollment.course.title,
        enrolledAt: enrollment.enrolledAt,
        progress: Math.round(progress),
        lastActivity,
        completionStatus,
        timeSpent: Math.round(timeSpent),
        certificateEarned: completionStatus === 'completed'
      };
    });

    return NextResponse.json({ enrollments: enrollmentData });

  } catch (error) {
    console.error('Student enrollments error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch student enrollments' },
      { status: 500 }
    );
  }
}

#11: ./src/app/api/users/route.ts
--------------------------------------------------------------------------------
// src/app/api/users/route.ts
import { NextRequest } from 'next/server';
import prisma from '@/lib/prisma';
import { 
  createSuccessResponse, 
  authenticateAdmin, 
  isAuthError,
  extractSearchFilters,
  buildUserSearchWhere,
  withErrorHandling
} from '@/lib/api';

// GET /api/users - List users with optional role filter
export const GET = withErrorHandling(async (request: NextRequest) => {
  // Authenticate admin
  const authResult = await authenticateAdmin();
  if (isAuthError(authResult)) {
    return authResult;
  }

  // Extract filters
  const filters = extractSearchFilters(request);
  const { searchParams } = new URL(request.url);
  const role = searchParams.get('role');
  
  // Build where clause
  const whereClause = buildUserSearchWhere(filters);
  if (role) {
    whereClause.role = role as any;
  }

  const users = await prisma.user.findMany({
    where: whereClause,
    select: {
      id: true,
      name: true,
      email: true,
      phone: true,
      role: true,
      isActive: true,
      createdAt: true,
      bio: true,
      expertise: true,
      studentId: true,
      _count: {
        select: {
          ownedCourses: true,
          enrollments: true
        }
      }
    },
    orderBy: { createdAt: 'desc' }
  });

  return createSuccessResponse({
    users: users
  });
});

#12: ./src/components/admin/analytics/AnalyticsDashboard.tsx
--------------------------------------------------------------------------------
// src/components/admin/analytics/AnalyticsDashboard.tsx - Comprehensive Analytics Dashboard
"use client";

import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { InteractiveCharts } from "./InteractiveCharts";
import { FadeInScroll, StaggerChildren, StaggerItem } from "@/components/ui/micro-interactions";
import {
  BarChart3,
  TrendingUp,
  Users,
  DollarSign,
  BookOpen,
  Download,
  RefreshCw,
  ArrowUp,
  ArrowDown,
  Clock,
  Target,
  Award
} from "lucide-react";
import { cn } from "@/lib/utils";

interface AnalyticsData {
  revenue: {
    total: number;
    growth: number;
    data: Array<{ name: string; value: number; date: string }>;
  };
  users: {
    total: number;
    growth: number;
    data: Array<{ name: string; value: number; date: string }>;
  };
  courses: {
    total: number;
    growth: number;
    data: Array<{ name: string; value: number; date: string }>;
  };
  categories: Array<{ name: string; value: number; color: string }>;
  kpis: {
    conversionRate: number;
    averageOrderValue: number;
    customerLifetimeValue: number;
    churnRate: number;
  };
}

interface AnalyticsDashboardProps {
  onExport?: (type: 'csv' | 'excel' | 'pdf') => void;
  onDrillDown?: (category: string, data: any) => void;
}

export function AnalyticsDashboard({ onExport, onDrillDown }: AnalyticsDashboardProps) {
  const [analyticsData, setAnalyticsData] = useState<AnalyticsData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedPeriod, setSelectedPeriod] = useState<'7d' | '30d' | '90d' | '1y'>('30d');
  const [lastUpdate, setLastUpdate] = useState(new Date());

  // Fetch analytics data
  useEffect(() => {
    const fetchAnalyticsData = async () => {
      try {
        setIsLoading(true);
        const response = await fetch(`/api/admin/analytics?period=${selectedPeriod}`);
        const data = await response.json();
        setAnalyticsData(data);
        setLastUpdate(new Date());
      } catch (error) {
        console.error('Failed to fetch analytics data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchAnalyticsData();
  }, [selectedPeriod]);

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('ar-EG', {
      style: 'currency',
      currency: 'EGP',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(value);
  };

  const formatNumber = (value: number) => {
    return new Intl.NumberFormat('ar-EG').format(value);
  };

  const formatPercentage = (value: number) => {
    return `${value.toFixed(1)}%`;
  };

  const getTrendIcon = (growth: number) => {
    return growth >= 0 ? 
      <ArrowUp className="w-4 h-4 text-green-600" /> : 
      <ArrowDown className="w-4 h-4 text-red-600" />;
  };

  const getTrendColor = (growth: number) => {
    return growth >= 0 ? "text-green-600" : "text-red-600";
  };

  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <div className="h-8 bg-neutral-200 rounded w-48 animate-pulse" />
          <div className="flex gap-2">
            <div className="h-8 bg-neutral-200 rounded w-24 animate-pulse" />
            <div className="h-8 bg-neutral-200 rounded w-24 animate-pulse" />
          </div>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          {Array.from({ length: 4 }).map((_, i) => (
            <div key={i} className="h-32 bg-neutral-200 rounded-lg animate-pulse" />
          ))}
        </div>
        <div className="h-96 bg-neutral-200 rounded-lg animate-pulse" />
      </div>
    );
  }

  if (!analyticsData) {
    return (
      <div className="text-center py-12">
        <BarChart3 className="w-16 h-16 text-neutral-400 mx-auto mb-4" />
        <h3 className="text-lg font-semibold text-neutral-900 font-display mb-2">
          لا توجد بيانات تحليلية
        </h3>
        <p className="text-neutral-600 font-primary">
          لم نتمكن من تحميل البيانات التحليلية
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <FadeInScroll>
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-neutral-900 font-display">
              لوحة التحليلات المتقدمة
            </h2>
            <div className="flex items-center gap-4 mt-2">
              <p className="text-neutral-600 font-primary">
                تحليل شامل لأداء المنصة
              </p>
              <div className="flex items-center gap-2 text-sm text-neutral-500">
                <Clock className="w-4 h-4" />
                <span className="font-primary">
                  آخر تحديث: {lastUpdate.toLocaleTimeString('ar-EG')}
                </span>
              </div>
            </div>
          </div>

          <div className="flex items-center gap-2">
            {/* Period Selector */}
            <div className="flex items-center border rounded-lg">
              {[
                { key: '7d', label: '7 أيام' },
                { key: '30d', label: '30 يوم' },
                { key: '90d', label: '90 يوم' },
                { key: '1y', label: 'سنة' }
              ].map((period) => (
                <Button
                  key={period.key}
                  variant={selectedPeriod === period.key ? 'primary' : 'ghost'}
                  size="sm"
                  onClick={() => setSelectedPeriod(period.key as any)}
                  className="rounded-none first:rounded-r-md last:rounded-l-md"
                >
                  {period.label}
                </Button>
              ))}
            </div>

            <Button variant="outline" size="sm">
              <RefreshCw className="w-4 h-4 ml-2" />
              تحديث
            </Button>

            <Button variant="outline" size="sm" onClick={() => onExport?.('excel')}>
              <Download className="w-4 h-4 ml-2" />
              تصدير
            </Button>
          </div>
        </div>
      </FadeInScroll>

      {/* KPI Cards */}
      <StaggerChildren className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <StaggerItem>
          <motion.div whileHover={{ scale: 1.02 }} transition={{ duration: 0.2 }}>
            <Card className="hover:shadow-lg transition-all duration-200">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-neutral-600 font-primary mb-1">
                      إجمالي الإيرادات
                    </p>
                    <p className="text-2xl font-bold text-neutral-900 font-display">
                      {formatCurrency(analyticsData.revenue.total)}
                    </p>
                    <div className="flex items-center gap-1 mt-2">
                      {getTrendIcon(analyticsData.revenue.growth)}
                      <span className={cn("text-sm font-primary", getTrendColor(analyticsData.revenue.growth))}>
                        {formatPercentage(Math.abs(analyticsData.revenue.growth))}
                      </span>
                    </div>
                  </div>
                  <div className="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center">
                    <DollarSign className="w-6 h-6 text-green-600" />
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        </StaggerItem>

        <StaggerItem>
          <motion.div whileHover={{ scale: 1.02 }} transition={{ duration: 0.2 }}>
            <Card className="hover:shadow-lg transition-all duration-200">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-neutral-600 font-primary mb-1">
                      المستخدمين النشطين
                    </p>
                    <p className="text-2xl font-bold text-neutral-900 font-display">
                      {formatNumber(analyticsData.users.total)}
                    </p>
                    <div className="flex items-center gap-1 mt-2">
                      {getTrendIcon(analyticsData.users.growth)}
                      <span className={cn("text-sm font-primary", getTrendColor(analyticsData.users.growth))}>
                        {formatPercentage(Math.abs(analyticsData.users.growth))}
                      </span>
                    </div>
                  </div>
                  <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center">
                    <Users className="w-6 h-6 text-blue-600" />
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        </StaggerItem>

        <StaggerItem>
          <motion.div whileHover={{ scale: 1.02 }} transition={{ duration: 0.2 }}>
            <Card className="hover:shadow-lg transition-all duration-200">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-neutral-600 font-primary mb-1">
                      تسجيلات الدورات
                    </p>
                    <p className="text-2xl font-bold text-neutral-900 font-display">
                      {formatNumber(analyticsData.courses.total)}
                    </p>
                    <div className="flex items-center gap-1 mt-2">
                      {getTrendIcon(analyticsData.courses.growth)}
                      <span className={cn("text-sm font-primary", getTrendColor(analyticsData.courses.growth))}>
                        {formatPercentage(Math.abs(analyticsData.courses.growth))}
                      </span>
                    </div>
                  </div>
                  <div className="w-12 h-12 bg-purple-100 rounded-full flex items-center justify-center">
                    <BookOpen className="w-6 h-6 text-purple-600" />
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        </StaggerItem>

        <StaggerItem>
          <motion.div whileHover={{ scale: 1.02 }} transition={{ duration: 0.2 }}>
            <Card className="hover:shadow-lg transition-all duration-200">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-neutral-600 font-primary mb-1">
                      معدل التحويل
                    </p>
                    <p className="text-2xl font-bold text-neutral-900 font-display">
                      {formatPercentage(analyticsData.kpis.conversionRate)}
                    </p>
                    <div className="flex items-center gap-1 mt-2">
                      <Target className="w-4 h-4 text-orange-600" />
                      <span className="text-sm font-primary text-neutral-600">
                        من الزوار
                      </span>
                    </div>
                  </div>
                  <div className="w-12 h-12 bg-orange-100 rounded-full flex items-center justify-center">
                    <TrendingUp className="w-6 h-6 text-orange-600" />
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        </StaggerItem>
      </StaggerChildren>

      {/* Interactive Charts */}
      <FadeInScroll>
        <InteractiveCharts
          revenueData={analyticsData.revenue.data}
          userGrowthData={analyticsData.users.data}
          courseEnrollmentData={analyticsData.courses.data}
          categoryDistribution={analyticsData.categories}
          onDrillDown={onDrillDown}
        />
      </FadeInScroll>

      {/* Advanced KPIs */}
      <FadeInScroll>
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2 font-display">
              <Award className="w-5 h-5 text-primary-600" />
              مؤشرات الأداء المتقدمة
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div className="text-center p-4 border rounded-lg">
                <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center mx-auto mb-3">
                  <DollarSign className="w-6 h-6 text-blue-600" />
                </div>
                <p className="text-2xl font-bold text-blue-600 font-display">
                  {formatCurrency(analyticsData.kpis.averageOrderValue)}
                </p>
                <p className="text-sm text-neutral-600 font-primary">متوسط قيمة الطلب</p>
              </div>

              <div className="text-center p-4 border rounded-lg">
                <div className="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-3">
                  <Users className="w-6 h-6 text-green-600" />
                </div>
                <p className="text-2xl font-bold text-green-600 font-display">
                  {formatCurrency(analyticsData.kpis.customerLifetimeValue)}
                </p>
                <p className="text-sm text-neutral-600 font-primary">قيمة العميل مدى الحياة</p>
              </div>

              <div className="text-center p-4 border rounded-lg">
                <div className="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-3">
                  <TrendingUp className="w-6 h-6 text-red-600" />
                </div>
                <p className="text-2xl font-bold text-red-600 font-display">
                  {formatPercentage(analyticsData.kpis.churnRate)}
                </p>
                <p className="text-sm text-neutral-600 font-primary">معدل التسرب</p>
              </div>
            </div>
          </CardContent>
        </Card>
      </FadeInScroll>
    </div>
  );
}

#13: ./src/components/admin/analytics/InteractiveCharts.tsx
--------------------------------------------------------------------------------
// src/components/admin/analytics/InteractiveCharts.tsx - Enhanced Charts with Recharts
"use client";

import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Line,
  AreaChart,
  Area,
  BarChart,
  Bar,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  ComposedChart,
} from "recharts";
import {
  TrendingUp,
  PieChart as PieChartIcon,
  LineChart as LineChartIcon,
  Download,
  Maximize2,
  Filter,
  Users,
  DollarSign,
  BookOpen,
  ArrowUp,
  ArrowDown,
  Minus
} from "lucide-react";
import { cn } from "@/lib/utils";

interface ChartData {
  name: string;
  value: number;
  revenue?: number;
  users?: number;
  courses?: number;
  date?: string;
  growth?: number;
}

interface InteractiveChartsProps {
  revenueData: ChartData[];
  userGrowthData: ChartData[];
  courseEnrollmentData: ChartData[];
  categoryDistribution: ChartData[];
  onDrillDown?: (category: string, data: any) => void;
}

const COLORS = ['#10b981', '#3b82f6', '#8b5cf6', '#f59e0b', '#ef4444', '#06b6d4', '#84cc16', '#f97316'];

export function InteractiveCharts({
  revenueData,
  userGrowthData,
  courseEnrollmentData,
  categoryDistribution,
  onDrillDown
}: InteractiveChartsProps) {
  const [selectedChart, setSelectedChart] = useState<'revenue' | 'users' | 'courses' | 'categories'>('revenue');
  const [timeRange, setTimeRange] = useState<'7d' | '30d' | '90d' | '1y'>('30d');
  const [isFullscreen, setIsFullscreen] = useState(false);

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('ar-EG', {
      style: 'currency',
      currency: 'EGP',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(value);
  };

  const formatNumber = (value: number) => {
    return new Intl.NumberFormat('ar-EG').format(value);
  };

  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white dark:bg-neutral-800 p-3 border rounded-lg shadow-lg">
          <p className="font-semibold text-neutral-900 dark:text-black font-display mb-2">
            {label}
          </p>
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2 text-sm">
              <div 
                className="w-3 h-3 rounded-full" 
                style={{ backgroundColor: entry.color }}
              />
              <span className="font-primary text-neutral-600 dark:text-neutral-400">
                {entry.name}: 
              </span>
              <span className="font-semibold font-primary text-neutral-900 dark:text-black">
                {entry.name === 'الإيرادات' ? formatCurrency(entry.value) : formatNumber(entry.value)}
              </span>
            </div>
          ))}
        </div>
      );
    }
    return null;
  };

  const getTrendIcon = (growth: number) => {
    if (growth > 0) return <ArrowUp className="w-4 h-4 text-green-600" />;
    if (growth < 0) return <ArrowDown className="w-4 h-4 text-red-600" />;
    return <Minus className="w-4 h-4 text-neutral-600" />;
  };

  const getTrendColor = (growth: number) => {
    if (growth > 0) return "text-green-600 bg-green-100";
    if (growth < 0) return "text-red-600 bg-red-100";
    return "text-neutral-600 bg-neutral-100";
  };

  return (
    <div className="space-y-6">
      {/* Chart Controls */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Button
            variant={selectedChart === 'revenue' ? 'primary' : 'outline'}
            size="sm"
            onClick={() => setSelectedChart('revenue')}
          >
            <DollarSign className="w-4 h-4 ml-2" />
            الإيرادات
          </Button>
          <Button
            variant={selectedChart === 'users' ? 'primary' : 'outline'}
            size="sm"
            onClick={() => setSelectedChart('users')}
          >
            <Users className="w-4 h-4 ml-2" />
            المستخدمين
          </Button>
          <Button
            variant={selectedChart === 'courses' ? 'primary' : 'outline'}
            size="sm"
            onClick={() => setSelectedChart('courses')}
          >
            <BookOpen className="w-4 h-4 ml-2" />
            الدورات
          </Button>
          <Button
            variant={selectedChart === 'categories' ? 'primary' : 'outline'}
            size="sm"
            onClick={() => setSelectedChart('categories')}
          >
            <PieChartIcon className="w-4 h-4 ml-2" />
            التصنيفات
          </Button>
        </div>

        <div className="flex items-center gap-2">
          {/* Time Range Selector */}
          <div className="flex items-center border rounded-lg">
            {[
              { key: '7d', label: '7 أيام' },
              { key: '30d', label: '30 يوم' },
              { key: '90d', label: '90 يوم' },
              { key: '1y', label: 'سنة' }
            ].map((range) => (
              <Button
                key={range.key}
                variant={timeRange === range.key ? 'primary' : 'ghost'}
                size="sm"
                onClick={() => setTimeRange(range.key as any)}
                className="rounded-none first:rounded-r-md last:rounded-l-md"
              >
                {range.label}
              </Button>
            ))}
          </div>

          <Button variant="outline" size="sm">
            <Filter className="w-4 h-4 ml-2" />
            فلترة
          </Button>

          <Button variant="outline" size="sm">
            <Download className="w-4 h-4 ml-2" />
            تصدير
          </Button>

          <Button 
            variant="outline" 
            size="sm"
            onClick={() => setIsFullscreen(!isFullscreen)}
          >
            <Maximize2 className="w-4 h-4" />
          </Button>
        </div>
      </div>

      {/* Main Chart Area */}
      <AnimatePresence mode="wait">
        <motion.div
          key={selectedChart}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -20 }}
          transition={{ duration: 0.3 }}
        >
          <Card className={cn("overflow-hidden", isFullscreen && "fixed inset-4 z-50")}>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2 font-display">
                  {selectedChart === 'revenue' && (
                    <>
                      <TrendingUp className="w-5 h-5 text-green-600" />
                      تحليل الإيرادات
                    </>
                  )}
                  {selectedChart === 'users' && (
                    <>
                      <Users className="w-5 h-5 text-blue-600" />
                      نمو المستخدمين
                    </>
                  )}
                  {selectedChart === 'courses' && (
                    <>
                      <BookOpen className="w-5 h-5 text-purple-600" />
                      تسجيلات الدورات
                    </>
                  )}
                  {selectedChart === 'categories' && (
                    <>
                      <PieChartIcon className="w-5 h-5 text-orange-600" />
                      توزيع التصنيفات
                    </>
                  )}
                </CardTitle>

                {/* Chart Metrics */}
                <div className="flex items-center gap-4">
                  {selectedChart === 'revenue' && (
                    <div className="text-right">
                      <p className="text-2xl font-bold text-green-600 font-display">
                        {formatCurrency(revenueData.reduce((sum, item) => sum + item.value, 0))}
                      </p>
                      <div className="flex items-center gap-1">
                        {getTrendIcon(12.5)}
                        <span className="text-sm font-primary text-neutral-600">
                          +12.5% من الشهر الماضي
                        </span>
                      </div>
                    </div>
                  )}
                  {selectedChart === 'users' && (
                    <div className="text-right">
                      <p className="text-2xl font-bold text-blue-600 font-display">
                        {formatNumber(userGrowthData.reduce((sum, item) => sum + item.value, 0))}
                      </p>
                      <div className="flex items-center gap-1">
                        {getTrendIcon(8.3)}
                        <span className="text-sm font-primary text-neutral-600">
                          +8.3% نمو شهري
                        </span>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </CardHeader>
            <CardContent>
              <div className={cn("h-80", isFullscreen && "h-96")}>
                <ResponsiveContainer width="100%" height="100%">
                  <>
                    {selectedChart === 'revenue' ? (
                      <ComposedChart data={revenueData}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#f1f5f9" />
                        <XAxis 
                          dataKey="name" 
                          tick={{ fontSize: 12, fill: '#64748b' }}
                          tickLine={{ stroke: '#e2e8f0' }}
                        />
                        <YAxis 
                          tick={{ fontSize: 12, fill: '#64748b' }}
                          tickLine={{ stroke: '#e2e8f0' }}
                          tickFormatter={formatCurrency}
                        />
                        <Tooltip content={<CustomTooltip />} />
                        <Legend />
                        <Area
                          type="monotone"
                          dataKey="value"
                          fill="url(#revenueGradient)"
                          stroke="#10b981"
                          strokeWidth={2}
                          name="الإيرادات"
                        />
                        <Line
                          type="monotone"
                          dataKey="value"
                          stroke="#10b981"
                          strokeWidth={3}
                          dot={{ fill: '#10b981', strokeWidth: 2, r: 4 }}
                          activeDot={{ r: 6, stroke: '#10b981', strokeWidth: 2 }}
                        />
                        <defs>
                          <linearGradient id="revenueGradient" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#10b981" stopOpacity={0.3}/>
                            <stop offset="95%" stopColor="#10b981" stopOpacity={0.05}/>
                          </linearGradient>
                        </defs>
                      </ComposedChart>
                    ) : selectedChart === 'users' ? (
                      <AreaChart data={userGrowthData}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#f1f5f9" />
                        <XAxis 
                          dataKey="name" 
                          tick={{ fontSize: 12, fill: '#64748b' }}
                        />
                        <YAxis 
                          tick={{ fontSize: 12, fill: '#64748b' }}
                          tickFormatter={formatNumber}
                        />
                        <Tooltip content={<CustomTooltip />} />
                        <Area
                          type="monotone"
                          dataKey="value"
                          stroke="#3b82f6"
                          fill="url(#userGradient)"
                          strokeWidth={2}
                          name="المستخدمين الجدد"
                        />
                        <defs>
                          <linearGradient id="userGradient" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="5%" stopColor="#3b82f6" stopOpacity={0.3}/>
                            <stop offset="95%" stopColor="#3b82f6" stopOpacity={0.05}/>
                          </linearGradient>
                        </defs>
                      </AreaChart>
                    ) : selectedChart === 'courses' ? (
                      <BarChart data={courseEnrollmentData}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#f1f5f9" />
                        <XAxis 
                          dataKey="name" 
                          tick={{ fontSize: 12, fill: '#64748b' }}
                        />
                        <YAxis 
                          tick={{ fontSize: 12, fill: '#64748b' }}
                          tickFormatter={formatNumber}
                        />
                        <Tooltip content={<CustomTooltip />} />
                        <Bar 
                          dataKey="value" 
                          fill="#8b5cf6" 
                          radius={[4, 4, 0, 0]}
                          name="التسجيلات"
                        />
                      </BarChart>
                    ) : selectedChart === 'categories' ? (
                      <PieChart>
                        <Pie
                          data={categoryDistribution}
                          cx="50%"
                          cy="50%"
                          outerRadius={120}
                          fill="#8884d8"
                          dataKey="value"
                          label={({ name, percent }) => `${name} ${((percent || 0) * 100).toFixed(0)}%`}
                          onClick={(data) => onDrillDown?.(data.name, data)}
                        >
                          {categoryDistribution.map((entry, index) => (
                            <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                          ))}
                        </Pie>
                        <Tooltip content={<CustomTooltip />} />
                      </PieChart>
                    ) : null}
                  </>
                </ResponsiveContainer>
              </div>
            </CardContent>
          </Card>
        </motion.div>
      </AnimatePresence>

      {/* Chart Insights */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center">
                <TrendingUp className="w-5 h-5 text-green-600" />
              </div>
              <div>
                <p className="text-sm text-neutral-600 font-primary">أعلى نمو</p>
                <p className="font-semibold font-display">الدورات التقنية</p>
                <Badge className="text-xs mt-1 bg-green-100 text-green-800">
                  +24.5%
                </Badge>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
                <Users className="w-5 h-5 text-blue-600" />
              </div>
              <div>
                <p className="text-sm text-neutral-600 font-primary">أكثر نشاطاً</p>
                <p className="font-semibold font-display">المستخدمين الجدد</p>
                <Badge className="text-xs mt-1 bg-blue-100 text-blue-800">
                  +18.2%
                </Badge>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-4">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center">
                <DollarSign className="w-5 h-5 text-purple-600" />
              </div>
              <div>
                <p className="text-sm text-neutral-600 font-primary">أعلى إيراد</p>
                <p className="font-semibold font-display">دورات البرمجة</p>
                <Badge className="text-xs mt-1 bg-purple-100 text-purple-800">
                  {formatCurrency(45000)}
                </Badge>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

#14: ./src/components/admin/CategoryManagement.tsx
--------------------------------------------------------------------------------
// src/components/admin/CategoryManagement.tsx
"use client";

import { useState } from "react";
import { CategoryDialog } from "./CategoryDialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import {
  Search,
  MoreHorizontal,
  Edit,
  Trash2,
  Eye,
  EyeOff,
  BookOpen,
  Users,
  Calendar,
  Link as LinkIcon,
} from "lucide-react";
import { deleteCategory } from "@/lib/actions/category.actions";
import { Category } from "@/lib/api/categories";
import { toast } from "sonner";

interface CategoryWithStats extends Category {
  _count: {
    courses: number;
  };
  totalEnrollments: number;
}

interface CategoryManagementProps {
  categories: CategoryWithStats[];
}

export function CategoryManagement({
  categories: initialCategories,
}: CategoryManagementProps) {
  const [categories, setCategories] = useState(initialCategories);
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState<
    "all" | "active" | "inactive"
  >("all");
  const [sortBy, setSortBy] = useState<
    "name" | "courses" | "enrollments" | "created"
  >("created");

  // Filter and sort categories
  const filteredCategories = categories
    .filter((category) => {
      const matchesSearch =
        category.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        category.description.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesStatus =
        statusFilter === "all" ||
        (statusFilter === "active" && category.isActive) ||
        (statusFilter === "inactive" && !category.isActive);
      return matchesSearch && matchesStatus;
    })
    .sort((a, b) => {
      switch (sortBy) {
        case "name":
          return a.name.localeCompare(b.name, "ar");
        case "courses":
          return b._count.courses - a._count.courses;
        case "enrollments":
          return b.totalEnrollments - a.totalEnrollments;
        case "created":
        default:
          return (
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
          );
      }
    });

  const handleDelete = async (categoryId: string) => {
    try {
      const result = await deleteCategory(categoryId);
      if (result.success) {
        setCategories((prev) => prev.filter((cat) => cat.id !== categoryId));
        toast.success(result.success);
      } else {
        toast.error(result.error || "فشل في حذف الفئة");
      }
    } catch (error) {
      toast.error("حدث خطأ أثناء حذف الفئة");
    }
  };

  const refreshCategories = () => {
    // In a real app, you'd refetch from the server
    // For now, we'll just trigger a page refresh
    window.location.reload();
  };

  return (
    <div className="space-y-4">
      {/* Filters and Search */}
      <div className="flex flex-col sm:flex-row gap-4">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-muted-foreground" />
          <Input
            placeholder="البحث في الفئات..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-10"
          />
        </div>

        <Select
          value={statusFilter}
          onValueChange={(value: any) => setStatusFilter(value)}
        >
          <SelectTrigger className="w-[150px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">جميع الفئات</SelectItem>
            <SelectItem value="active">النشطة فقط</SelectItem>
            <SelectItem value="inactive">غير النشطة</SelectItem>
          </SelectContent>
        </Select>

        <Select value={sortBy} onValueChange={(value: any) => setSortBy(value)}>
          <SelectTrigger className="w-[150px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="created">الأحدث</SelectItem>
            <SelectItem value="name">الاسم</SelectItem>
            <SelectItem value="courses">عدد الدورات</SelectItem>
            <SelectItem value="enrollments">التسجيلات</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Categories Grid */}
      {filteredCategories.length === 0 ? (
        <div className="text-center py-8">
          <Search className="mx-auto h-12 w-12 text-muted-foreground" />
          <h3 className="mt-2 text-sm font-semibold">لا توجد نتائج</h3>
          <p className="mt-1 text-sm text-muted-foreground">
            جرب تغيير معايير البحث أو الفلترة
          </p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredCategories.map((category) => (
            <div key={category.id} className="border rounded-lg p-4 space-y-3">
              {/* Header */}
              <div className="flex items-start justify-between">
                <div className="flex-1">
                  <h3 className="font-semibold text-lg">{category.name}</h3>
                  <p className="text-sm text-muted-foreground line-clamp-2">
                    {category.description}
                  </p>
                </div>

                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm">
                      <MoreHorizontal className="w-4 h-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <CategoryDialog
                      category={category}
                      onSuccess={refreshCategories}
                      trigger={
                        <DropdownMenuItem onSelect={(e: Event) => e.preventDefault()}>
                          <Edit className="w-4 h-4 mr-2" />
                          تعديل
                        </DropdownMenuItem>
                      }
                    />
                    <DropdownMenuSeparator />
                    <AlertDialog>
                      <AlertDialogTrigger asChild>
                        <DropdownMenuItem
                          onSelect={(e: Event) => e.preventDefault()}
                          className="text-destructive focus:text-destructive"
                          disabled={category._count.courses > 0}
                        >
                          <Trash2 className="w-4 h-4 mr-2" />
                          حذف
                        </DropdownMenuItem>
                      </AlertDialogTrigger>
                      <AlertDialogContent>
                        <AlertDialogHeader>
                          <AlertDialogTitle>تأكيد الحذف</AlertDialogTitle>
                          <AlertDialogDescription>
                            هل أنت متأكد من حذف فئة &ldquo;{category.name}&rdquo;؟ هذا
                            الإجراء لا يمكن التراجع عنه.
                          </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                          <AlertDialogCancel>إلغاء</AlertDialogCancel>
                          <AlertDialogAction
                            onClick={() => handleDelete(category.id)}
                            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                          >
                            حذف
                          </AlertDialogAction>
                        </AlertDialogFooter>
                      </AlertDialogContent>
                    </AlertDialog>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>

              {/* Status and Slug */}
              <div className="flex items-center gap-2">
                <Badge variant={category.isActive ? "default" : "secondary"}>
                  {category.isActive ? (
                    <>
                      <Eye className="w-3 h-3 mr-1" />
                      نشط
                    </>
                  ) : (
                    <>
                      <EyeOff className="w-3 h-3 mr-1" />
                      غير نشط
                    </>
                  )}
                </Badge>
                <div className="flex items-center text-xs text-muted-foreground">
                  <LinkIcon className="w-3 h-3 mr-1" />
                  {category.slug}
                </div>
              </div>

              {/* Statistics */}
              <div className="grid grid-cols-2 gap-4 pt-2 border-t">
                <div className="text-center">
                  <div className="flex items-center justify-center gap-1 text-sm text-muted-foreground">
                    <BookOpen className="w-4 h-4" />
                    <span>الدورات</span>
                  </div>
                  <div className="text-lg font-semibold">
                    {category._count.courses}
                  </div>
                </div>
                <div className="text-center">
                  <div className="flex items-center justify-center gap-1 text-sm text-muted-foreground">
                    <Users className="w-4 h-4" />
                    <span>الملتحقين</span>
                  </div>
                  <div className="text-lg font-semibold">
                    {category.totalEnrollments}
                  </div>
                </div>
              </div>

              {/* Created Date */}
              <div className="flex items-center text-xs text-muted-foreground pt-2 border-t">
                <Calendar className="w-3 h-3 mr-1" />
                تم الإنشاء:{" "}
                {new Date(category.createdAt).toLocaleDateString("ar-EG")}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}


#15: ./src/components/admin/ModernFilters.tsx
--------------------------------------------------------------------------------
// src/components/admin/ModernFilters.tsx
"use client";

import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Filter,
  X,
  Search,
  Calendar as CalendarIcon,
  ChevronDown,
  RotateCcw,
  Download,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { formatAdminDate } from "@/lib/date-utils";

export interface FilterOption {
  key: string;
  label: string;
  type: "text" | "select" | "date" | "dateRange" | "multiSelect";
  options?: { value: string; label: string }[];
  placeholder?: string;
}

export interface FilterValue {
  [key: string]: any;
}

interface ModernFiltersProps {
  filters: FilterOption[];
  values: FilterValue;
  onChange: (values: FilterValue) => void;
  onReset?: () => void;
  onExport?: () => void;
  className?: string;
  showExport?: boolean;
  isLoading?: boolean;
}

export function ModernFilters({
  filters,
  values,
  onChange,
  onReset,
  onExport,
  className,
  showExport = false,
  isLoading = false,
}: ModernFiltersProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [searchQuery, setSearchQuery] = useState(values.search || "");

  const activeFiltersCount = Object.values(values).filter(
    (value) =>
      value !== undefined &&
      value !== null &&
      value !== "" &&
      (Array.isArray(value) ? value.length > 0 : true)
  ).length;

  const handleFilterChange = (key: string, value: any) => {
    onChange({ ...values, [key]: value });
  };

  const handleSearchChange = (value: string) => {
    setSearchQuery(value);
    handleFilterChange("search", value);
  };

  const clearFilter = (key: string) => {
    const newValues = { ...values };
    delete newValues[key];
    onChange(newValues);
    if (key === "search") {
      setSearchQuery("");
    }
  };

  const handleReset = () => {
    setSearchQuery("");
    onChange({});
    onReset?.();
  };

  const renderFilterInput = (filter: FilterOption) => {
    const value = values[filter.key];

    switch (filter.type) {
      case "text":
        return (
          <Input
            placeholder={filter.placeholder}
            value={value || ""}
            onChange={(e) => handleFilterChange(filter.key, e.target.value)}
            className="h-9"
          />
        );

      case "select":
        return (
          <Select
            value={value || ""}
            onValueChange={(val) => handleFilterChange(filter.key, val)}
          >
            <SelectTrigger className="h-9">
              <SelectValue placeholder={filter.placeholder} />
            </SelectTrigger>
            <SelectContent>
              {filter.options?.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      case "date":
        return (
          <Popover>
            <PopoverTrigger asChild>
              <Button
                variant="outline"
                className={cn(
                  "h-9 justify-start text-left font-normal",
                  !value && "text-muted-foreground"
                )}
              >
                <CalendarIcon className="mr-2 h-4 w-4" />
                {value ? formatAdminDate(new Date(value)) : filter.placeholder}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0" align="start">
              <Calendar
                mode="single"
                selected={value ? new Date(value) : undefined}
                onSelect={(date: Date | undefined) =>
                  handleFilterChange(filter.key, date?.toISOString())
                }
                initialFocus
              />
            </PopoverContent>
          </Popover>
        );

      case "multiSelect":
        const selectedValues = Array.isArray(value) ? value : [];
        return (
          <div className="space-y-2">
            <Select
              onValueChange={(val) => {
                const newValues = selectedValues.includes(val)
                  ? selectedValues.filter((v) => v !== val)
                  : [...selectedValues, val];
                handleFilterChange(filter.key, newValues);
              }}
            >
              <SelectTrigger className="h-9">
                <SelectValue placeholder={filter.placeholder} />
              </SelectTrigger>
              <SelectContent>
                {filter.options?.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    <div className="flex items-center gap-2">
                      <div
                        className={cn(
                          "w-4 h-4 border rounded",
                          selectedValues.includes(option.value) &&
                            "bg-primary border-primary"
                        )}
                      />
                      {option.label}
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            {selectedValues.length > 0 && (
              <div className="flex flex-wrap gap-1">
                {selectedValues.map((val) => {
                  const option = filter.options?.find(
                    (opt) => opt.value === val
                  );
                  return (
                    <Badge key={val} variant="secondary" className="text-xs">
                      {option?.label}
                      <Button
                        variant="ghost"
                        size="sm"
                        className="h-auto p-0 ml-1"
                        onClick={() => {
                          const newValues = selectedValues.filter(
                            (v) => v !== val
                          );
                          handleFilterChange(filter.key, newValues);
                        }}
                      >
                        <X className="w-3 h-3" />
                      </Button>
                    </Badge>
                  );
                })}
              </div>
            )}
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <Card
      className={cn(
        "border-0 shadow-sm bg-card/50 backdrop-blur-sm",
        className
      )}
    >
      <CardContent className="p-4">
        {/* Search Bar and Toggle */}
        <div className="flex items-center gap-3 mb-4">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-muted-foreground" />
            <Input
              placeholder="البحث..."
              value={searchQuery}
              onChange={(e) => handleSearchChange(e.target.value)}
              className="pl-10 h-10 bg-background/50"
            />
            {searchQuery && (
              <Button
                variant="ghost"
                size="sm"
                className="absolute right-2 top-1/2 transform -translate-y-1/2 h-6 w-6 p-0"
                onClick={() => handleSearchChange("")}
              >
                <X className="w-4 h-4" />
              </Button>
            )}
          </div>

          <Button
            variant="outline"
            onClick={() => setIsExpanded(!isExpanded)}
            className="h-10 px-4"
          >
            <Filter className="w-4 h-4 mr-2" />
            فلترة
            {activeFiltersCount > 0 && (
              <Badge
                variant="secondary"
                className="ml-2 h-5 w-5 p-0 flex items-center justify-center text-xs"
              >
                {activeFiltersCount}
              </Badge>
            )}
            <ChevronDown
              className={cn(
                "w-4 h-4 ml-2 transition-transform duration-200",
                isExpanded && "rotate-180"
              )}
            />
          </Button>

          {activeFiltersCount > 0 && (
            <Button
              variant="ghost"
              size="sm"
              onClick={handleReset}
              className="h-10 px-3"
            >
              <RotateCcw className="w-4 h-4 mr-2" />
              إعادة تعيين
            </Button>
          )}

          {showExport && (
            <Button
              variant="outline"
              onClick={onExport}
              disabled={isLoading}
              className="h-10 px-4"
            >
              <Download className="w-4 h-4 mr-2" />
              تصدير
            </Button>
          )}
        </div>

        {/* Active Filters */}
        {activeFiltersCount > 0 && (
          <div className="flex flex-wrap gap-2 mb-4">
            {Object.entries(values)
              .filter(([key, value]) => {
                if (!value || (Array.isArray(value) && value.length === 0))
                  return false;
                const filter = filters.find((f) => f.key === key);
                return filter && key !== "search";
              })
              .map(([key, value]) => {
                const filter = filters.find((f) => f.key === key);
                if (!filter) return null;

                let displayValue = value;
                if (filter.type === "select" || filter.type === "multiSelect") {
                  if (Array.isArray(value)) {
                    displayValue = value
                      .map(
                        (v) =>
                          filter.options?.find((opt) => opt.value === v)
                            ?.label || v
                      )
                      .join(", ");
                  } else {
                    displayValue =
                      filter.options?.find((opt) => opt.value === value)
                        ?.label || value;
                  }
                } else if (filter.type === "date") {
                  displayValue = formatAdminDate(new Date(value));
                }

                return (
                  <Badge key={key} variant="secondary" className="gap-1">
                    <span className="text-xs font-medium">{filter.label}:</span>
                    <span className="text-xs">{displayValue}</span>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 ml-1"
                      onClick={() => clearFilter(key)}
                    >
                      <X className="w-3 h-3" />
                    </Button>
                  </Badge>
                );
              })}
          </div>
        )}

        {/* Expanded Filters */}
        <AnimatePresence>
          {isExpanded && (
            <motion.div
              initial={{ height: 0, opacity: 0 }}
              animate={{ height: "auto", opacity: 1 }}
              exit={{ height: 0, opacity: 0 }}
              transition={{ duration: 0.3, ease: "easeInOut" }}
              className="overflow-hidden"
            >
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 pt-4 border-t">
                {filters.map((filter) => (
                  <div key={filter.key} className="space-y-2">
                    <Label className="text-sm font-medium">
                      {filter.label}
                    </Label>
                    {renderFilterInput(filter)}
                  </div>
                ))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </CardContent>
    </Card>
  );
}


#16: ./src/components/admin/student-detail/CertificateList.tsx
--------------------------------------------------------------------------------
// src/components/admin/student-detail/CertificateList.tsx

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Award, Eye } from 'lucide-react';

interface CertificateListProps {
  certificates: any[];
}

export function CertificateList({ certificates }: CertificateListProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>الشهادات ({certificates.length})</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {certificates.length > 0 ? (
            certificates.map((certificate) => (
              <div
                key={certificate.id}
                className="flex items-center justify-between p-4 border rounded-lg"
              >
                <div>
                  <h3 className="font-semibold">{certificate.course.title}</h3>
                  <p className="text-sm text-muted-foreground">
                    رمز الشهادة: {certificate.certificateCode}
                  </p>
                  <p className="text-sm text-muted-foreground">
                    تاريخ الإصدار:{' '}
                    {new Date(certificate.issuedAt).toLocaleDateString('ar-SA')}
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  <Badge
                    variant={
                      certificate.status === 'ACTIVE' ? 'default' : 'secondary'
                    }
                  >
                    {certificate.status === 'ACTIVE' ? 'نشطة' : 'غير نشطة'}
                  </Badge>
                  <Button variant="outline" size="sm">
                    <Eye className="h-3 w-3 ml-1" />
                    عرض
                  </Button>
                </div>
              </div>
            ))
          ) : (
            <div className="text-center py-8">
              <Award className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
              <p className="text-muted-foreground">لا توجد شهادات</p>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

#17: ./src/components/admin/student-detail/EnrollmentList.tsx
--------------------------------------------------------------------------------
// src/components/admin/student-detail/EnrollmentList.tsx

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { BookOpen } from "lucide-react";
import { formatCurrency } from "@/lib/formatters";

interface EnrollmentListProps {
  enrollments: any[];
}

export function EnrollmentList({ enrollments }: EnrollmentListProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>الدورات المسجل بها ({enrollments.length})</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {enrollments.length > 0 ? (
            enrollments.map((enrollment) => (
              <div
                key={enrollment.id}
                className="flex items-center gap-4 p-4 border rounded-lg"
              >
                <img
                  src={enrollment.course.thumbnailUrl}
                  alt={enrollment.course.title}
                  className="w-24 h-16 object-cover rounded-md"
                />
                <div className="flex-1">
                  <h3 className="font-semibold">{enrollment.course.title}</h3>
                  <p className="text-sm text-muted-foreground">
                    الأستاذ: {enrollment.course.professor.name}
                  </p>
                  <div className="flex items-center gap-4 text-sm text-muted-foreground mt-1">
                    <span>التقدم: {enrollment.progressPercent}%</span>
                    <span>
                      وقت المشاهدة: {Math.round(enrollment.totalWatchTime / 60)}{" "}
                      دقيقة
                    </span>
                    <span>
                      تاريخ التسجيل:{" "}
                      {new Date(enrollment.enrolledAt).toLocaleDateString(
                        "ar-SA"
                      )}
                    </span>
                  </div>
                </div>
                <div className="text-right">
                  {enrollment.course.price != null ? (
                    <p className="font-semibold">
                      {formatCurrency(enrollment.course.price)}
                    </p>
                  ) : (
                    <Badge variant="outline">مجاني</Badge>
                  )}
                </div>
              </div>
            ))
          ) : (
            <div className="text-center py-8">
              <BookOpen className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
              <p className="text-muted-foreground">لم يسجل في أي دورات بعد</p>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}


#18: ./src/components/admin/student-detail/PaymentList.tsx
--------------------------------------------------------------------------------
// src/components/admin/student-detail/PaymentList.tsx

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { CreditCard, Eye } from 'lucide-react';
import { PaymentStatusBadge } from '@/components/shared/PaymentStatusBadge';
import { formatCurrency } from '@/lib/formatters';

interface PaymentListProps {
  payments: any[];
  onViewDetails: (paymentId: string) => void;
}

export function PaymentList({ payments, onViewDetails }: PaymentListProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>سجل المدفوعات ({payments.length})</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {payments.length > 0 ? (
            payments.map((payment) => (
              <div
                key={payment.id}
                className="flex items-center gap-4 p-4 border rounded-lg"
              >
                <img
                  src={payment.course.thumbnailUrl}
                  alt={payment.course.title}
                  className="w-24 h-16 object-cover rounded-md"
                />
                <div className="flex-1">
                  <div className="flex items-center gap-2 mb-1">
                    <h3 className="font-semibold">{payment.course.title}</h3>
                    <PaymentStatusBadge status={payment.status} />
                  </div>
                  <div className="flex flex-wrap items-center gap-x-4 gap-y-1 text-sm text-muted-foreground">
                    <span>
                      تاريخ الإنشاء:{' '}
                      {new Date(payment.createdAt).toLocaleDateString('ar-SA')}
                    </span>
                    {payment.completedAt && (
                      <span>
                        تاريخ الإكمال:{' '}
                        {new Date(payment.completedAt).toLocaleDateString('ar-SA')}
                      </span>
                    )}
                    {payment.paymobTransactionId && (
                      <span>رقم المعاملة: {payment.paymobTransactionId}</span>
                    )}
                  </div>
                  {payment.failureReason && (
                    <p className="text-xs text-red-600 mt-1">
                      سبب الفشل: {payment.failureReason}
                    </p>
                  )}
                </div>
                <div className="text-right space-y-2">
                  <div className="text-lg font-bold">
                    {formatCurrency(payment.amount)}
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => onViewDetails(payment.id)}
                  >
                    <Eye className="h-3 w-3 ml-1" />
                    التفاصيل
                  </Button>
                </div>
              </div>
            ))
          ) : (
            <div className="text-center py-8">
              <CreditCard className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
              <p className="text-muted-foreground">لا توجد مدفوعات</p>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

#19: ./src/components/admin/student-detail/StudentDataTabs.tsx
--------------------------------------------------------------------------------
// src/components/admin/student-detail/StudentDataTabs.tsx

import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { EnrollmentList } from './EnrollmentList';
import { PaymentList } from './PaymentList';
import { CertificateList } from './CertificateList';
import { Enrollment, Payment, Certificate } from '@prisma/client';

// Define flexible types that match the actual data structure
type StudentData = {
  enrollments: any[];
  payments: any[];
  certificates: any[];
};

interface StudentDataTabsProps {
  studentData: StudentData;
  onViewPaymentDetails: (paymentId: string) => void;
}

export function StudentDataTabs({
  studentData,
  onViewPaymentDetails,
}: StudentDataTabsProps) {
  return (
    <Tabs defaultValue="enrollments" className="w-full">
      <TabsList>
        <TabsTrigger value="enrollments">الدورات المسجل بها</TabsTrigger>
        <TabsTrigger value="payments">سجل المدفوعات</TabsTrigger>
        <TabsTrigger value="certificates">الشهادات</TabsTrigger>
      </TabsList>
      <TabsContent value="enrollments" className="pt-4">
        <EnrollmentList enrollments={studentData.enrollments} />
      </TabsContent>
      <TabsContent value="payments" className="pt-4">
        <PaymentList
          payments={studentData.payments}
          onViewDetails={onViewPaymentDetails}
        />
      </TabsContent>
      <TabsContent value="certificates" className="pt-4">
        <CertificateList certificates={studentData.certificates} />
      </TabsContent>
    </Tabs>
  );
}

#20: ./src/components/course/CourseAccessGuard.tsx
--------------------------------------------------------------------------------
// src/components/course/CourseAccessGuard.tsx
"use client";

import { useState, useEffect, ReactNode } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { PaymentButton } from "@/components/payment/PaymentButton";
import { CourseAccessResult } from "@/lib/services/course-access.service";
import { getAccessMessage } from "@/lib/access-messages";
import { checkCourseAccess, enrollInFreeCourse } from "@/lib/api/course-access";
import { 
  Lock, 
  CheckCircle, 
  CreditCard, 
  UserPlus, 
  AlertCircle,
  Shield,
  Crown,
  GraduationCap,
  ExternalLink
} from "lucide-react";
import { toast } from "sonner";
import { useRouter } from "next/navigation";
import Link from "next/link";

interface Course {
  id: string;
  title: string;
  description: string;
  price: number | null;
  currency: string;
  thumbnailUrl: string;
  isPublished: boolean;
  bunnyLibraryId: string;
  categoryId: string;
  professorId: string;
  createdAt: string;
  updatedAt: string;
  category: {
    id: string;
    name: string;
    slug: string;
    description?: string;
  };
  professor: {
    id: string;
    name: string;
    bio: string | null;
    expertise?: string[];
  };
  _count: {
    lessons: number;
    enrollments: number;
  };
}

interface CourseAccessGuardProps {
  courseId: string;
  course?: Course; // Optional course data to avoid extra API calls
  children: ReactNode;
  fallback?: ReactNode;
  showAccessInfo?: boolean;
}

export function CourseAccessGuard({ 
  courseId, 
  course, 
  children, 
  fallback,
  showAccessInfo = true 
}: CourseAccessGuardProps) {
  const [accessResult, setAccessResult] = useState<CourseAccessResult | null>(null);
  const [loading, setLoading] = useState(true);
  const [enrolling, setEnrolling] = useState(false);
  // const router = useRouter(); // Unused for now

  // Check course access on mount
  useEffect(() => {
    async function checkAccess() {
      try {
        setLoading(true);
        const result = await checkCourseAccess(courseId);
        setAccessResult(result);
      } catch (error) {
        console.error('Access check error:', error);
        setAccessResult({
          hasAccess: false,
          reason: 'not_found'
        });
      } finally {
        setLoading(false);
      }
    }

    checkAccess();
  }, [courseId]);

  // Handle free course enrollment
  const handleFreeEnrollment = async () => {
    try {
      setEnrolling(true);
      const result = await enrollInFreeCourse(courseId);
      
      if (result.success) {
        toast.success(result.message);
        // Refresh access check
        const newAccessResult = await checkCourseAccess(courseId);
        setAccessResult(newAccessResult);
      } else {
        toast.error(result.message);
      }
    } catch (error) {
      console.error('Enrollment error:', error);
      toast.error('حدث خطأ أثناء التسجيل');
    } finally {
      setEnrolling(false);
    }
  };

  // Handle payment success
  const handlePaymentSuccess = async () => {
    // Refresh access check after successful payment
    const newAccessResult = await checkCourseAccess(courseId);
    setAccessResult(newAccessResult);
  };

  // Get access icon
  const getAccessIcon = (reason: CourseAccessResult['reason']) => {
    switch (reason) {
      case 'enrolled':
        return <CheckCircle className="w-8 h-8 text-green-600" />;
      case 'free_course':
        return <GraduationCap className="w-8 h-8 text-blue-600" />;
      case 'admin_access':
        return <Crown className="w-8 h-8 text-purple-600" />;
      case 'professor_owns':
        return <Shield className="w-8 h-8 text-indigo-600" />;
      case 'payment_required':
        return <CreditCard className="w-8 h-8 text-orange-600" />;
      case 'not_authenticated':
        return <Lock className="w-8 h-8 text-gray-600" />;
      default:
        return <AlertCircle className="w-8 h-8 text-red-600" />;
    }
  };

  // Loading state
  if (loading) {
    return (
      <div className="space-y-4">
        <Card>
          <CardHeader>
            <div className="flex items-center gap-3">
              <Skeleton className="w-8 h-8 rounded-full" />
              <div className="space-y-2">
                <Skeleton className="h-5 w-32" />
                <Skeleton className="h-4 w-48" />
              </div>
            </div>
          </CardHeader>
          <CardContent>
            <Skeleton className="h-10 w-full" />
          </CardContent>
        </Card>
        {fallback || (
          <div className="space-y-4">
            <Skeleton className="h-64 w-full" />
            <Skeleton className="h-32 w-full" />
          </div>
        )}
      </div>
    );
  }

  // No access result
  if (!accessResult) {
    return (
      <Card>
        <CardContent className="text-center py-8">
          <AlertCircle className="w-12 h-12 mx-auto mb-4 text-red-600" />
          <h3 className="text-lg font-semibold mb-2">خطأ في التحقق من الوصول</h3>
          <p className="text-muted-foreground">حدث خطأ أثناء التحقق من صلاحية الوصول للدورة</p>
        </CardContent>
      </Card>
    );
  }

  // User has access - show content
  if (accessResult.hasAccess) {
    return (
      <div className="space-y-4">
        {/* Access Info (optional) */}
        {showAccessInfo && (
          <Card className="border-green-200 bg-green-50">
            <CardContent className="flex items-center gap-3 py-4">
              {getAccessIcon(accessResult.reason)}
              <div>
                <h4 className="font-semibold text-green-800">
                  {getAccessMessage(accessResult).title}
                </h4>
                <p className="text-sm text-green-700">
                  {getAccessMessage(accessResult).description}
                </p>
              </div>
            </CardContent>
          </Card>
        )}
        
        {/* Course Content */}
        {children}
      </div>
    );
  }

  // User doesn't have access - show access gate
  const accessMessage = getAccessMessage(accessResult);
  
  return (
    <div className="space-y-4">
      <Card>
        <CardHeader className="text-center">
          <div className="flex justify-center mb-4">
            {getAccessIcon(accessResult.reason)}
          </div>
          <CardTitle className="text-xl">{accessMessage.title}</CardTitle>
          <CardDescription className="text-base">
            {accessMessage.description}
          </CardDescription>
        </CardHeader>
        
        <CardContent className="space-y-4">
          {/* Course Information */}
          {accessResult.course && (
            <div className="p-4 bg-muted/50 rounded-lg">
              <h4 className="font-semibold mb-2">معلومات الدورة</h4>
              <p className="text-sm text-muted-foreground">
                {accessResult.course.title}
              </p>
              {accessResult.course.price && (
                <p className="text-sm font-medium mt-1">
                  السعر: {new Intl.NumberFormat('ar-EG', {
                    style: 'currency',
                    currency: accessResult.course.currency || 'EGP',
                    minimumFractionDigits: 0
                  }).format(Number(accessResult.course.price))}
                </p>
              )}
            </div>
          )}

          {/* Action Buttons */}
          <div className="flex gap-3">
            {accessMessage.actionType === 'login' && (
              <Button asChild className="flex-1">
                <Link href="/login">
                  <Lock className="w-4 h-4" />
                  {accessMessage.actionText}
                </Link>
              </Button>
            )}

            {accessMessage.actionType === 'payment' && course && (
              <PaymentButton
                course={course}
                className="flex-1"
                size="lg"
                onPaymentSuccess={handlePaymentSuccess}
              />
            )}

            {accessMessage.actionType === 'enrollment' && (
              <Button 
                onClick={handleFreeEnrollment}
                disabled={enrolling}
                className="flex-1"
                size="lg"
              >
                {enrolling ? (
                  <>
                    <div className="w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin" />
                    جاري التسجيل...
                  </>
                ) : (
                  <>
                    <UserPlus className="w-4 h-4" />
                    {accessMessage.actionText}
                  </>
                )}
              </Button>
            )}

            {accessMessage.actionType === 'contact' && (
              <Button variant="outline" className="flex-1" size="lg">
                <ExternalLink className="w-4 h-4" />
                {accessMessage.actionText}
              </Button>
            )}
          </div>

          {/* Additional Actions */}
          <div className="flex justify-center">
            <Button variant="ghost" asChild>
              <Link href="/courses">
                العودة إلى الدورات
              </Link>
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Fallback Content */}
      {fallback && (
        <div className="opacity-50 pointer-events-none">
          {fallback}
        </div>
      )}
    </div>
  );
}

// Higher-order component for protecting entire pages
export function withCourseAccess<P extends object>(
  Component: React.ComponentType<P>,
  options: {
    courseIdProp?: keyof P;
    fallback?: ReactNode;
    showAccessInfo?: boolean;
  } = {}
) {
  const { courseIdProp = 'courseId', fallback, showAccessInfo = true } = options;

  return function ProtectedComponent(props: P) {
    const courseId = (props as any)[courseIdProp] as string;

    if (!courseId) {
      return (
        <Card>
          <CardContent className="text-center py-8">
            <AlertCircle className="w-12 h-12 mx-auto mb-4 text-red-600" />
            <h3 className="text-lg font-semibold mb-2">معرف الدورة مفقود</h3>
            <p className="text-muted-foreground">لم يتم تحديد معرف الدورة</p>
          </CardContent>
        </Card>
      );
    }

    return (
      <CourseAccessGuard
        courseId={courseId}
        fallback={fallback}
        showAccessInfo={showAccessInfo}
      >
        <Component {...props} />
      </CourseAccessGuard>
    );
  };
}

#21: ./src/components/course/CourseCatalog.tsx
--------------------------------------------------------------------------------
// src/components/course/CourseCatalog.tsx - AI-Powered Course Catalog
'use client';

import { UserRole } from '@prisma/client';
import { useState, useEffect, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useCourseCatalog } from '@/hooks/useCourseCatalog';
import { useOptimizedMotion } from '@/hooks/useAnimations';
import { StaggerChildren, StaggerItem, FadeInScroll } from '@/components/ui/micro-interactions';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent } from '@/components/ui/card';
import CourseCard from './CourseCard';
import { 
  Search, 
  Filter, 
  Grid3X3, 
  List, 
  SlidersHorizontal,
  Sparkles,
  TrendingUp,
  Clock,
  Users,
  Star,
  Zap,
  Brain,
  Target,
  X,
  ChevronDown,
  Loader2
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface CourseCatalogProps {
  initialFilters: {
    page: number;
    category?: string;
    search?: string;
    priceRange?: string;
    level?: string;
    sort: string;
    limit: number;
  };
  userRole?: UserRole;
  userId?: string;
}

interface AIRecommendation {
  id: string;
  type: 'trending' | 'personalized' | 'similar' | 'popular';
  title: string;
  description: string;
  courses: any[];
  icon: React.ElementType;
}

export default function CourseCatalog({ initialFilters, userRole, userId }: CourseCatalogProps) {
  const {
    courses,
    isLoading,
    error,
    totalCount,
    totalPages,
    currentPage,
    viewMode,
    setViewMode,
    searchTerm,
    categoryFilter,
    priceRangeFilter,
    levelFilter,
    sortFilter,
    categories,
    handleSearch,
    handleFilterChange,
    handlePageChange,
    clearFilters,
    fetchCourses
  } = useCourseCatalog(initialFilters);

  const { shouldReduceMotion } = useOptimizedMotion();
  const [showFilters, setShowFilters] = useState(false);
  const [searchSuggestions, setSearchSuggestions] = useState<string[]>([]);
  const [showSuggestions, setShowSuggestions] = useState(false);

  // Course recommendations based on user behavior and course popularity
  const aiRecommendations: AIRecommendation[] = useMemo(() => [
    {
      id: '1',
      type: 'personalized',
      title: 'موصى لك',
      description: 'بناءً على اهتماماتك وتقدمك السابق',
      courses: courses.slice(0, 3),
      icon: Sparkles
    },
    {
      id: '2',
      type: 'trending',
      title: 'الأكثر رواجاً',
      description: 'الدورات الأكثر شعبية هذا الأسبوع',
      courses: courses.slice(3, 6),
      icon: TrendingUp
    },
    {
      id: '3',
      type: 'similar',
      title: 'مشابهة لما تعلمته',
      description: 'دورات تكمل مسيرتك التعليمية',
      courses: courses.slice(6, 9),
      icon: Target
    }
  ], [courses]);

  // Smart search suggestions
  const searchSuggestionsData = [
    'تطوير المواقع',
    'React',
    'JavaScript',
    'Python',
    'التسويق الرقمي',
    'تصميم الجرافيك',
    'الذكاء الاصطناعي',
    'علوم البيانات'
  ];

  // Handle search with suggestions
  const handleSearchWithSuggestions = (query: string) => {
    handleSearch(query);
    if (query.length > 0) {
      const filtered = searchSuggestionsData.filter(suggestion =>
        suggestion.toLowerCase().includes(query.toLowerCase())
      );
      setSearchSuggestions(filtered.slice(0, 5));
      setShowSuggestions(true);
    } else {
      setShowSuggestions(false);
    }
  };

  // Filter options
  const filterOptions = {
    categories: categories || [],
    priceRanges: [
      { value: 'free', label: 'مجاني' },
      { value: '0-100', label: '0 - 100 جنيه' },
      { value: '100-500', label: '100 - 500 جنيه' },
      { value: '500+', label: '500+ جنيه' }
    ],
    levels: [
      { value: 'beginner', label: 'مبتدئ' },
      { value: 'intermediate', label: 'متوسط' },
      { value: 'advanced', label: 'متقدم' }
    ],
    sortOptions: [
      { value: 'newest', label: 'الأحدث' },
      { value: 'popular', label: 'الأكثر شعبية' },
      { value: 'rating', label: 'الأعلى تقييماً' },
      { value: 'price-low', label: 'السعر: من الأقل للأعلى' },
      { value: 'price-high', label: 'السعر: من الأعلى للأقل' }
    ]
  };

  // Active filters count
  const activeFiltersCount = [
    categoryFilter,
    priceRangeFilter,
    levelFilter,
    searchTerm
  ].filter(Boolean).length;

  // Loading state
  if (isLoading && courses.length === 0) {
    return (
      <div className="flex items-center justify-center min-h-96">
        <div className="text-center space-y-4">
          <Loader2 className="w-8 h-8 animate-spin text-primary-600 mx-auto" />
          <p className="text-neutral-600 font-primary">جاري تحميل الدورات...</p>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="flex items-center justify-center min-h-96">
        <div className="text-center space-y-4">
          <div className="w-16 h-16 bg-error/10 rounded-full flex items-center justify-center mx-auto">
            <X className="w-8 h-8 text-error" />
          </div>
          <div>
            <h3 className="text-lg font-semibold text-neutral-900 font-display">حدث خطأ</h3>
            <p className="text-neutral-600 font-primary mt-1">لم نتمكن من تحميل الدورات</p>
          </div>
          <Button onClick={fetchCourses} variant="primary">
            إعادة المحاولة
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      {/* AI Recommendations Section */}
      {!searchTerm && !categoryFilter && aiRecommendations.length > 0 && (
        <FadeInScroll>
          <div className="space-y-6">
            <div className="flex items-center gap-2">
              <Brain className="w-6 h-6 text-primary-600" />
              <h2 className="text-2xl font-bold text-neutral-900 font-display">
                اقتراحات ذكية
              </h2>
            </div>
            
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              {aiRecommendations.map((recommendation, index) => (
                <motion.div
                  key={recommendation.id}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: index * 0.1 }}
                >
                  <Card className="p-6 hover:shadow-elevation-3 transition-all duration-300">
                    <div className="flex items-center gap-3 mb-4">
                      <div className="w-10 h-10 bg-primary-100 rounded-lg flex items-center justify-center">
                        <recommendation.icon className="w-5 h-5 text-primary-600" />
                      </div>
                      <div>
                        <h3 className="font-semibold text-neutral-900 font-display">
                          {recommendation.title}
                        </h3>
                        <p className="text-sm text-neutral-600 font-primary">
                          {recommendation.description}
                        </p>
                      </div>
                    </div>
                    
                    <div className="space-y-3">
                      {recommendation.courses.slice(0, 2).map((course) => (
                        <div key={course.id} className="flex items-center gap-3 p-2 rounded-lg hover:bg-neutral-50 transition-colors">
                          <div className="w-12 h-8 bg-neutral-200 rounded overflow-hidden">
                            <img 
                              src={course.thumbnailUrl} 
                              alt={course.title}
                              className="w-full h-full object-cover"
                            />
                          </div>
                          <div className="flex-1 min-w-0">
                            <p className="text-sm font-medium text-neutral-900 truncate font-primary">
                              {course.title}
                            </p>
                            <p className="text-xs text-neutral-500 font-primary">
                              {course.professor.name}
                            </p>
                          </div>
                        </div>
                      ))}
                    </div>
                    
                    <Button 
                      variant="outline" 
                      size="sm" 
                      className="w-full mt-4"
                      onClick={() => {
                        // Filter by recommendation type
                        handleFilterChange('sort', recommendation.type);
                      }}
                    >
                      عرض المزيد
                    </Button>
                  </Card>
                </motion.div>
              ))}
            </div>
          </div>
        </FadeInScroll>
      )}

      {/* Search and Filters */}
      <div className="space-y-4">
        {/* Search Bar */}
        <div className="relative max-w-2xl">
          <div className="relative">
            <Search className="absolute left-4 top-1/2 transform -translate-y-1/2 h-5 w-5 text-neutral-500" />
            <Input
              type="text"
              placeholder="ابحث عن الدورات، المدربين، أو المواضيع..."
              value={searchTerm}
              onChange={(e) => handleSearchWithSuggestions(e.target.value)}
              onFocus={() => searchTerm && setShowSuggestions(true)}
              onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
              className="pl-12 pr-4 h-12 text-base font-primary"
            />
          </div>
          
          {/* Search Suggestions */}
          <AnimatePresence>
            {showSuggestions && searchSuggestions.length > 0 && (
              <motion.div
                className="absolute top-full left-0 right-0 mt-2 bg-white border border-neutral-200 rounded-lg shadow-elevation-4 z-10"
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
              >
                <div className="p-2">
                  {searchSuggestions.map((suggestion, index) => (
                    <button
                      key={index}
                      className="w-full text-right px-3 py-2 hover:bg-neutral-50 rounded text-sm font-primary transition-colors"
                      onClick={() => {
                        handleSearch(suggestion);
                        setShowSuggestions(false);
                      }}
                    >
                      {suggestion}
                    </button>
                  ))}
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>

        {/* Filter Controls */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Button
              variant="outline"
              onClick={() => setShowFilters(!showFilters)}
              className="flex items-center gap-2"
            >
              <SlidersHorizontal className="w-4 h-4" />
              فلترة
              {activeFiltersCount > 0 && (
                <Badge variant="default" className="ml-2">
                  {activeFiltersCount}
                </Badge>
              )}
            </Button>

            {/* Quick Filters */}
            <div className="flex items-center gap-2">
              <Button
                variant={categoryFilter === '' ? 'primary' : 'ghost'}
                size="sm"
                onClick={() => handleFilterChange('category', '')}
              >
                الكل
              </Button>
              {filterOptions.categories.slice(0, 3).map((category) => (
                <Button
                  key={category.id}
                  variant={categoryFilter === category.id ? 'primary' : 'ghost'}
                  size="sm"
                  onClick={() => handleFilterChange('category', category.id)}
                >
                  {category.name}
                </Button>
              ))}
            </div>
          </div>

          {/* View Mode & Sort */}
          <div className="flex items-center gap-2">
            <div className="flex items-center border border-neutral-200 rounded-lg p-1">
              <Button
                variant={viewMode === 'grid' ? 'primary' : 'ghost'}
                size="sm"
                onClick={() => setViewMode('grid')}
                className="p-2"
              >
                <Grid3X3 className="w-4 h-4" />
              </Button>
              <Button
                variant={viewMode === 'list' ? 'primary' : 'ghost'}
                size="sm"
                onClick={() => setViewMode('list')}
                className="p-2"
              >
                <List className="w-4 h-4" />
              </Button>
            </div>

            <select
              value={sortFilter}
              onChange={(e) => handleFilterChange('sort', e.target.value)}
              className="px-3 py-2 border border-neutral-200 rounded-lg text-sm font-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              {filterOptions.sortOptions.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </div>
        </div>

        {/* Advanced Filters */}
        <AnimatePresence>
          {showFilters && (
            <motion.div
              className="grid grid-cols-1 md:grid-cols-3 gap-4 p-4 bg-neutral-50 rounded-lg"
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
            >
              {/* Category Filter */}
              <div>
                <label className="block text-sm font-medium text-neutral-700 mb-2 font-display">
                  التصنيف
                </label>
                <select
                  value={categoryFilter}
                  onChange={(e) => handleFilterChange('category', e.target.value)}
                  className="w-full px-3 py-2 border border-neutral-200 rounded-lg text-sm font-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
                >
                  <option value="">جميع التصنيفات</option>
                  {filterOptions.categories.map((category) => (
                    <option key={category.id} value={category.id}>
                      {category.name}
                    </option>
                  ))}
                </select>
              </div>

              {/* Price Filter */}
              <div>
                <label className="block text-sm font-medium text-neutral-700 mb-2 font-display">
                  السعر
                </label>
                <select
                  value={priceRangeFilter}
                  onChange={(e) => handleFilterChange('priceRange', e.target.value)}
                  className="w-full px-3 py-2 border border-neutral-200 rounded-lg text-sm font-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
                >
                  <option value="">جميع الأسعار</option>
                  {filterOptions.priceRanges.map((range) => (
                    <option key={range.value} value={range.value}>
                      {range.label}
                    </option>
                  ))}
                </select>
              </div>

              {/* Level Filter */}
              <div>
                <label className="block text-sm font-medium text-neutral-700 mb-2 font-display">
                  المستوى
                </label>
                <select
                  value={levelFilter}
                  onChange={(e) => handleFilterChange('level', e.target.value)}
                  className="w-full px-3 py-2 border border-neutral-200 rounded-lg text-sm font-primary focus:outline-none focus:ring-2 focus:ring-primary-500"
                >
                  <option value="">جميع المستويات</option>
                  {filterOptions.levels.map((level) => (
                    <option key={level.value} value={level.value}>
                      {level.label}
                    </option>
                  ))}
                </select>
              </div>
            </motion.div>
          )}
        </AnimatePresence>

        {/* Active Filters */}
        {activeFiltersCount > 0 && (
          <div className="flex items-center gap-2 flex-wrap">
            <span className="text-sm text-neutral-600 font-primary">الفلاتر النشطة:</span>
            {searchTerm && (
              <Badge variant="secondary" className="flex items-center gap-1">
                البحث: {searchTerm}
                <button onClick={() => handleSearch('')}>
                  <X className="w-3 h-3" />
                </button>
              </Badge>
            )}
            {categoryFilter && (
              <Badge variant="secondary" className="flex items-center gap-1">
                التصنيف: {filterOptions.categories.find(c => c.id === categoryFilter)?.name}
                <button onClick={() => handleFilterChange('category', '')}>
                  <X className="w-3 h-3" />
                </button>
              </Badge>
            )}
            <Button variant="ghost" size="sm" onClick={clearFilters}>
              مسح الكل
            </Button>
          </div>
        )}
      </div>

      {/* Results Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <h2 className="text-xl font-semibold text-neutral-900 font-display">
            {searchTerm ? `نتائج البحث عن "${searchTerm}"` : 'جميع الدورات'}
          </h2>
          <Badge variant="outline" className="font-primary">
            {totalCount} دورة
          </Badge>
        </div>
        
        {isLoading && (
          <div className="flex items-center gap-2 text-sm text-neutral-600">
            <Loader2 className="w-4 h-4 animate-spin" />
            <span className="font-primary">جاري التحديث...</span>
          </div>
        )}
      </div>

      {/* Courses Grid */}
      {courses.length > 0 ? (
        <StaggerChildren className={cn(
          "grid gap-6",
          viewMode === 'grid' 
            ? "grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4" 
            : "grid-cols-1"
        )}>
          {courses.map((course, index) => (
            <StaggerItem key={course.id}>
              <CourseCard
                course={course}
                userRole={userRole}
                userId={userId}
                viewMode={viewMode}
              />
            </StaggerItem>
          ))}
        </StaggerChildren>
      ) : (
        <div className="text-center py-12">
          <div className="w-16 h-16 bg-neutral-100 rounded-full flex items-center justify-center mx-auto mb-4">
            <Search className="w-8 h-8 text-neutral-400" />
          </div>
          <h3 className="text-lg font-semibold text-neutral-900 font-display mb-2">
            لم نجد أي دورات
          </h3>
          <p className="text-neutral-600 font-primary mb-4">
            جرب تغيير معايير البحث أو الفلاتر
          </p>
          <Button onClick={clearFilters} variant="primary">
            مسح الفلاتر
          </Button>
        </div>
      )}

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex justify-center">
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              disabled={currentPage === 1}
              onClick={() => handlePageChange(currentPage - 1)}
            >
              السابق
            </Button>
            
            {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
              const page = i + 1;
              return (
                <Button
                  key={page}
                  variant={currentPage === page ? 'primary' : 'outline'}
                  onClick={() => handlePageChange(page)}
                  className="w-10 h-10 p-0"
                >
                  {page}
                </Button>
              );
            })}
            
            <Button
              variant="outline"
              disabled={currentPage === totalPages}
              onClick={() => handlePageChange(currentPage + 1)}
            >
              التالي
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}

#22: ./src/components/course/CourseContent.tsx
--------------------------------------------------------------------------------
// src/components/course/CourseContent.tsx - Modular Course Content
"use client";

import { useState, useEffect, useMemo } from "react";
import { motion } from "framer-motion";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { CertificateGenerator } from "@/components/certificates/CertificateGenerator";
import { VideoPlayer } from "./course-content/VideoPlayer";
import { LessonDiscussions } from "./course-content/LessonDiscussions";
import { LessonMaterials } from "./course-content/LessonMaterials";
import { CourseProgressCard } from "./course-content/CourseProgressCard";
import {
  useCourseContent,
  type Lesson as HookLesson, // Rename imported type
  type Course,
} from "@/hooks/useCourseContent";
import { useOptimizedMotion } from "@/hooks/useAnimations";
import {
  FadeInScroll,
  StaggerChildren,
  StaggerItem,
} from "@/components/ui/micro-interactions";
import {
  BookOpen,
  CheckCircle,
  Bookmark,
  Share2,
  FileText,
  MessageSquare,
  Award,
  Clock,
  Play
} from "lucide-react";
import { cn } from "@/lib/utils";
import { JsonValue } from "@prisma/client/runtime/library";

// Extend the hook's Lesson type locally
interface Lesson extends HookLesson {
    materials?: JsonValue;
}

interface CourseContentProps {
  course: Course;
  lessons: Lesson[];
}

export function CourseContent({ course, lessons }: CourseContentProps) {
  const {
    selectedLesson,
    setSelectedLesson,
    lessonProgress,
    completedLessons,
    overallProgress,
    totalWatchedTime,
    totalDuration,
    completedCount,
    handleLessonComplete,
  } = useCourseContent(course, lessons);

  const { shouldReduceMotion } = useOptimizedMotion();
  const [activeTab, setActiveTab] = useState("lessons");

  const totalCount = lessons.length;
  const completionRate = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

  const handleVideoProgress = (progress: number) => {
    if (progress >= 90 && selectedLesson && !completedLessons.has(selectedLesson.id)) {
      handleLessonComplete();
    }
  };

  const handleVideoComplete = () => {
    if (selectedLesson && !completedLessons.has(selectedLesson.id)) {
      handleLessonComplete();
    }
  };

  const parsedMaterials = useMemo(() => {
    const materials = (selectedLesson as Lesson)?.materials;
    if (Array.isArray(materials)) {
      return materials.filter(
        (m): m is any => // Using 'any' for now, should be a defined Material type
          typeof m === 'object' && m !== null && 'title' in m && 'url' in m
      );
    }
    return [];
  }, [selectedLesson]);

  return (
    <div className="space-y-6">
      {/* Enhanced Progress Card */}
      <FadeInScroll>
        <Card className="overflow-hidden border-0 shadow-elevation-2">
          <div className="bg-gradient-to-r from-primary-500 to-secondary-500 p-6 text-black">
            <div className="flex items-center justify-between mb-4">
              <div>
                <h2 className="text-2xl font-bold font-display leading-arabic-tight">
                  {course.title}
                </h2>
                <p className="text-black/80 font-primary">
                  {course.description}
                </p>
              </div>
              <div className="text-right">
                <div className="text-3xl font-bold font-display">
                  {Math.round(overallProgress)}%
                </div>
                <p className="text-black/80 text-sm font-primary">مكتمل</p>
              </div>
            </div>

            <Progress value={overallProgress} className="mb-4 bg-white/20" />

            <div className="grid grid-cols-3 gap-4 text-center">
              <div>
                <div className="text-xl font-bold font-display">
                  {completedCount}
                </div>
                <p className="text-black/80 text-sm font-primary">
                  دروس مكتملة
                </p>
              </div>
              <div>
                <div className="text-xl font-bold font-display">
                  {lessons.length}
                </div>
                <p className="text-black/80 text-sm font-primary">
                  إجمالي الدروس
                </p>
              </div>
              <div>
                <div className="text-xl font-bold font-display">
                  {Math.round(totalWatchedTime / 60)}
                </div>
                <p className="text-black/80 text-sm font-primary">
                  دقيقة مشاهدة
                </p>
              </div>
            </div>
          </div>
        </Card>
      </FadeInScroll>

      {/* Enhanced Tabs */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
        <TabsList className="grid w-full grid-cols-5 h-12 bg-neutral-100 p-1">
          <TabsTrigger
            value="lessons"
            className="flex items-center gap-2 font-primary"
          >
            <Play className="w-4 h-4" />
            الدروس
          </TabsTrigger>
          <TabsTrigger
            value="materials"
            className="flex items-center gap-2 font-primary"
          >
            <FileText className="w-4 h-4" />
            المواد
          </TabsTrigger>
          <TabsTrigger
            value="discussions"
            className="flex items-center gap-2 font-primary"
          >
            <MessageSquare className="w-4 h-4" />
            النقاشات
          </TabsTrigger>
          <TabsTrigger
            value="notes"
            className="flex items-center gap-2 font-primary"
          >
            <BookOpen className="w-4 h-4" />
            الملاحظات
          </TabsTrigger>
          <TabsTrigger
            value="certificate"
            className="flex items-center gap-2 font-primary"
          >
            <Award className="w-4 h-4" />
            الشهادة
          </TabsTrigger>
        </TabsList>

        {/* Lessons Tab with Enhanced Video Player */}
        <TabsContent value="lessons" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
            {/* Sidebar */}
            <div className="lg:col-span-1 space-y-6">
              {/* Course Progress */}
              <CourseProgressCard
                completedLessons={completedCount}
                totalLessons={totalCount}
                totalWatchTime={Math.round(totalWatchedTime / 60)}
                estimatedTime={Math.round(totalDuration / 60)}
                currentStreak={7}
                xpEarned={850}
              />
              
              {/* Lesson Navigation */}
              <Card className="sticky top-6">
                <CardHeader>
                  <CardTitle className="flex items-center gap-2 font-display">
                    <BookOpen className="w-5 h-5 text-primary-600" />
                    قائمة الدروس
                  </CardTitle>
                </CardHeader>
                <CardContent className="p-0">
                  <StaggerChildren className="space-y-1">
                    {lessons.map((lesson, index) => (
                      <StaggerItem key={lesson.id}>
                        <motion.button
                          className={cn(
                            "w-full text-right p-4 hover:bg-neutral-50 transition-colors border-b border-neutral-100 last:border-b-0",
                            selectedLesson?.id === lesson.id &&
                              "bg-primary-50 border-primary-200"
                          )}
                          onClick={() => setSelectedLesson(lesson)}
                          whileHover={{ x: 4 }}
                          transition={{ duration: 0.1 }}
                        >
                          <div className="flex items-center gap-3">
                            <div
                              className={cn(
                                "w-8 h-8 rounded-full flex items-center justify-center text-sm font-semibold",
                                completedLessons.has(lesson.id)
                                  ? "bg-success text-black"
                                  : selectedLesson?.id === lesson.id
                                  ? "bg-primary-500 text-black"
                                  : "bg-neutral-200 text-neutral-600"
                              )}
                            >
                              {completedLessons.has(lesson.id) ? (
                                <CheckCircle className="w-4 h-4" />
                              ) : (
                                index + 1
                              )}
                            </div>
                            <div className="flex-1 min-w-0">
                              <h4 className="font-medium text-sm leading-arabic-tight truncate font-primary">
                                {lesson.title}
                              </h4>
                              <div className="flex items-center gap-2 text-xs text-neutral-500 mt-1">
                                <Clock className="w-3 h-3" />
                                <span className="font-primary">
                                  {Math.round((lesson.duration || 0) / 60)} دقيقة
                                </span>
                                {lessonProgress[lesson.id] && (
                                  <Badge variant="secondary" className="text-xs">
                                    {Math.round(lessonProgress[lesson.id])}%
                                  </Badge>
                                )}
                              </div>
                            </div>
                          </div>
                        </motion.button>
                      </StaggerItem>
                    ))}
                  </StaggerChildren>
                </CardContent>
              </Card>
            </div>

            {/* Main Content */}
            <div className="lg:col-span-3">
              {selectedLesson ? (
                <div className="space-y-4">
                  <VideoPlayer
                    videoUrl={`https://video.bunnycdn.com/play/${selectedLesson.bunnyVideoId}`}
                    title={selectedLesson.title}
                    onProgress={handleVideoProgress}
                    onComplete={handleVideoComplete}
                    className="aspect-video"
                  />
                  
                  <Card>
                    <CardContent className="p-6">
                      <div className="flex items-center justify-between mb-4">
                        <div>
                          <h2 className="text-xl font-bold font-display leading-arabic-tight">
                            {selectedLesson.title}
                          </h2>
                          <p className="text-neutral-600 font-primary mt-1">
                            الدرس رقم {selectedLesson.order} - مدة الدرس: {Math.round((selectedLesson.duration || 0) / 60)} دقيقة
                          </p>
                        </div>
                        <div className="flex items-center gap-2">
                          <Button variant="outline" size="sm">
                            <Bookmark className="w-4 h-4 ml-2" />
                            حفظ
                          </Button>
                          <Button variant="outline" size="sm">
                            <Share2 className="w-4 h-4 ml-2" />
                            مشاركة
                          </Button>
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                  
                  {/* Lesson Discussions */}
                  <LessonDiscussions 
                    lessonId={selectedLesson.id}
                  />
                </div>
              ) : (
                <Card className="aspect-video flex items-center justify-center">
                  <div className="text-center">
                    <Play className="w-16 h-16 text-neutral-400 mx-auto mb-4" />
                    <h3 className="text-lg font-semibold text-neutral-900 font-display">
                      اختر درساً لبدء المشاهدة
                    </h3>
                    <p className="text-neutral-600 font-primary">
                      اختر درساً من القائمة الجانبية لبدء التعلم
                    </p>
                  </div>
                </Card>
              )}
            </div>
          </div>
        </TabsContent>

        {/* Materials Tab */}
        <TabsContent value="materials" className="space-y-6">
          <LessonMaterials 
            materials={parsedMaterials}
          />
        </TabsContent>

        {/* Discussions Tab */}
        <TabsContent value="discussions" className="space-y-6">
          <LessonDiscussions 
            lessonId={selectedLesson?.id || ''}
          />
        </TabsContent>

        {/* Notes Tab */}
        <TabsContent value="notes" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2 font-display">
                <BookOpen className="w-5 h-5 text-primary-600" />
                ملاحظاتي
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-center py-8 text-neutral-500">
                <BookOpen className="w-12 h-12 mx-auto mb-3 opacity-50" />
                <p>لا توجد ملاحظات حتى الآن</p>
                <p className="text-sm">ابدأ بإضافة ملاحظاتك أثناء مشاهدة الدروس</p>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        {/* Certificate Tab */}
        <TabsContent value="certificate" className="space-y-6">
          {completionRate >= 100 ? (
            <CertificateGenerator
              courseId={course.id}
              courseName={course.title}
              completionRate={completionRate}
            />
          ) : (
            <Card>
              <CardContent className="p-8 text-center">
                <Award className="w-16 h-16 text-neutral-400 mx-auto mb-4" />
                <h3 className="text-lg font-semibold text-neutral-900 font-display mb-2">
                  الشهادة غير متاحة بعد
                </h3>
                <p className="text-neutral-600 font-primary mb-4">
                  أكمل جميع دروس الدورة للحصول على الشهادة
                </p>
                <div className="max-w-md mx-auto">
                  <Progress value={completionRate} className="mb-2" />
                  <p className="text-sm text-neutral-500">
                    {completedCount} من {totalCount} دروس مكتملة ({Math.round(completionRate)}%)
                  </p>
                </div>
              </CardContent>
            </Card>
          )}
        </TabsContent>
      </Tabs>
    </div>
  );
}

#23: ./src/components/course/CourseProgress.tsx
--------------------------------------------------------------------------------
"use client";

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { FadeInScroll, StaggerChildren, StaggerItem } from "@/components/ui/micro-interactions";
import { useOptimizedMotion } from "@/hooks/useAnimations";
import {
  Trophy, Star, Flame, Target, Clock, Award, Zap, Shield, Rocket, Brain,
  Sparkles, TrendingUp, BarChart3, CheckCircle, Play, BookOpen, Share2, Plus, ChevronRight
} from "lucide-react";
import { cn } from "@/lib/utils";

interface CourseProgressProps {
  courseId: string;
  courseName: string;
  overallProgress: number;
  completedCount: number;
  totalLessons: number;
  totalWatchedTime: number;
  totalDuration: number;
  currentStreak: number;
  longestStreak: number;
  studyGoals: StudyGoal[];
  achievements: Achievement[];
  learningPath: LearningPathNode[];
  userId: string;
  onGoalCreate?: (goal: Partial<StudyGoal>) => void;
  onCertificateGenerate?: () => void;
}

interface StudyGoal {
  id: string;
  title: string;
  description: string;
  targetValue: number;
  currentValue: number;
  unit: string;
  deadline: string;
  priority: 'high' | 'medium' | 'low';
  category: 'time' | 'lessons' | 'streak' | 'completion';
  completed: boolean;
  reward: { xp: number; badge?: string };
}

interface Achievement {
  id: string;
  title: string;
  description: string;
  icon: React.ElementType;
  earned: boolean;
  earnedDate?: string;
  progress?: number;
  maxProgress?: number;
  rarity: 'common' | 'rare' | 'epic' | 'legendary';
  xpReward: number;
  category: 'learning' | 'social' | 'streak' | 'completion' | 'special';
}

interface LearningPathNode {
  id: string;
  title: string;
  type: 'lesson' | 'quiz' | 'project' | 'milestone';
  completed: boolean;
  locked: boolean;
  estimatedTime: number;
  xpReward: number;
  dependencies: string[];
}

interface Milestone {
  id: string;
  title: string;
  description: string;
  progress: number;
  target: number;
  reward: string;
  icon: React.ElementType;
  color: string;
}

export function CourseProgress({
  courseId, courseName, overallProgress, completedCount, totalLessons,
  totalWatchedTime, totalDuration, currentStreak, longestStreak,
  studyGoals, achievements, learningPath, userId,
  onGoalCreate, onCertificateGenerate
}: CourseProgressProps) {
  const { shouldReduceMotion } = useOptimizedMotion();
  const [activeTab, setActiveTab] = useState<'overview' | 'achievements' | 'goals' | 'path'>('overview');
  const [showCelebration, setShowCelebration] = useState(false);
  const [newAchievements, setNewAchievements] = useState<Achievement[]>([]);
  const [milestones, setMilestones] = useState<Milestone[]>([]);

  const completionRate = totalLessons > 0 ? (completedCount / totalLessons) * 100 : 0;
  const avgSessionTime = totalWatchedTime > 0 ? totalWatchedTime / completedCount || 0 : 0;
  const estTimeRemaining = totalDuration - totalWatchedTime;
  const dailyAvg = currentStreak > 0 ? totalWatchedTime / currentStreak : 0;
  
  const currentXP = Math.floor(totalWatchedTime * 2 + completedCount * 50 + currentStreak * 25);
  const level = Math.floor(currentXP / 1000) + 1;
  const xpToNext = (level * 1000) - currentXP;
  const xpProgress = ((currentXP % 1000) / 1000) * 100;

  useEffect(() => {
    const loadMilestones = async () => {
      try {
        const res = await fetch(`/api/courses/${courseId}/milestones?userId=${userId}`);
        if (res.ok) {
          const data = await res.json();
          setMilestones(data.milestones || []);
        }
      } catch (error) {
        console.error('Failed to load milestones:', error);
        setMilestones([]);
      }
    };
    if (userId && courseId) loadMilestones();
  }, [userId, courseId, completedCount, currentStreak, completionRate]);

  useEffect(() => {
    const completedMs = milestones.filter(m => m.progress >= m.target);
    if (completedMs.length > 0 && !showCelebration) {
      setShowCelebration(true);
      setTimeout(() => setShowCelebration(false), 3000);
    }
  }, [milestones, showCelebration]);

  const getRarityColor = (rarity: Achievement['rarity']) => {
    const colors = {
      common: 'text-neutral-600 bg-neutral-100 border-neutral-200',
      rare: 'text-blue-600 bg-blue-100 border-blue-200',
      epic: 'text-purple-600 bg-purple-100 border-purple-200',
      legendary: 'text-yellow-600 bg-yellow-100 border-yellow-200'
    };
    return colors[rarity] || colors.common;
  };

  const getPriorityColor = (priority: StudyGoal['priority']) => {
    const colors = {
      high: 'border-red-200 bg-red-50',
      medium: 'border-yellow-200 bg-yellow-50',
      low: 'border-green-200 bg-green-50'
    };
    return colors[priority] || 'border-neutral-200 bg-neutral-50';
  };

  const StatCard = ({ icon: Icon, title, value, desc, color }: any) => (
    <Card>
      <CardContent className="p-6">
        <div className="flex items-center gap-3 mb-4">
          <div className={`w-12 h-12 ${color} rounded-full flex items-center justify-center`}>
            <Icon className="w-6 h-6" />
          </div>
          <div>
            <h3 className="font-semibold font-display">{title}</h3>
            <p className="text-2xl font-bold font-display" style={{color: color.includes('blue') ? '#2563eb' : color.includes('green') ? '#16a34a' : '#9333ea'}}>
              {value}
            </p>
          </div>
        </div>
        <p className="text-sm text-neutral-600 font-primary">{desc}</p>
      </CardContent>
    </Card>
  );

  const tabs = [
    { id: 'overview', label: 'نظرة عامة', icon: BarChart3 },
    { id: 'achievements', label: 'الإنجازات', icon: Trophy },
    { id: 'goals', label: 'الأهداف', icon: Target },
    { id: 'path', label: 'مسار التعلم', icon: BookOpen }
  ];

  return (
    <div className="space-y-6">
      <AnimatePresence>
        {showCelebration && (
          <motion.div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <motion.div
              className="bg-white rounded-2xl p-8 text-center max-w-md mx-4"
              initial={{ scale: 0.5, y: 50 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.5, y: 50 }}
              transition={{ type: "spring", stiffness: 300, damping: 25 }}
            >
              <motion.div
                className="w-20 h-20 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full flex items-center justify-center mx-auto mb-4"
                animate={{ rotate: [0, 360] }}
                transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
              >
                <Trophy className="w-10 h-10 text-black" />
              </motion.div>
              <h2 className="text-2xl font-bold text-neutral-900 font-display mb-2">🎉 تهانينا!</h2>
              <p className="text-neutral-600 font-primary mb-4">لقد حققت إنجازاً جديداً في رحلتك التعليمية</p>
              <Button onClick={() => setShowCelebration(false)}>متابعة التعلم</Button>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      <FadeInScroll>
        <Card className="overflow-hidden border-0 shadow-elevation-3">
          <div className="bg-gradient-to-br from-primary-500 via-primary-600 to-secondary-500 p-6 text-black relative">
            <div className="absolute inset-0 opacity-10">
              <div className="absolute top-4 right-4 w-16 h-16 border-2 border-white rounded-full" />
              <div className="absolute bottom-4 left-4 w-12 h-12 border-2 border-white rounded-full" />
              <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-24 h-24 border border-white rounded-full" />
            </div>
            
            <div className="relative z-10">
              <div className="flex items-center justify-between mb-6">
                <div>
                  <h2 className="text-2xl font-bold mb-2 font-display leading-arabic-tight">{courseName}</h2>
                  <p className="text-black/90 font-primary">المستوى {level} • {currentXP.toLocaleString()} XP</p>
                </div>
                
                <div className="text-center">
                  <div className="relative">
                    <div className="w-16 h-16 bg-white/20 rounded-full flex items-center justify-center mb-2 backdrop-blur-sm">
                      <span className="text-xl font-bold font-display">{level}</span>
                    </div>
                    <motion.div
                      className="absolute inset-0 border-4 border-white/30 rounded-full"
                      style={{ background: `conic-gradient(from 0deg, white ${xpProgress}%, transparent ${xpProgress}%)` }}
                      animate={{ rotate: 360 }}
                      transition={{ duration: 2, ease: "easeInOut" }}
                    />
                  </div>
                  <p className="text-xs text-black/80 font-primary">{xpToNext} XP للمستوى التالي</p>
                </div>
              </div>
              
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <span className="font-primary">التقدم الإجمالي</span>
                  <span className="font-semibold font-primary">{completedCount} / {totalLessons} دروس ({Math.round(completionRate)}%)</span>
                </div>
                <Progress value={completionRate} className="h-3 bg-white/20" />
                
                <div className="grid grid-cols-4 gap-4 mt-6">
                  {[
                    { icon: Flame, value: currentStreak, label: 'يوم متتالي' },
                    { icon: Clock, value: Math.round(totalWatchedTime / 60), label: 'دقيقة مشاهدة' },
                    { icon: Trophy, value: achievements.filter(a => a.earned).length, label: 'إنجاز' },
                    { icon: Target, value: studyGoals.filter(g => g.completed).length, label: 'هدف محقق' }
                  ].map((stat, i) => (
                    <div key={i} className="text-center">
                      <div className="flex items-center justify-center w-10 h-10 bg-white/20 rounded-full mb-2 mx-auto">
                        <stat.icon className="w-5 h-5" />
                      </div>
                      <div className="text-lg font-bold font-display">{stat.value}</div>
                      <p className="text-black/80 text-xs font-primary">{stat.label}</p>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        </Card>
      </FadeInScroll>

      <div className="flex items-center gap-2 overflow-x-auto pb-2">
        {tabs.map((tab) => (
          <Button
            key={tab.id}
            variant={activeTab === tab.id ? 'primary' : 'outline'}
            size="sm"
            onClick={() => setActiveTab(tab.id as any)}
            className="flex items-center gap-2 whitespace-nowrap"
          >
            <tab.icon className="w-4 h-4" />
            {tab.label}
          </Button>
        ))}
      </div>

      <AnimatePresence mode="wait">
        {activeTab === 'overview' && (
          <motion.div
            key="overview"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            className="space-y-6"
          >
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2 font-display">
                  <Sparkles className="w-5 h-5 text-primary-600" />
                  المعالم والإنجازات
                </CardTitle>
              </CardHeader>
              <CardContent>
                <StaggerChildren className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {milestones.map((ms) => (
                    <StaggerItem key={ms.id}>
                      <Card className="p-4 hover:shadow-elevation-2 transition-all duration-200">
                        <div className="flex items-center gap-3 mb-3">
                          <div className={cn("w-10 h-10 rounded-full flex items-center justify-center", ms.color)}>
                            <ms.icon className="w-5 h-5" />
                          </div>
                          <div className="flex-1">
                            <h4 className="font-semibold font-display leading-arabic-tight">{ms.title}</h4>
                            <p className="text-sm text-neutral-600 font-primary">{ms.description}</p>
                          </div>
                          {ms.progress >= ms.target && <CheckCircle className="w-5 h-5 text-success" />}
                        </div>
                        <div className="space-y-2">
                          <div className="flex items-center justify-between text-sm">
                            <span className="font-primary">{Math.min(ms.progress, ms.target)} / {ms.target}</span>
                            <Badge variant="secondary" className="text-xs">{ms.reward}</Badge>
                          </div>
                          <Progress value={(ms.progress / ms.target) * 100} className="h-2" />
                        </div>
                      </Card>
                    </StaggerItem>
                  ))}
                </StaggerChildren>
              </CardContent>
            </Card>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <StatCard 
                icon={TrendingUp} 
                title="معدل التقدم" 
                value={`${Math.round(dailyAvg)} دقيقة/يوم`}
                desc="متوسط وقت الدراسة اليومي"
                color="bg-blue-100 text-blue-600"
              />
              <StatCard 
                icon={Clock} 
                title="الوقت المتبقي" 
                value={`${Math.round(estTimeRemaining / 60)} ساعة`}
                desc="تقدير لإكمال الدورة"
                color="bg-green-100 text-green-600"
              />
              <StatCard 
                icon={Zap} 
                title="أطول Streak" 
                value={`${longestStreak} يوم`}
                desc="أطول فترة دراسة متواصلة"
                color="bg-purple-100 text-purple-600"
              />
            </div>
          </motion.div>
        )}

        {activeTab === 'achievements' && (
          <motion.div key="achievements" initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -20 }} className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between font-display">
                  <div className="flex items-center gap-2">
                    <Trophy className="w-5 h-5 text-primary-600" />
                    الإنجازات ({achievements.filter(a => a.earned).length}/{achievements.length})
                  </div>
                  <Button variant="outline" size="sm">
                    <Share2 className="w-4 h-4 ml-2" />
                    مشاركة الإنجازات
                  </Button>
                </CardTitle>
              </CardHeader>
              <CardContent>
                <StaggerChildren className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {achievements.map((ach) => (
                    <StaggerItem key={ach.id}>
                      <motion.div
                        className={cn("p-4 rounded-lg border-2 transition-all duration-200",
                          ach.earned ? getRarityColor(ach.rarity) + " shadow-elevation-2" : "border-neutral-200 bg-neutral-50 opacity-60")}
                        whileHover={ach.earned ? { scale: 1.02 } : {}}
                      >
                        <div className="flex items-center gap-3 mb-3">
                          <div className={cn("w-12 h-12 rounded-full flex items-center justify-center",
                            ach.earned ? "bg-white/50" : "bg-neutral-200")}>
                            <ach.icon className={cn("w-6 h-6", ach.earned ? "text-current" : "text-neutral-400")} />
                          </div>
                          <div className="flex-1">
                            <h4 className="font-semibold font-display leading-arabic-tight">{ach.title}</h4>
                            <p className="text-sm opacity-80 font-primary">{ach.description}</p>
                          </div>
                        </div>
                        
                        {ach.earned ? (
                          <div className="flex items-center justify-between">
                            <Badge variant="secondary" className="text-xs">+{ach.xpReward} XP</Badge>
                            <span className="text-xs opacity-70 font-primary">
                              {ach.earnedDate && new Date(ach.earnedDate).toLocaleDateString('ar-EG')}
                            </span>
                          </div>
                        ) : (
                          <div className="space-y-2">
                            {ach.progress !== undefined && ach.maxProgress && (
                              <>
                                <div className="flex items-center justify-between text-sm">
                                  <span className="font-primary">{ach.progress} / {ach.maxProgress}</span>
                                  <span className="text-xs opacity-70 font-primary">
                                    {Math.round((ach.progress / ach.maxProgress) * 100)}%
                                  </span>
                                </div>
                                <Progress value={(ach.progress / ach.maxProgress) * 100} className="h-1" />
                              </>
                            )}
                          </div>
                        )}
                      </motion.div>
                    </StaggerItem>
                  ))}
                </StaggerChildren>
              </CardContent>
            </Card>
          </motion.div>
        )}

        {activeTab === 'goals' && (
          <motion.div key="goals" initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -20 }} className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between font-display">
                  <div className="flex items-center gap-2">
                    <Target className="w-5 h-5 text-primary-600" />
                    أهداف الدراسة ({studyGoals.filter(g => g.completed).length}/{studyGoals.length})
                  </div>
                  <Button size="sm" onClick={() => onGoalCreate?.({})}>
                    <Plus className="w-4 h-4 ml-2" />
                    هدف جديد
                  </Button>
                </CardTitle>
              </CardHeader>
              <CardContent>
                <StaggerChildren className="space-y-4">
                  {studyGoals.map((goal) => (
                    <StaggerItem key={goal.id}>
                      <Card className={cn("p-4", getPriorityColor(goal.priority))}>
                        <div className="flex items-center justify-between mb-3">
                          <div className="flex items-center gap-3">
                            <div className={cn("w-10 h-10 rounded-full flex items-center justify-center",
                              goal.completed ? "bg-success text-black" : "bg-white")}>
                              {goal.completed ? <CheckCircle className="w-5 h-5" /> : <Target className="w-5 h-5 text-neutral-600" />}
                            </div>
                            <div>
                              <h4 className="font-semibold font-display leading-arabic-tight">{goal.title}</h4>
                              <p className="text-sm text-neutral-600 font-primary">{goal.description}</p>
                            </div>
                          </div>
                          <div className="text-right">
                            <Badge variant={goal.priority === 'high' ? 'destructive' : goal.priority === 'medium' ? 'default' : 'secondary'} className="text-xs mb-2">
                              {goal.priority === 'high' ? 'عالي' : goal.priority === 'medium' ? 'متوسط' : 'منخفض'}
                            </Badge>
                            <p className="text-xs text-neutral-500 font-primary">
                              {new Date(goal.deadline).toLocaleDateString('ar-EG')}
                            </p>
                          </div>
                        </div>
                        
                        <div className="space-y-2">
                          <div className="flex items-center justify-between text-sm">
                            <span className="font-primary">{goal.currentValue} / {goal.targetValue} {goal.unit}</span>
                            <span className="font-semibold font-primary">{Math.round((goal.currentValue / goal.targetValue) * 100)}%</span>
                          </div>
                          <Progress value={(goal.currentValue / goal.targetValue) * 100} className="h-2" />
                          <div className="flex items-center justify-between text-xs text-neutral-500">
                            <span className="font-primary">المكافأة: +{goal.reward.xp} XP</span>
                            <span className="font-primary">
                              {Math.ceil((goal.targetValue - goal.currentValue) / (goal.currentValue / (Date.now() - new Date(goal.deadline).getTime()) * 86400000))} يوم متبقي
                            </span>
                          </div>
                        </div>
                      </Card>
                    </StaggerItem>
                  ))}
                </StaggerChildren>
              </CardContent>
            </Card>
          </motion.div>
        )}

        {activeTab === 'path' && (
          <motion.div key="path" initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -20 }} className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2 font-display">
                  <BookOpen className="w-5 h-5 text-primary-600" />
                  مسار التعلم التفاعلي
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {learningPath.map((node, idx) => (
                    <motion.div
                      key={node.id}
                      className={cn("flex items-center gap-4 p-4 rounded-lg border-2 transition-all duration-200",
                        node.completed ? "border-success bg-success/5" : node.locked ? "border-neutral-200 bg-neutral-50 opacity-50" : "border-primary-200 bg-primary-50 hover:shadow-elevation-1")}
                      whileHover={!node.locked ? { scale: 1.01 } : {}}
                    >
                      {idx < learningPath.length - 1 && <div className="absolute left-8 top-16 w-0.5 h-8 bg-neutral-200" />}
                      
                      <div className={cn("w-12 h-12 rounded-full flex items-center justify-center relative z-10",
                        node.completed ? "bg-success text-black" : node.locked ? "bg-neutral-200 text-neutral-400" : "bg-primary-500 text-black")}>
                        {node.completed ? <CheckCircle className="w-6 h-6" /> : 
                         node.type === 'lesson' ? <Play className="w-6 h-6" /> : 
                         node.type === 'quiz' ? <Brain className="w-6 h-6" /> : 
                         node.type === 'project' ? <Rocket className="w-6 h-6" /> : <Trophy className="w-6 h-6" />}
                      </div>
                      
                      <div className="flex-1">
                        <div className="flex items-center justify-between mb-2">
                          <h4 className="font-semibold font-display leading-arabic-tight">{node.title}</h4>
                          <div className="flex items-center gap-2">
                            <Badge variant="secondary" className="text-xs">
                              {node.type === 'lesson' ? 'درس' : node.type === 'quiz' ? 'اختبار' : node.type === 'project' ? 'مشروع' : 'معلم'}
                            </Badge>
                            <Badge variant="outline" className="text-xs">+{node.xpReward} XP</Badge>
                          </div>
                        </div>
                        <div className="flex items-center gap-4 text-sm text-neutral-600">
                          <div className="flex items-center gap-1">
                            <Clock className="w-4 h-4" />
                            <span className="font-primary">{node.estimatedTime} دقيقة</span>
                          </div>
                          {node.dependencies.length > 0 && (
                            <div className="flex items-center gap-1">
                              <Shield className="w-4 h-4" />
                              <span className="font-primary">يتطلب {node.dependencies.length} متطلب</span>
                            </div>
                          )}
                        </div>
                      </div>
                      
                      {!node.locked && !node.completed && (
                        <Button size="sm" variant="outline">
                          <ChevronRight className="w-4 h-4" />
                        </Button>
                      )}
                    </motion.div>
                  ))}
                </div>
              </CardContent>
            </Card>
          </motion.div>
        )}
      </AnimatePresence>

      <div className="flex items-center gap-4">
        <Button onClick={onCertificateGenerate} disabled={completionRate < 100} className="flex-1">
          <Award className="w-4 h-4 ml-2" />
          {completionRate >= 100 ? 'تحميل الشهادة' : `أكمل ${Math.round(100 - completionRate)}% للحصول على الشهادة`}
        </Button>
        <Button variant="outline">
          <Share2 className="w-4 h-4 ml-2" />
          مشاركة التقدم
        </Button>
      </div>
    </div>
  );
}


#24: ./src/components/course/MaterialManager.tsx
--------------------------------------------------------------------------------
// src/components/course/MaterialManager.tsx
"use client";

import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { FileUploader } from "@/components/upload/FileUploader";
import {
  Plus,
  Trash2,
  Edit,
  Save,
  X,
  Download,
  Eye,
  FileText,
  Image,
  Video,
} from "lucide-react";
import { toast } from "sonner";
import { JsonValue } from "@prisma/client/runtime/library";

interface Material {
  title: string;
  url: string;
  type?: string;
  size?: number;
  uploadedAt?: string;
}

interface MaterialManagerProps {
  lessonId: string;
  materials: JsonValue;
  onUpdate: (materials: Material[]) => void;
  canEdit?: boolean;
}

export function MaterialManager({
  lessonId,
  materials,
  onUpdate,
  canEdit = false,
}: MaterialManagerProps) {
  const [parsedMaterials, setParsedMaterials] = useState<Material[]>(() => {
    if (Array.isArray(materials)) {
      return materials
        .filter((m) => {
          return (
            typeof m === "object" &&
            m !== null &&
            typeof (m as any).title === "string" &&
            typeof (m as any).url === "string"
          );
        })
        .map((m) => m as unknown as Material);
    }
    return [];
  });

  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [editTitle, setEditTitle] = useState("");
  const [isUploading, setIsUploading] = useState(false);

  const getFileIcon = (url: string, type?: string) => {
    if (type) {
      if (type.startsWith("image/")) return <Image className="w-4 h-4" />;
      if (type.startsWith("video/")) return <Video className="w-4 h-4" />;
    }

    const extension = url.split(".").pop()?.toLowerCase();
    if (["jpg", "jpeg", "png", "gif", "webp"].includes(extension || "")) {
      return <Image className="w-4 h-4" />;
    }
    if (["mp4", "webm", "ogg"].includes(extension || "")) {
      return <Video className="w-4 h-4" />;
    }
    return <FileText className="w-4 h-4" />;
  };

  const handleFileUpload = async (uploadedFiles: any[]) => {
    setIsUploading(true);
    try {
      const newMaterials = uploadedFiles.map((file) => ({
        title: file.name,
        url: file.url,
        type: file.type,
        size: file.size,
        uploadedAt: file.uploadedAt,
      }));

      const updatedMaterials = [...parsedMaterials, ...newMaterials];
      setParsedMaterials(updatedMaterials);
      onUpdate(updatedMaterials);

      toast.success(`تم رفع ${uploadedFiles.length} ملف بنجاح`);
    } catch (error) {
      toast.error("حدث خطأ في رفع الملفات");
    } finally {
      setIsUploading(false);
    }
  };

  const handleEdit = (index: number) => {
    setEditingIndex(index);
    setEditTitle(parsedMaterials[index].title);
  };

  const handleSaveEdit = () => {
    if (editingIndex === null) return;

    const updatedMaterials = [...parsedMaterials];
    updatedMaterials[editingIndex] = {
      ...updatedMaterials[editingIndex],
      title: editTitle,
    };

    setParsedMaterials(updatedMaterials);
    onUpdate(updatedMaterials);
    setEditingIndex(null);
    setEditTitle("");
    toast.success("تم تحديث اسم الملف");
  };

  const handleCancelEdit = () => {
    setEditingIndex(null);
    setEditTitle("");
  };

  const handleDelete = async (index: number) => {
    const material = parsedMaterials[index];

    try {
      // Delete file from server if it's an uploaded file
      if (material.url.startsWith("/uploads/")) {
        await fetch(`/api/upload?url=${encodeURIComponent(material.url)}`, {
          method: "DELETE",
        });
      }

      const updatedMaterials = parsedMaterials.filter((_, i) => i !== index);
      setParsedMaterials(updatedMaterials);
      onUpdate(updatedMaterials);

      toast.success("تم حذف الملف");
    } catch (error) {
      toast.error("حدث خطأ في حذف الملف");
    }
  };

  const handleDownload = (material: Material) => {
    const link = document.createElement("a");
    link.href = material.url;
    link.download = material.title;
    link.target = "_blank";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handlePreview = (material: Material) => {
    window.open(material.url, "_blank");
  };

  const formatFileSize = (bytes?: number) => {
    if (!bytes) return "";
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + " " + sizes[i];
  };

  return (
    <div className="space-y-6">
      {/* Upload Section - Only for editors */}
      {canEdit && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Plus className="w-5 h-5" />
              إضافة ملفات جديدة
            </CardTitle>
          </CardHeader>
          <CardContent>
            <FileUploader
              onUpload={handleFileUpload}
              maxFileSize={50}
              maxFiles={10}
              disabled={isUploading}
            />
          </CardContent>
        </Card>
      )}

      {/* Materials List */}
      <Card>
        <CardHeader>
          <CardTitle>المواد التعليمية ({parsedMaterials.length})</CardTitle>
        </CardHeader>
        <CardContent>
          {parsedMaterials.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <FileText className="w-12 h-12 mx-auto mb-4 opacity-50" />
              <p>لا توجد مواد تعليمية مرفقة بهذا الدرس</p>
              {canEdit && (
                <p className="text-sm mt-2">
                  استخدم النموذج أعلاه لإضافة ملفات
                </p>
              )}
            </div>
          ) : (
            <div className="space-y-3">
              {parsedMaterials.map((material, index) => (
                <div
                  key={index}
                  className="flex items-center gap-3 p-3 border rounded-lg hover:bg-muted/50 transition-colors"
                >
                  {/* File Icon */}
                  <div className="flex-shrink-0 text-primary">
                    {getFileIcon(material.url, material.type)}
                  </div>

                  {/* File Info */}
                  <div className="flex-grow min-w-0">
                    {editingIndex === index ? (
                      <div className="flex items-center gap-2">
                        <Input
                          value={editTitle}
                          onChange={(e) => setEditTitle(e.target.value)}
                          className="flex-grow"
                          placeholder="اسم الملف"
                        />
                        <Button
                          size="sm"
                          onClick={handleSaveEdit}
                          disabled={!editTitle.trim()}
                        >
                          <Save className="w-4 h-4" />
                        </Button>
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={handleCancelEdit}
                        >
                          <X className="w-4 h-4" />
                        </Button>
                      </div>
                    ) : (
                      <>
                        <p className="font-medium truncate">{material.title}</p>
                        <div className="flex items-center gap-4 text-xs text-muted-foreground">
                          {material.size && (
                            <span>{formatFileSize(material.size)}</span>
                          )}
                          {material.uploadedAt && (
                            <span>
                              {new Date(material.uploadedAt).toLocaleDateString(
                                "ar-EG"
                              )}
                            </span>
                          )}
                        </div>
                      </>
                    )}
                  </div>

                  {/* Actions */}
                  {editingIndex !== index && (
                    <div className="flex items-center gap-1">
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handlePreview(material)}
                        title="معاينة"
                      >
                        <Eye className="w-4 h-4" />
                      </Button>

                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => handleDownload(material)}
                        title="تحميل"
                      >
                        <Download className="w-4 h-4" />
                      </Button>

                      {canEdit && (
                        <>
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => handleEdit(index)}
                            title="تعديل"
                          >
                            <Edit className="w-4 h-4" />
                          </Button>

                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => handleDelete(index)}
                            title="حذف"
                            className="text-red-500 hover:text-red-700"
                          >
                            <Trash2 className="w-4 h-4" />
                          </Button>
                        </>
                      )}
                    </div>
                  )}
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}


#25: ./src/components/course/StudyScheduler.tsx
--------------------------------------------------------------------------------
// src/components/course/StudyScheduler.tsx - Personalized Learning Scheduler
"use client";

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import {
  FadeInScroll,
  StaggerChildren,
  StaggerItem,
} from "@/components/ui/micro-interactions";
import {
  Calendar,
  Clock,
  Bell,
  Target,
  Zap,
  Brain,
  Coffee,
  Moon,
  Sun,
  Smartphone,
  Mail,
  Settings,
  Plus,
  Edit,
  Trash2,
  CheckCircle,
  AlertCircle,
  TrendingUp,
  BarChart3,
  Users,
  BookOpen,
  Play,
  Pause,
  RotateCcw,
} from "lucide-react";
import { cn } from "@/lib/utils";

interface StudySchedulerProps {
  courseId: string;
  userId: string;
  onScheduleUpdate?: (schedule: StudySchedule) => void;
  onReminderCreate?: (reminder: StudyReminder) => void;
}

interface StudySchedule {
  id: string;
  userId: string;
  courseId: string;
  title: string;
  description?: string;
  startDate: string;
  endDate: string;
  dailyGoalMinutes: number;
  preferredTimes: TimeSlot[];
  weeklySchedule: WeeklySchedule;
  adaptiveSettings: AdaptiveSettings;
  notifications: NotificationSettings;
  active: boolean;
  createdAt: string;
  updatedAt: string;
}

interface TimeSlot {
  id: string;
  startTime: string; // HH:MM format
  endTime: string;
  priority: "high" | "medium" | "low";
  type: "focus" | "review" | "practice" | "break";
}

interface WeeklySchedule {
  monday: DaySchedule;
  tuesday: DaySchedule;
  wednesday: DaySchedule;
  thursday: DaySchedule;
  friday: DaySchedule;
  saturday: DaySchedule;
  sunday: DaySchedule;
}

interface DaySchedule {
  enabled: boolean;
  timeSlots: TimeSlot[];
  goalMinutes: number;
  restDay: boolean;
}

interface AdaptiveSettings {
  adjustBasedOnProgress: boolean;
  increaseOnSuccess: boolean;
  decreaseOnMissed: boolean;
  considerEnergyLevels: boolean;
  adaptToPerformance: boolean;
  maxDailyMinutes: number;
  minDailyMinutes: number;
}

interface NotificationSettings {
  enabled: boolean;
  pushNotifications: boolean;
  emailReminders: boolean;
  smsReminders: boolean;
  reminderMinutesBefore: number;
  motivationalMessages: boolean;
  progressUpdates: boolean;
  streakReminders: boolean;
}

interface StudyReminder {
  id: string;
  scheduleId: string;
  title: string;
  message: string;
  scheduledTime: string;
  type: "study" | "break" | "review" | "motivation" | "streak";
  priority: "high" | "medium" | "low";
  recurring: boolean;
  completed: boolean;
  snoozed: boolean;
  snoozeUntil?: string;
}

interface StudySession {
  id: string;
  scheduleId: string;
  startTime: string;
  endTime?: string;
  plannedDuration: number;
  actualDuration?: number;
  completed: boolean;
  productivity: number; // 1-10 scale
  energyLevel: number; // 1-10 scale
  notes?: string;
}

export function StudyScheduler({
  courseId,
  userId,
  onScheduleUpdate,
  onReminderCreate,
}: StudySchedulerProps) {
  const [activeTab, setActiveTab] = useState<
    "schedule" | "reminders" | "analytics" | "settings"
  >("schedule");
  const [currentSchedule, setCurrentSchedule] = useState<StudySchedule | null>(
    null
  );
  const [reminders, setReminders] = useState<StudyReminder[]>([]);
  const [sessions, setSessions] = useState<StudySession[]>([]);
  const [isCreatingSchedule, setIsCreatingSchedule] = useState(false);
  const [selectedDay, setSelectedDay] =
    useState<keyof WeeklySchedule>("monday");

  // Load user's study schedule
  useEffect(() => {
    const loadSchedule = async () => {
      try {
        const response = await fetch(`/api/study-schedule/${courseId}?userId=${userId}`);
        if (response.ok) {
          const data = await response.json();
          setCurrentSchedule(data.schedule);
          setReminders(data.reminders || []);
        }
      } catch (error) {
        console.error('Failed to load study schedule:', error);
        // Set empty schedule if loading fails
        setCurrentSchedule(null);
        setReminders([]);
      }
    };

    if (userId && courseId) {
      loadSchedule();
    }
  }, [userId, courseId]);

  const getDayName = (day: keyof WeeklySchedule) => {
    const dayNames = {
      monday: "الإثنين",
      tuesday: "الثلاثاء",
      wednesday: "الأربعاء",
      thursday: "الخميس",
      friday: "الجمعة",
      saturday: "السبت",
      sunday: "الأحد",
    };
    return dayNames[day];
  };

  const getTypeIcon = (type: TimeSlot["type"]) => {
    switch (type) {
      case "focus":
        return Brain;
      case "review":
        return BookOpen;
      case "practice":
        return Play;
      case "break":
        return Coffee;
      default:
        return Clock;
    }
  };

  const getTypeColor = (type: TimeSlot["type"]) => {
    switch (type) {
      case "focus":
        return "text-blue-600 bg-blue-100";
      case "review":
        return "text-green-600 bg-green-100";
      case "practice":
        return "text-purple-600 bg-purple-100";
      case "break":
        return "text-orange-600 bg-orange-100";
      default:
        return "text-neutral-600 bg-neutral-100";
    }
  };

  const getPriorityColor = (priority: "high" | "medium" | "low") => {
    switch (priority) {
      case "high":
        return "border-red-200 bg-red-50";
      case "medium":
        return "border-yellow-200 bg-yellow-50";
      case "low":
        return "border-green-200 bg-green-50";
      default:
        return "border-neutral-200 bg-neutral-50";
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <FadeInScroll>
        <Card className="overflow-hidden border-0 shadow-elevation-2">
          <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-6 text-black">
            <div className="flex items-center justify-between">
              <div>
                <h2 className="text-2xl font-bold mb-2 font-display leading-arabic-tight">
                  مخطط الدراسة الذكي
                </h2>
                <p className="text-black/90 font-primary">
                  نظم وقتك وحقق أهدافك التعليمية بكفاءة
                </p>
              </div>
              <div className="text-center">
                <div className="w-16 h-16 bg-white/20 rounded-full flex items-center justify-center mb-2">
                  <Calendar className="w-8 h-8" />
                </div>
                <p className="text-sm text-black/80 font-primary">
                  {currentSchedule?.active ? "نشط" : "غير نشط"}
                </p>
              </div>
            </div>
          </div>
        </Card>
      </FadeInScroll>

      {/* Navigation Tabs */}
      <div className="flex items-center gap-2 overflow-x-auto pb-2">
        {[
          { id: "schedule", label: "الجدول الأسبوعي", icon: Calendar },
          { id: "reminders", label: "التذكيرات", icon: Bell },
          { id: "analytics", label: "التحليلات", icon: BarChart3 },
          { id: "settings", label: "الإعدادات", icon: Settings },
        ].map((tab) => (
          <Button
            key={tab.id}
            variant={activeTab === tab.id ? "primary" : "outline"}
            size="sm"
            onClick={() => setActiveTab(tab.id as any)}
            className="flex items-center gap-2 whitespace-nowrap"
          >
            <tab.icon className="w-4 h-4" />
            {tab.label}
          </Button>
        ))}
      </div>

      {/* Tab Content */}
      <AnimatePresence mode="wait">
        {activeTab === "schedule" && currentSchedule && (
          <motion.div
            key="schedule"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            className="space-y-6"
          >
            {/* Weekly Overview */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between font-display">
                  <div className="flex items-center gap-2">
                    <Calendar className="w-5 h-5 text-primary-600" />
                    الجدول الأسبوعي
                  </div>
                  <div className="flex items-center gap-2">
                    <Badge variant="secondary">
                      {
                        Object.values(currentSchedule.weeklySchedule).filter(
                          (d) => d.enabled
                        ).length
                      }{" "}
                      أيام نشطة
                    </Badge>
                    <Button size="sm" variant="outline">
                      <Edit className="w-4 h-4 ml-2" />
                      تعديل
                    </Button>
                  </div>
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-7 gap-2 mb-6">
                  {Object.entries(currentSchedule.weeklySchedule).map(
                    ([day, schedule]) => (
                      <motion.button
                        key={day}
                        className={cn(
                          "p-3 rounded-lg border-2 text-center transition-all duration-200",
                          selectedDay === day
                            ? "border-primary-500 bg-primary-50"
                            : schedule.enabled
                            ? "border-neutral-200 bg-white hover:border-primary-200"
                            : "border-neutral-200 bg-neutral-50 opacity-50"
                        )}
                        onClick={() =>
                          setSelectedDay(day as keyof WeeklySchedule)
                        }
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                      >
                        <div className="text-sm font-semibold font-display mb-1">
                          {getDayName(day as keyof WeeklySchedule)}
                        </div>
                        <div className="text-xs text-neutral-600 font-primary">
                          {schedule.restDay
                            ? "راحة"
                            : `${schedule.goalMinutes} دقيقة`}
                        </div>
                        {schedule.enabled && !schedule.restDay && (
                          <div className="w-2 h-2 bg-primary-500 rounded-full mx-auto mt-1" />
                        )}
                      </motion.button>
                    )
                  )}
                </div>

                {/* Selected Day Details */}
                <Card className="p-4 bg-neutral-50">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="font-semibold font-display">
                      تفاصيل {getDayName(selectedDay)}
                    </h3>
                    <div className="flex items-center gap-2">
                      <Switch
                        checked={
                          currentSchedule.weeklySchedule[selectedDay].enabled
                        }
                        onCheckedChange={(checked) => {
                          // Update schedule logic here
                        }}
                      />
                      <Button size="sm" variant="outline">
                        <Plus className="w-4 h-4 ml-2" />
                        إضافة جلسة
                      </Button>
                    </div>
                  </div>

                  {currentSchedule.weeklySchedule[selectedDay].restDay ? (
                    <div className="text-center py-8">
                      <Moon className="w-12 h-12 text-neutral-400 mx-auto mb-3" />
                      <h4 className="font-semibold text-neutral-900 font-display mb-1">
                        يوم راحة
                      </h4>
                      <p className="text-sm text-neutral-600 font-primary">
                        خذ استراحة واستعد لأسبوع جديد من التعلم
                      </p>
                    </div>
                  ) : (
                    <div className="space-y-3">
                      {currentSchedule.preferredTimes.map((timeSlot) => {
                        const TypeIcon = getTypeIcon(timeSlot.type);
                        return (
                          <div
                            key={timeSlot.id}
                            className={cn(
                              "flex items-center gap-3 p-3 rounded-lg border",
                              getPriorityColor(timeSlot.priority)
                            )}
                          >
                            <div
                              className={cn(
                                "w-10 h-10 rounded-full flex items-center justify-center",
                                getTypeColor(timeSlot.type)
                              )}
                            >
                              <TypeIcon className="w-5 h-5" />
                            </div>
                            <div className="flex-1">
                              <div className="flex items-center gap-2 mb-1">
                                <span className="font-semibold font-display">
                                  {timeSlot.startTime} - {timeSlot.endTime}
                                </span>
                                <Badge variant="secondary" className="text-xs">
                                  {timeSlot.type === "focus"
                                    ? "تركيز"
                                    : timeSlot.type === "review"
                                    ? "مراجعة"
                                    : timeSlot.type === "practice"
                                    ? "تطبيق"
                                    : "استراحة"}
                                </Badge>
                                <Badge
                                  variant={
                                    timeSlot.priority === "high"
                                      ? "destructive"
                                      : "secondary"
                                  }
                                  className="text-xs"
                                >
                                  {timeSlot.priority === "high"
                                    ? "عالي"
                                    : timeSlot.priority === "medium"
                                    ? "متوسط"
                                    : "منخفض"}
                                </Badge>
                              </div>
                              <p className="text-sm text-neutral-600 font-primary">
                                مدة الجلسة:{" "}
                                {Math.round(
                                  (new Date(
                                    `2000-01-01T${timeSlot.endTime}`
                                  ).getTime() -
                                    new Date(
                                      `2000-01-01T${timeSlot.startTime}`
                                    ).getTime()) /
                                    60000
                                )}{" "}
                                دقيقة
                              </p>
                            </div>
                            <div className="flex items-center gap-2">
                              <Button size="sm" variant="ghost">
                                <Edit className="w-4 h-4" />
                              </Button>
                              <Button size="sm" variant="ghost">
                                <Trash2 className="w-4 h-4" />
                              </Button>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </Card>
              </CardContent>
            </Card>

            {/* Quick Stats */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
              <Card>
                <CardContent className="p-4 text-center">
                  <Target className="w-8 h-8 text-blue-600 mx-auto mb-2" />
                  <div className="text-2xl font-bold text-blue-600 font-display">
                    {currentSchedule.dailyGoalMinutes}
                  </div>
                  <p className="text-sm text-neutral-600 font-primary">
                    دقيقة يومياً
                  </p>
                </CardContent>
              </Card>

              <Card>
                <CardContent className="p-4 text-center">
                  <Calendar className="w-8 h-8 text-green-600 mx-auto mb-2" />
                  <div className="text-2xl font-bold text-green-600 font-display">
                    {
                      Object.values(currentSchedule.weeklySchedule).filter(
                        (d) => d.enabled
                      ).length
                    }
                  </div>
                  <p className="text-sm text-neutral-600 font-primary">
                    أيام نشطة
                  </p>
                </CardContent>
              </Card>

              <Card>
                <CardContent className="p-4 text-center">
                  <Clock className="w-8 h-8 text-purple-600 mx-auto mb-2" />
                  <div className="text-2xl font-bold text-purple-600 font-display">
                    {Object.values(currentSchedule.weeklySchedule).reduce(
                      (sum, day) => sum + day.goalMinutes,
                      0
                    )}
                  </div>
                  <p className="text-sm text-neutral-600 font-primary">
                    دقيقة أسبوعياً
                  </p>
                </CardContent>
              </Card>

              <Card>
                <CardContent className="p-4 text-center">
                  <Bell className="w-8 h-8 text-orange-600 mx-auto mb-2" />
                  <div className="text-2xl font-bold text-orange-600 font-display">
                    {reminders.filter((r) => !r.completed).length}
                  </div>
                  <p className="text-sm text-neutral-600 font-primary">
                    تذكير نشط
                  </p>
                </CardContent>
              </Card>
            </div>
          </motion.div>
        )}

        {activeTab === "reminders" && (
          <motion.div
            key="reminders"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            className="space-y-6"
          >
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between font-display">
                  <div className="flex items-center gap-2">
                    <Bell className="w-5 h-5 text-primary-600" />
                    التذكيرات النشطة (
                    {reminders.filter((r) => !r.completed).length})
                  </div>
                  <Button size="sm">
                    <Plus className="w-4 h-4 ml-2" />
                    تذكير جديد
                  </Button>
                </CardTitle>
              </CardHeader>
              <CardContent>
                <StaggerChildren className="space-y-4">
                  {reminders.map((reminder) => (
                    <StaggerItem key={reminder.id}>
                      <Card
                        className={cn(
                          "p-4",
                          getPriorityColor(reminder.priority)
                        )}
                      >
                        <div className="flex items-start gap-3">
                          <div
                            className={cn(
                              "w-10 h-10 rounded-full flex items-center justify-center",
                              reminder.completed
                                ? "bg-success text-black"
                                : "bg-white"
                            )}
                          >
                            {reminder.completed ? (
                              <CheckCircle className="w-5 h-5" />
                            ) : reminder.type === "study" ? (
                              <BookOpen className="w-5 h-5 text-blue-600" />
                            ) : reminder.type === "break" ? (
                              <Coffee className="w-5 h-5 text-orange-600" />
                            ) : (
                              <Bell className="w-5 h-5 text-neutral-600" />
                            )}
                          </div>
                          <div className="flex-1">
                            <div className="flex items-center justify-between mb-2">
                              <h4 className="font-semibold font-display leading-arabic-tight">
                                {reminder.title}
                              </h4>
                              <div className="flex items-center gap-2">
                                <Badge variant="secondary" className="text-xs">
                                  {new Date(
                                    reminder.scheduledTime
                                  ).toLocaleTimeString("ar-EG", {
                                    hour: "2-digit",
                                    minute: "2-digit",
                                  })}
                                </Badge>
                                {reminder.recurring && (
                                  <Badge variant="outline" className="text-xs">
                                    متكرر
                                  </Badge>
                                )}
                              </div>
                            </div>
                            <p className="text-sm text-neutral-700 leading-arabic-relaxed font-primary mb-3">
                              {reminder.message}
                            </p>
                            <div className="flex items-center gap-2">
                              {!reminder.completed && (
                                <>
                                  <Button size="sm" variant="outline">
                                    <CheckCircle className="w-4 h-4 ml-2" />
                                    تم
                                  </Button>
                                  <Button size="sm" variant="outline">
                                    <Clock className="w-4 h-4 ml-2" />
                                    تأجيل
                                  </Button>
                                </>
                              )}
                              <Button size="sm" variant="ghost">
                                <Edit className="w-4 h-4" />
                              </Button>
                            </div>
                          </div>
                        </div>
                      </Card>
                    </StaggerItem>
                  ))}
                </StaggerChildren>
              </CardContent>
            </Card>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


#26: ./src/components/payment/PaymentResult.tsx
--------------------------------------------------------------------------------
// src/components/payment/PaymentResult.tsx - Payment Result with Celebrations
"use client";

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Course } from "@/lib/api/courses";
import { 
  CheckCircle, 
  XCircle, 
  AlertTriangle,
  Download,
  Share2,
  Play,
  RefreshCw,
  ArrowRight,
  Gift,
  Star,
  Trophy,
  Sparkles,
  Heart,
  Facebook,
  Twitter,
  Linkedin,
  Copy,
  Mail,
  MessageSquare
} from "lucide-react";
import { cn } from "@/lib/utils";

interface PaymentResultProps {
  type: 'success' | 'failure' | 'pending';
  course: Course;
  paymentId?: string;
  transactionId?: string;
  amount?: number;
  currency?: string;
  error?: string;
  onRetry?: () => void;
  onGoToCourse?: () => void;
  onDownloadReceipt?: () => void;
}

// Confetti component
const Confetti = () => {
  const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3'];
  
  return (
    <div className="fixed inset-0 pointer-events-none z-50">
      {Array.from({ length: 50 }).map((_, i) => (
        <motion.div
          key={i}
          className="absolute w-2 h-2 rounded-full"
          style={{
            backgroundColor: colors[Math.floor(Math.random() * colors.length)],
            left: `${Math.random() * 100}%`,
            top: '-10px'
          }}
          initial={{ y: -10, rotate: 0 }}
          animate={{ 
            y: window.innerHeight + 10, 
            rotate: 360,
            x: Math.random() * 200 - 100
          }}
          transition={{ 
            duration: Math.random() * 3 + 2,
            ease: "easeOut",
            delay: Math.random() * 2
          }}
        />
      ))}
    </div>
  );
};

export function PaymentResult({
  type,
  course,
  paymentId,
  transactionId,
  amount,
  currency = 'EGP',
  error,
  onRetry,
  onGoToCourse,
  onDownloadReceipt
}: PaymentResultProps) {
  const [showConfetti, setShowConfetti] = useState(false);
  const [showShareModal, setShowShareModal] = useState(false);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    if (type === 'success') {
      setShowConfetti(true);
      const timer = setTimeout(() => setShowConfetti(false), 5000);
      return () => clearTimeout(timer);
    }
  }, [type]);

  const formatAmount = () => {
    if (!amount) return '';
    return new Intl.NumberFormat('ar-EG', {
      style: 'currency',
      currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }).format(amount);
  };

  const handleShare = (platform: string) => {
    const shareText = `🎉 لقد أكملت دورة "${course.title}" بنجاح! انضم إلي في رحلة التعلم.`;
    const shareUrl = `${window.location.origin}/courses/${course.id}`;
    
    switch (platform) {
      case 'facebook':
        window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}&quote=${encodeURIComponent(shareText)}`);
        break;
      case 'twitter':
        window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`);
        break;
      case 'linkedin':
        window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(shareUrl)}`);
        break;
      case 'copy':
        navigator.clipboard.writeText(`${shareText} ${shareUrl}`);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
        break;
    }
    setShowShareModal(false);
  };

  if (type === 'success') {
    return (
      <>
        {showConfetti && <Confetti />}
        
        <div className="min-h-screen bg-gradient-to-br from-green-50 via-white to-blue-50 flex items-center justify-center p-4">
          <motion.div
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            transition={{ type: "spring", stiffness: 300, damping: 25 }}
            className="w-full max-w-2xl"
          >
            <Card className="border-0 shadow-2xl overflow-hidden">
              {/* Success Header */}
              <div className="bg-gradient-to-r from-green-500 to-emerald-600 p-8 text-black text-center relative">
                <motion.div
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  transition={{ delay: 0.2, type: "spring", stiffness: 400 }}
                  className="w-20 h-20 bg-white/20 rounded-full flex items-center justify-center mx-auto mb-4 backdrop-blur-sm"
                >
                  <CheckCircle className="w-12 h-12" />
                </motion.div>
                
                <motion.h1
                  initial={{ y: 20, opacity: 0 }}
                  animate={{ y: 0, opacity: 1 }}
                  transition={{ delay: 0.3 }}
                  className="text-3xl font-bold font-display mb-2"
                >
                  🎉 تم الدفع بنجاح!
                </motion.h1>
                
                <motion.p
                  initial={{ y: 20, opacity: 0 }}
                  animate={{ y: 0, opacity: 1 }}
                  transition={{ delay: 0.4 }}
                  className="text-black/90 text-lg font-primary"
                >
                  مرحباً بك في رحلة التعلم الجديدة
                </motion.p>

                {/* Floating Elements */}
                <motion.div
                  className="absolute top-4 right-4"
                  animate={{ rotate: 360, scale: [1, 1.2, 1] }}
                  transition={{ duration: 3, repeat: Infinity }}
                >
                  <Sparkles className="w-6 h-6 text-yellow-300" />
                </motion.div>
                <motion.div
                  className="absolute bottom-4 left-4"
                  animate={{ rotate: -360, scale: [1, 1.1, 1] }}
                  transition={{ duration: 4, repeat: Infinity }}
                >
                  <Trophy className="w-6 h-6 text-yellow-300" />
                </motion.div>
              </div>

              <CardContent className="p-8 space-y-6">
                {/* Course Info */}
                <motion.div
                  initial={{ y: 30, opacity: 0 }}
                  animate={{ y: 0, opacity: 1 }}
                  transition={{ delay: 0.5 }}
                  className="text-center"
                >
                  <div className="w-24 h-24 mx-auto mb-4 rounded-lg overflow-hidden shadow-lg">
                    <img 
                      src={course.thumbnailUrl} 
                      alt={course.title}
                      className="w-full h-full object-cover"
                      onError={(e) => {
                        (e.target as HTMLImageElement).src = '/placeholder-course.jpg';
                      }}
                    />
                  </div>
                  <h2 className="text-xl font-bold font-display mb-2">{course.title}</h2>
                  <p className="text-neutral-600 font-primary">
                    بواسطة {course.professor.name}
                  </p>
                </motion.div>

                {/* Payment Details */}
                <motion.div
                  initial={{ y: 30, opacity: 0 }}
                  animate={{ y: 0, opacity: 1 }}
                  transition={{ delay: 0.6 }}
                  className="bg-neutral-50 rounded-lg p-4 space-y-2"
                >
                  <div className="flex justify-between items-center">
                    <span className="text-neutral-600 font-primary">المبلغ المدفوع:</span>
                    <span className="font-bold text-green-600 font-display">{formatAmount()}</span>
                  </div>
                  {transactionId && (
                    <div className="flex justify-between items-center">
                      <span className="text-neutral-600 font-primary">رقم العملية:</span>
                      <span className="font-mono text-sm">{transactionId}</span>
                    </div>
                  )}
                  <div className="flex justify-between items-center">
                    <span className="text-neutral-600 font-primary">تاريخ الدفع:</span>
                    <span className="font-primary">{new Date().toLocaleDateString('ar-EG')}</span>
                  </div>
                </motion.div>

                {/* What's Next */}
                <motion.div
                  initial={{ y: 30, opacity: 0 }}
                  animate={{ y: 0, opacity: 1 }}
                  transition={{ delay: 0.7 }}
                  className="bg-blue-50 rounded-lg p-4"
                >
                  <h3 className="font-semibold text-blue-800 font-display mb-3 flex items-center gap-2">
                    <Gift className="w-5 h-5" />
                    ما ستحصل عليه الآن:
                  </h3>
                  <div className="space-y-2">
                    {[
                      'وصول فوري لجميع دروس الدورة',
                      'مواد تعليمية قابلة للتحميل',
                      'شهادة إتمام معتمدة',
                      'دعم فني مباشر'
                    ].map((item, index) => (
                      <motion.div
                        key={index}
                        initial={{ x: -20, opacity: 0 }}
                        animate={{ x: 0, opacity: 1 }}
                        transition={{ delay: 0.8 + index * 0.1 }}
                        className="flex items-center gap-2 text-blue-700"
                      >
                        <CheckCircle className="w-4 h-4" />
                        <span className="text-sm font-primary">{item}</span>
                      </motion.div>
                    ))}
                  </div>
                </motion.div>

                {/* Action Buttons */}
                <motion.div
                  initial={{ y: 30, opacity: 0 }}
                  animate={{ y: 0, opacity: 1 }}
                  transition={{ delay: 0.9 }}
                  className="flex flex-col sm:flex-row gap-3"
                >
                  <Button 
                    onClick={onGoToCourse}
                    className="flex-1 h-12 text-lg font-semibold"
                    size="lg"
                  >
                    <Play className="w-5 h-5 ml-2" />
                    ابدأ التعلم الآن
                  </Button>
                  
                  <Button 
                    variant="outline"
                    onClick={onDownloadReceipt}
                    className="h-12"
                  >
                    <Download className="w-5 h-5 ml-2" />
                    تحميل الإيصال
                  </Button>
                  
                  <Button 
                    variant="outline"
                    onClick={() => setShowShareModal(true)}
                    className="h-12"
                  >
                    <Share2 className="w-5 h-5 ml-2" />
                    مشاركة
                  </Button>
                </motion.div>

                {/* Motivational Message */}
                <motion.div
                  initial={{ y: 30, opacity: 0 }}
                  animate={{ y: 0, opacity: 1 }}
                  transition={{ delay: 1 }}
                  className="text-center p-4 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg"
                >
                  <div className="flex items-center justify-center gap-2 mb-2">
                    <Heart className="w-5 h-5 text-pink-500" />
                    <Star className="w-5 h-5 text-yellow-500" />
                    <Heart className="w-5 h-5 text-pink-500" />
                  </div>
                  <p className="text-neutral-700 font-primary">
                    "                    &ldquo;كل خطوة في التعلم هي استثمار في مستقبلك. أحسنت الاختيار!&rdquo;"
                  </p>
                </motion.div>
              </CardContent>
            </Card>
          </motion.div>
        </div>

        {/* Share Modal */}
        <AnimatePresence>
          {showShareModal && (
            <motion.div
              className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              onClick={() => setShowShareModal(false)}
            >
              <motion.div
                className="bg-white rounded-2xl p-6 max-w-md w-full mx-4"
                initial={{ scale: 0.5, y: 50 }}
                animate={{ scale: 1, y: 0 }}
                exit={{ scale: 0.5, y: 50 }}
                onClick={(e) => e.stopPropagation()}
              >
                <div className="text-center mb-6">
                  <div className="w-16 h-16 bg-gradient-to-r from-blue-500 to-purple-600 rounded-full flex items-center justify-center mx-auto mb-4">
                    <Share2 className="w-8 h-8 text-black" />
                  </div>
                  <h3 className="text-xl font-bold text-neutral-900 font-display mb-2">
                    شارك إنجازك
                  </h3>
                  <p className="text-neutral-600 font-primary">
                    أخبر أصدقاءك عن رحلتك التعليمية الجديدة
                  </p>
                </div>

                <div className="grid grid-cols-2 gap-3 mb-6">
                  {[
                    { id: 'facebook', name: 'Facebook', icon: Facebook, color: 'bg-blue-600' },
                    { id: 'twitter', name: 'Twitter', icon: Twitter, color: 'bg-sky-500' },
                    { id: 'linkedin', name: 'LinkedIn', icon: Linkedin, color: 'bg-blue-700' },
                    { id: 'copy', name: 'نسخ الرابط', icon: Copy, color: 'bg-neutral-600' }
                  ].map((platform) => (
                    <Button
                      key={platform.id}
                      variant="outline"
                      onClick={() => handleShare(platform.id)}
                      className="flex items-center gap-2 p-4 h-auto"
                    >
                      <div className={cn("w-8 h-8 rounded-full flex items-center justify-center", platform.color)}>
                        <platform.icon className="w-4 h-4 text-black" />
                      </div>
                      <span className="font-primary">{platform.name}</span>
                    </Button>
                  ))}
                </div>

                {copied && (
                  <motion.div
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="text-center text-green-600 text-sm font-primary mb-4"
                  >
                    ✓ تم نسخ الرابط بنجاح
                  </motion.div>
                )}

                <Button
                  variant="ghost"
                  onClick={() => setShowShareModal(false)}
                  className="w-full"
                >
                  إغلاق
                </Button>
              </motion.div>
            </motion.div>
          )}
        </AnimatePresence>
      </>
    );
  }

  if (type === 'failure') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-red-50 via-white to-orange-50 flex items-center justify-center p-4">
        <motion.div
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ type: "spring", stiffness: 300, damping: 25 }}
          className="w-full max-w-2xl"
        >
          <Card className="border-0 shadow-2xl overflow-hidden">
            {/* Error Header */}
            <div className="bg-gradient-to-r from-red-500 to-pink-600 p-8 text-black text-center">
              <motion.div
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                transition={{ delay: 0.2, type: "spring", stiffness: 400 }}
                className="w-20 h-20 bg-white/20 rounded-full flex items-center justify-center mx-auto mb-4 backdrop-blur-sm"
              >
                <XCircle className="w-12 h-12" />
              </motion.div>
              
              <h1 className="text-3xl font-bold font-display mb-2">
                فشل في عملية الدفع
              </h1>
              <p className="text-black/90 text-lg font-primary">
                لم نتمكن من إتمام عملية الدفع
              </p>
            </div>

            <CardContent className="p-8 space-y-6">
              {/* Error Details */}
              <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                <div className="flex items-start gap-3">
                  <AlertTriangle className="w-5 h-5 text-red-600 mt-0.5" />
                  <div>
                    <h3 className="font-semibold text-red-800 font-display mb-1">
                      سبب الفشل:
                    </h3>
                    <p className="text-red-700 font-primary">
                      {error || 'حدث خطأ غير متوقع أثناء معالجة عملية الدفع'}
                    </p>
                  </div>
                </div>
              </div>

              {/* Course Info */}
              <div className="text-center">
                <div className="w-24 h-24 mx-auto mb-4 rounded-lg overflow-hidden shadow-lg opacity-75">
                  <img 
                    src={course.thumbnailUrl} 
                    alt={course.title}
                    className="w-full h-full object-cover"
                    onError={(e) => {
                      (e.target as HTMLImageElement).src = '/placeholder-course.jpg';
                    }}
                  />
                </div>
                <h2 className="text-xl font-bold font-display mb-2">{course.title}</h2>
                <p className="text-neutral-600 font-primary">
                  بواسطة {course.professor.name}
                </p>
              </div>

              {/* What to do next */}
              <div className="bg-blue-50 rounded-lg p-4">
                <h3 className="font-semibold text-blue-800 font-display mb-3">
                  ماذا يمكنك فعله الآن:
                </h3>
                <div className="space-y-2">
                  {[
                    'تحقق من بيانات البطاقة وحاول مرة أخرى',
                    'تأكد من وجود رصيد كافي في البطاقة',
                    'جرب طريقة دفع أخرى',
                    'تواصل مع البنك إذا استمرت المشكلة'
                  ].map((item, index) => (
                    <div key={index} className="flex items-center gap-2 text-blue-700">
                      <div className="w-2 h-2 bg-blue-500 rounded-full" />
                      <span className="text-sm font-primary">{item}</span>
                    </div>
                  ))}
                </div>
              </div>

              {/* Action Buttons */}
              <div className="flex flex-col sm:flex-row gap-3">
                <Button 
                  onClick={onRetry}
                  className="flex-1 h-12 text-lg font-semibold"
                  size="lg"
                >
                  <RefreshCw className="w-5 h-5 ml-2" />
                  حاول مرة أخرى
                </Button>
                
                <Button 
                  variant="outline"
                  onClick={() => window.history.back()}
                  className="h-12"
                >
                  <ArrowRight className="w-5 h-5 ml-2" />
                  العودة للدورة
                </Button>
              </div>

              {/* Support */}
              <div className="text-center p-4 bg-neutral-50 rounded-lg">
                <p className="text-neutral-600 font-primary mb-2">
                  تحتاج مساعدة؟ فريق الدعم جاهز لمساعدتك
                </p>
                <Button variant="outline" size="sm">
                  <MessageSquare className="w-4 h-4 ml-2" />
                  تواصل مع الدعم
                </Button>
              </div>
            </CardContent>
          </Card>
        </motion.div>
      </div>
    );
  }

  // Pending state
  return (
    <div className="min-h-screen bg-gradient-to-br from-yellow-50 via-white to-orange-50 flex items-center justify-center p-4">
      <motion.div
        initial={{ scale: 0.8, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ type: "spring", stiffness: 300, damping: 25 }}
        className="w-full max-w-2xl"
      >
        <Card className="border-0 shadow-2xl overflow-hidden">
          <div className="bg-gradient-to-r from-yellow-500 to-orange-600 p-8 text-black text-center">
            <motion.div
              className="w-20 h-20 bg-white/20 rounded-full flex items-center justify-center mx-auto mb-4 backdrop-blur-sm"
              animate={{ rotate: 360 }}
              transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
            >
              <RefreshCw className="w-12 h-12" />
            </motion.div>
            
            <h1 className="text-3xl font-bold font-display mb-2">
              جاري معالجة الدفع
            </h1>
            <p className="text-black/90 text-lg font-primary">
              يرجى الانتظار بينما نتحقق من عملية الدفع
            </p>
          </div>

          <CardContent className="p-8 text-center">
            <div className="space-y-4">
              <div className="flex items-center justify-center gap-2">
                <div className="w-2 h-2 bg-yellow-500 rounded-full animate-bounce" />
                <div className="w-2 h-2 bg-yellow-500 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }} />
                <div className="w-2 h-2 bg-yellow-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }} />
              </div>
              <p className="text-neutral-600 font-primary">
                لا تغلق هذه الصفحة حتى اكتمال العملية
              </p>
            </div>
          </CardContent>
        </Card>
      </motion.div>
    </div>
  );
}

#27: ./src/components/professor/LessonEditor.tsx
--------------------------------------------------------------------------------
// src/components/professor/LessonEditor.tsx
"use client";

import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { MaterialManager } from '@/components/course/MaterialManager';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Save, Video, FileText, Settings } from 'lucide-react';
import { toast } from 'sonner';
import { Lesson } from '@prisma/client';

interface LessonEditorProps {
  lesson: Lesson;
  onUpdate: (updatedLesson: Partial<Lesson>) => void;
  onSave: () => void;
}

export function LessonEditor({ lesson, onUpdate, onSave }: LessonEditorProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [localLesson, setLocalLesson] = useState(lesson);

  const handleFieldChange = (field: keyof Lesson, value: any) => {
    const updated = { ...localLesson, [field]: value };
    setLocalLesson(updated);
    onUpdate({ [field]: value });
  };

  const handleSave = async () => {
    setIsLoading(true);
    try {
      await onSave();
      toast.success('تم حفظ التغييرات بنجاح');
    } catch (error) {
      toast.error('حدث خطأ في حفظ التغييرات');
    } finally {
      setIsLoading(false);
    }
  };

  const handleMaterialsUpdate = async (materials: any[]) => {
    try {
      const response = await fetch(`/api/lessons/${lesson.id}/materials`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ materials }),
      });

      if (!response.ok) {
        throw new Error('Failed to update materials');
      }

      const updatedLesson = { ...localLesson, materials };
      setLocalLesson(updatedLesson);
      onUpdate({ materials });
      
    } catch (error) {
      console.error('Error updating materials:', error);
      toast.error('حدث خطأ في تحديث المواد');
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">تحرير الدرس: {lesson.title}</h2>
        <Button onClick={handleSave} disabled={isLoading}>
          <Save className="w-4 h-4 mr-2" />
          {isLoading ? 'جاري الحفظ...' : 'حفظ التغييرات'}
        </Button>
      </div>

      <Tabs defaultValue="basic" className="w-full">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="basic">
            <Settings className="w-4 h-4 mr-2" />
            الإعدادات الأساسية
          </TabsTrigger>
          <TabsTrigger value="video">
            <Video className="w-4 h-4 mr-2" />
            إعدادات الفيديو
          </TabsTrigger>
          <TabsTrigger value="materials">
            <FileText className="w-4 h-4 mr-2" />
            المواد التعليمية
          </TabsTrigger>
        </TabsList>

        {/* Basic Settings */}
        <TabsContent value="basic">
          <Card>
            <CardHeader>
              <CardTitle>الإعدادات الأساسية</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <Label htmlFor="title">عنوان الدرس</Label>
                <Input
                  id="title"
                  value={localLesson.title}
                  onChange={(e) => handleFieldChange('title', e.target.value)}
                  placeholder="أدخل عنوان الدرس"
                />
              </div>

              <div>
                <Label htmlFor="order">ترتيب الدرس</Label>
                <Input
                  id="order"
                  type="number"
                  value={localLesson.order}
                  onChange={(e) => handleFieldChange('order', parseInt(e.target.value))}
                  placeholder="ترتيب الدرس في الدورة"
                />
              </div>

              <div>
                <Label htmlFor="duration">مدة الدرس (بالثواني)</Label>
                <Input
                  id="duration"
                  type="number"
                  value={localLesson.duration || ''}
                  onChange={(e) => handleFieldChange('duration', e.target.value ? parseInt(e.target.value) : null)}
                  placeholder="مدة الفيديو بالثواني"
                />
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        {/* Video Settings */}
        <TabsContent value="video">
          <Card>
            <CardHeader>
              <CardTitle>إعدادات الفيديو</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <Label htmlFor="bunnyVideoId">معرف فيديو Bunny.net</Label>
                <Input
                  id="bunnyVideoId"
                  value={localLesson.bunnyVideoId}
                  onChange={(e) => handleFieldChange('bunnyVideoId', e.target.value)}
                  placeholder="معرف الفيديو من Bunny.net"
                />
                <p className="text-sm text-muted-foreground mt-1">
                  يمكنك العثور على معرف الفيديو في لوحة تحكم Bunny.net
                </p>
              </div>

              {/* Video Preview */}
              {localLesson.bunnyVideoId && (
                <div>
                  <Label>معاينة الفيديو</Label>
                  <div className="mt-2 p-4 border rounded-lg bg-muted/50">
                    <p className="text-sm text-muted-foreground">
                      معرف الفيديو: {localLesson.bunnyVideoId}
                    </p>
                    <p className="text-sm text-muted-foreground">
                      المدة: {localLesson.duration ? `${Math.floor(localLesson.duration / 60)}:${(localLesson.duration % 60).toString().padStart(2, '0')}` : 'غير محدد'}
                    </p>
                  </div>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        {/* Materials */}
        <TabsContent value="materials">
          <MaterialManager
            lessonId={lesson.id}
            materials={localLesson.materials}
            onUpdate={handleMaterialsUpdate}
            canEdit={true}
          />
        </TabsContent>
      </Tabs>
    </div>
  );
}

#28: ./src/components/professor/ProfessorCourseManagement.tsx
--------------------------------------------------------------------------------
// src/components/professor/ProfessorCourseManagement.tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { 
  DropdownMenu, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuTrigger,
  DropdownMenuSeparator
} from "@/components/ui/dropdown-menu";
import { 
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { 
  Search, 
  MoreHorizontal, 
  Edit, 
  Trash2, 
  Eye, 
  EyeOff,
  BookOpen,
  Users,
  Clock,
  Calendar,
  DollarSign,
  Plus,
  Settings
} from "lucide-react";
import { deleteCourse } from "@/lib/actions";
import { toast } from "sonner";
import Link from "next/link";

interface Course {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  price: any; // Decimal type from Prisma
  currency: string;
  isPublished: boolean;
  createdAt: string;
  category: {
    id: string;
    name: string;
    slug: string;
  };
  _count: {
    enrollments: number;
    lessons: number;
  };
}

interface ProfessorCourseManagementProps {
  courses: Course[];
}

export function ProfessorCourseManagement({ courses: initialCourses }: ProfessorCourseManagementProps) {
  const [courses, setCourses] = useState(initialCourses);
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState<"all" | "published" | "draft">("all");
  const [sortBy, setSortBy] = useState<"title" | "enrollments" | "lessons" | "created">("created");

  // Filter and sort courses
  const filteredCourses = courses
    .filter(course => {
      const matchesSearch = course.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                           course.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
                           course.category.name.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesStatus = statusFilter === "all" || 
                           (statusFilter === "published" && course.isPublished) ||
                           (statusFilter === "draft" && !course.isPublished);
      return matchesSearch && matchesStatus;
    })
    .sort((a, b) => {
      switch (sortBy) {
        case "title":
          return a.title.localeCompare(b.title, 'ar');
        case "enrollments":
          return b._count.enrollments - a._count.enrollments;
        case "lessons":
          return b._count.lessons - a._count.lessons;
        case "created":
        default:
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      }
    });

  const handleDelete = async (courseId: string) => {
    try {
      const result = await deleteCourse(courseId);
      if (result.success) {
        setCourses(prev => prev.filter(course => course.id !== courseId));
        toast.success(result.success);
      } else {
        toast.error(result.error || "فشل في حذف الدورة");
      }
    } catch (error) {
      toast.error("حدث خطأ أثناء حذف الدورة");
    }
  };

  const formatPrice = (course: Course): string => {
    if (!course.price || course.price === 0) {
      return 'مجاني';
    }
    
    return new Intl.NumberFormat('ar-EG', {
      style: 'currency',
      currency: course.currency || 'EGP',
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }).format(Number(course.price));
  };

  return (
    <div className="space-y-4">
      {/* Filters and Search */}
      <div className="flex flex-col sm:flex-row gap-4">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-muted-foreground" />
          <Input
            placeholder="البحث في الدورات..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="pl-10"
          />
        </div>
        
        <Select value={statusFilter} onValueChange={(value: any) => setStatusFilter(value)}>
          <SelectTrigger className="w-[150px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">جميع الدورات</SelectItem>
            <SelectItem value="published">المنشورة فقط</SelectItem>
            <SelectItem value="draft">المسودات فقط</SelectItem>
          </SelectContent>
        </Select>

        <Select value={sortBy} onValueChange={(value: any) => setSortBy(value)}>
          <SelectTrigger className="w-[150px]">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="created">الأحدث</SelectItem>
            <SelectItem value="title">الاسم</SelectItem>
            <SelectItem value="enrollments">عدد الملتحقين</SelectItem>
            <SelectItem value="lessons">عدد الدروس</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Courses Grid */}
      {filteredCourses.length === 0 ? (
        <div className="text-center py-8">
          <Search className="mx-auto h-12 w-12 text-muted-foreground" />
          <h3 className="mt-2 text-sm font-semibold">لا توجد نتائج</h3>
          <p className="mt-1 text-sm text-muted-foreground">
            جرب تغيير معايير البحث أو الفلترة
          </p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {filteredCourses.map((course) => (
            <div key={course.id} className="border rounded-lg overflow-hidden">
              {/* Course Image */}
              <div className="aspect-video bg-muted relative">
                <img 
                  src={course.thumbnailUrl} 
                  alt={course.title}
                  className="w-full h-full object-cover"
                  onError={(e) => {
                    (e.target as HTMLImageElement).src = '/placeholder-course.jpg';
                  }}
                />
                <div className="absolute top-2 right-2">
                  <Badge variant={course.isPublished ? "default" : "secondary"}>
                    {course.isPublished ? (
                      <>
                        <Eye className="w-3 h-3 mr-1" />
                        منشور
                      </>
                    ) : (
                      <>
                        <EyeOff className="w-3 h-3 mr-1" />
                        مسودة
                      </>
                    )}
                  </Badge>
                </div>
                <div className="absolute top-2 left-2">
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="secondary" size="sm">
                        <MoreHorizontal className="w-4 h-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem asChild>
                        <Link href={`/professor/courses/${course.id}`}>
                          <Settings className="w-4 h-4 mr-2" />
                          إدارة الدورة
                        </Link>
                      </DropdownMenuItem>
                      <DropdownMenuItem asChild>
                        <Link href={`/professor/courses/${course.id}/edit`}>
                          <Edit className="w-4 h-4 mr-2" />
                          تعديل
                        </Link>
                      </DropdownMenuItem>
                      <DropdownMenuSeparator />
                      <AlertDialog>
                        <AlertDialogTrigger asChild>
                          <DropdownMenuItem 
                            onSelect={(e: Event) => e.preventDefault()}
                            className="text-destructive focus:text-destructive"
                            disabled={course._count.enrollments > 0}
                          >
                            <Trash2 className="w-4 h-4 mr-2" />
                            حذف
                          </DropdownMenuItem>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                          <AlertDialogHeader>
                            <AlertDialogTitle>تأكيد الحذف</AlertDialogTitle>
                            <AlertDialogDescription>
                              هل أنت متأكد من حذف دورة &ldquo;{course.title}&rdquo;؟ 
                              هذا الإجراء لا يمكن التراجع عنه.
                            </AlertDialogDescription>
                          </AlertDialogHeader>
                          <AlertDialogFooter>
                            <AlertDialogCancel>إلغاء</AlertDialogCancel>
                            <AlertDialogAction
                              onClick={() => handleDelete(course.id)}
                              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                            >
                              حذف
                            </AlertDialogAction>
                          </AlertDialogFooter>
                        </AlertDialogContent>
                      </AlertDialog>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </div>

              {/* Course Content */}
              <div className="p-4 space-y-3">
                {/* Title and Category */}
                <div>
                  <h3 className="font-semibold text-lg line-clamp-2">{course.title}</h3>
                  <p className="text-sm text-muted-foreground">{course.category.name}</p>
                </div>

                {/* Description */}
                <p className="text-sm text-muted-foreground line-clamp-2">
                  {course.description}
                </p>

                {/* Statistics */}
                <div className="grid grid-cols-3 gap-2 pt-2 border-t">
                  <div className="text-center">
                    <div className="flex items-center justify-center gap-1 text-xs text-muted-foreground">
                      <Users className="w-3 h-3" />
                      <span>ملتحقين</span>
                    </div>
                    <div className="text-sm font-semibold">{course._count.enrollments}</div>
                  </div>
                  <div className="text-center">
                    <div className="flex items-center justify-center gap-1 text-xs text-muted-foreground">
                      <Clock className="w-3 h-3" />
                      <span>دروس</span>
                    </div>
                    <div className="text-sm font-semibold">{course._count.lessons}</div>
                  </div>
                  <div className="text-center">
                    <div className="flex items-center justify-center gap-1 text-xs text-muted-foreground">
                      <DollarSign className="w-3 h-3" />
                      <span>السعر</span>
                    </div>
                    <div className="text-sm font-semibold">{formatPrice(course)}</div>
                  </div>
                </div>

                {/* Actions */}
                <div className="flex gap-2 pt-2 border-t">
                  <Button asChild size="sm" className="flex-1">
                    <Link href={`/professor/courses/${course.id}`}>
                      <Settings className="w-4 h-4" />
                      إدارة
                    </Link>
                  </Button>
                  <Button asChild variant="outline" size="sm" className="flex-1">
                    <Link href={`/professor/courses/${course.id}/edit`}>
                      <Edit className="w-4 h-4" />
                      تعديل
                    </Link>
                  </Button>
                </div>

                {/* Created Date */}
                <div className="flex items-center text-xs text-muted-foreground pt-2 border-t">
                  <Calendar className="w-3 h-3 mr-1" />
                  تم الإنشاء: {new Date(course.createdAt).toLocaleDateString('ar-EG')}
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

#29: ./src/components/profile/ExamHistory.tsx
--------------------------------------------------------------------------------
// src/components/profile/ExamHistory.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ClipboardCheck, Target } from "lucide-react";
import { auth } from "@/lib/auth";
import prisma from "@/lib/prisma";

// This is now an async Server Component
export default async function ExamHistory() {
  const session = await auth();
  if (!session?.user?.id) return null;

  // Fetch only the exam history for THIS component
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { examHistory: true }
  });
  
  const exams = Array.isArray(user?.examHistory) ? user.examHistory : [];

  return (
    <Card className="bg-card">
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-xl">
          <ClipboardCheck className="w-6 h-6 text-primary" />
          <span>نتائج الإمتحانات</span>
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {exams.length > 0 ? (
            exams.map((exam: any, index: number) => (
              <div key={index} className="p-4 rounded-lg bg-muted/50 flex justify-between items-center">
                <div>
                  <h3 className="font-semibold text-foreground">{exam.title}</h3>
                  <p className="text-sm text-muted-foreground">{new Date(exam.date).toLocaleDateString()}</p>
                </div>
                <span className="text-2xl font-bold text-primary bg-primary/10 px-3 py-1 rounded-md">{exam.score}</span>
              </div>
            ))
          ) : (
            <div className="text-center py-10">
              <Target className="mx-auto w-12 h-12 text-muted-foreground/50 mb-4" />
              <p className="text-muted-foreground">لا توجد نتائج امتحانات مسجلة.</p>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

#30: ./src/components/ui/mobile-interactions.tsx
--------------------------------------------------------------------------------
// src/components/ui/mobile-interactions.tsx - Mobile-First Touch Interactions
"use client";

import { useState, useRef, useEffect, ReactNode } from "react";
import { motion, PanInfo, useMotionValue, useTransform } from "framer-motion";
import { cn } from "@/lib/utils";

// Touch Target Component - Ensures 44px minimum touch targets
interface TouchTargetProps {
  children: ReactNode;
  className?: string;
  onClick?: () => void;
  disabled?: boolean;
  haptic?: boolean;
}

export function TouchTarget({ 
  children, 
  className, 
  onClick, 
  disabled = false,
  haptic = true 
}: TouchTargetProps) {
  const handleClick = () => {
    if (disabled) return;
    
    // Haptic feedback simulation
    if (haptic && 'vibrate' in navigator) {
      navigator.vibrate(10);
    }
    
    onClick?.();
  };

  return (
    <motion.button
      className={cn(
        "min-h-[44px] min-w-[44px] flex items-center justify-center",
        "touch-manipulation select-none",
        "transition-all duration-150",
        disabled && "opacity-50 cursor-not-allowed",
        className
      )}
      onClick={handleClick}
      disabled={disabled}
      whileTap={disabled ? {} : { scale: 0.95 }}
      transition={{ duration: 0.1 }}
    >
      {children}
    </motion.button>
  );
}

// Swipeable Card Component
interface SwipeableCardProps {
  children: ReactNode;
  onSwipeLeft?: () => void;
  onSwipeRight?: () => void;
  onSwipeUp?: () => void;
  onSwipeDown?: () => void;
  className?: string;
  swipeThreshold?: number;
}

export function SwipeableCard({
  children,
  onSwipeLeft,
  onSwipeRight,
  onSwipeUp,
  onSwipeDown,
  className,
  swipeThreshold = 100
}: SwipeableCardProps) {
  const x = useMotionValue(0);
  const y = useMotionValue(0);
  const rotateX = useTransform(y, [-100, 100], [5, -5]);
  const rotateY = useTransform(x, [-100, 100], [-5, 5]);

  const handleDragEnd = (event: any, info: PanInfo) => {
    const { offset, velocity } = info;
    
    // Haptic feedback for swipe actions
    if ('vibrate' in navigator) {
      navigator.vibrate(15);
    }

    if (Math.abs(offset.x) > swipeThreshold || Math.abs(velocity.x) > 500) {
      if (offset.x > 0 && onSwipeRight) {
        onSwipeRight();
      } else if (offset.x < 0 && onSwipeLeft) {
        onSwipeLeft();
      }
    }

    if (Math.abs(offset.y) > swipeThreshold || Math.abs(velocity.y) > 500) {
      if (offset.y > 0 && onSwipeDown) {
        onSwipeDown();
      } else if (offset.y < 0 && onSwipeUp) {
        onSwipeUp();
      }
    }

    // Reset position
    x.set(0);
    y.set(0);
  };

  return (
    <motion.div
      className={cn("cursor-grab active:cursor-grabbing", className)}
      drag
      dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}
      dragElastic={0.2}
      onDragEnd={handleDragEnd}
      style={{ x, y, rotateX, rotateY }}
      whileDrag={{ scale: 1.02 }}
    >
      {children}
    </motion.div>
  );
}

// Pull to Refresh Component
interface PullToRefreshProps {
  children: ReactNode;
  onRefresh: () => Promise<void>;
  className?: string;
}

export function PullToRefresh({ children, onRefresh, className }: PullToRefreshProps) {
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [pullDistance, setPullDistance] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  const handlePanStart = () => {
    if (containerRef.current?.scrollTop === 0) {
      setPullDistance(0);
    }
  };

  const handlePan = (event: any, info: PanInfo) => {
    if (containerRef.current?.scrollTop === 0 && info.offset.y > 0) {
      setPullDistance(Math.min(info.offset.y, 100));
    }
  };

  const handlePanEnd = async (event: any, info: PanInfo) => {
    if (pullDistance > 60 && !isRefreshing) {
      setIsRefreshing(true);
      
      // Haptic feedback
      if ('vibrate' in navigator) {
        navigator.vibrate([10, 50, 10]);
      }
      
      try {
        await onRefresh();
      } finally {
        setIsRefreshing(false);
        setPullDistance(0);
      }
    } else {
      setPullDistance(0);
    }
  };

  return (
    <motion.div
      ref={containerRef}
      className={cn("relative overflow-auto", className)}
      onPanStart={handlePanStart}
      onPan={handlePan}
      onPanEnd={handlePanEnd}
    >
      {/* Pull to refresh indicator */}
      {pullDistance > 0 && (
        <motion.div
          className="absolute top-0 left-0 right-0 flex items-center justify-center py-4 bg-primary-50 z-10"
          initial={{ opacity: 0, y: -50 }}
          animate={{ 
            opacity: pullDistance > 30 ? 1 : 0.5, 
            y: pullDistance - 50 
          }}
        >
          <div className="flex items-center gap-2 text-primary-600">
            <motion.div
              animate={{ rotate: isRefreshing ? 360 : 0 }}
              transition={{ duration: 1, repeat: isRefreshing ? Infinity : 0 }}
              className="w-5 h-5 border-2 border-primary-600 border-t-transparent rounded-full"
            />
            <span className="text-sm font-primary">
              {isRefreshing ? 'جاري التحديث...' : pullDistance > 60 ? 'اتركه للتحديث' : 'اسحب للتحديث'}
            </span>
          </div>
        </motion.div>
      )}
      
      <motion.div
        style={{ y: pullDistance * 0.5 }}
        transition={{ type: "spring", stiffness: 300, damping: 30 }}
      >
        {children}
      </motion.div>
    </motion.div>
  );
}

// Mobile Navigation Drawer
interface MobileDrawerProps {
  isOpen: boolean;
  onClose: () => void;
  children: ReactNode;
  position?: 'left' | 'right' | 'bottom';
}

export function MobileDrawer({ 
  isOpen, 
  onClose, 
  children, 
  position = 'right' 
}: MobileDrawerProps) {
  const variants = {
    left: {
      closed: { x: '-100%' },
      open: { x: 0 }
    },
    right: {
      closed: { x: '100%' },
      open: { x: 0 }
    },
    bottom: {
      closed: { y: '100%' },
      open: { y: 0 }
    }
  };

  return (
    <>
      {/* Backdrop */}
      {isOpen && (
        <motion.div
          className="fixed inset-0 bg-black/50 z-40"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          onClick={onClose}
        />
      )}

      {/* Drawer */}
      <motion.div
        className={cn(
          "fixed z-50 bg-white shadow-xl",
          position === 'left' && "top-0 left-0 h-full w-80 max-w-[80vw]",
          position === 'right' && "top-0 right-0 h-full w-80 max-w-[80vw]",
          position === 'bottom' && "bottom-0 left-0 right-0 max-h-[80vh] rounded-t-2xl"
        )}
        variants={variants[position]}
        initial="closed"
        animate={isOpen ? "open" : "closed"}
        transition={{ type: "spring", stiffness: 300, damping: 30 }}
        drag={position === 'bottom' ? 'y' : 'x'}
        dragConstraints={{ 
          [position === 'bottom' ? 'top' : position]: 0,
          [position === 'bottom' ? 'bottom' : (position === 'left' ? 'right' : 'left')]: 0
        }}
        onDragEnd={(event, info) => {
          const threshold = 100;
          const shouldClose = position === 'bottom' 
            ? info.offset.y > threshold
            : Math.abs(info.offset.x) > threshold;
          
          if (shouldClose) {
            onClose();
          }
        }}
      >
        {/* Drag Handle for bottom drawer */}
        {position === 'bottom' && (
          <div className="flex justify-center py-3">
            <div className="w-12 h-1 bg-neutral-300 rounded-full" />
          </div>
        )}
        
        {children}
      </motion.div>
    </>
  );
}

// Touch-optimized Form Components
interface TouchInputProps {
  label: string;
  value: string;
  onChange: (value: string) => void;
  type?: 'text' | 'email' | 'tel' | 'number' | 'password';
  placeholder?: string;
  error?: string;
  className?: string;
}

export function TouchInput({
  label,
  value,
  onChange,
  type = 'text',
  placeholder,
  error,
  className
}: TouchInputProps) {
  const [isFocused, setIsFocused] = useState(false);

  return (
    <div className={cn("space-y-2", className)}>
      <label className="block text-sm font-medium text-neutral-700 font-primary">
        {label}
      </label>
      <motion.input
        type={type}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
        placeholder={placeholder}
        className={cn(
          "w-full min-h-[44px] px-4 py-3 text-base",
          "border-2 rounded-lg transition-all duration-200",
          "touch-manipulation font-primary",
          isFocused 
            ? "border-primary-500 ring-2 ring-primary-200" 
            : "border-neutral-300",
          error && "border-red-500 ring-2 ring-red-200"
        )}
        // Mobile-specific attributes
        autoCapitalize={type === 'email' ? 'none' : 'sentences'}
        autoCorrect={type === 'email' || type === 'password' ? 'off' : 'on'}
        spellCheck={type === 'email' || type === 'password' ? false : true}
      />
      {error && (
        <motion.p
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          className="text-sm text-red-600 font-primary"
        >
          {error}
        </motion.p>
      )}
    </div>
  );
}

// Mobile-optimized Button
interface TouchButtonProps {
  children: ReactNode;
  onClick?: () => void;
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  loading?: boolean;
  fullWidth?: boolean;
  className?: string;
}

export function TouchButton({
  children,
  onClick,
  variant = 'primary',
  size = 'md',
  disabled = false,
  loading = false,
  fullWidth = false,
  className
}: TouchButtonProps) {
  const baseClasses = cn(
    "inline-flex items-center justify-center font-medium rounded-lg",
    "touch-manipulation select-none transition-all duration-150",
    "focus:outline-none focus:ring-2 focus:ring-offset-2",
    disabled && "opacity-50 cursor-not-allowed",
    fullWidth && "w-full"
  );

  const variantClasses = {
    primary: "bg-primary-600 text-black hover:bg-primary-700 focus:ring-primary-500",
    secondary: "bg-neutral-600 text-black hover:bg-neutral-700 focus:ring-neutral-500",
    outline: "border-2 border-primary-600 text-primary-600 hover:bg-primary-50 focus:ring-primary-500",
    ghost: "text-primary-600 hover:bg-primary-50 focus:ring-primary-500"
  };

  const sizeClasses = {
    sm: "min-h-[40px] px-3 py-2 text-sm",
    md: "min-h-[44px] px-4 py-3 text-base",
    lg: "min-h-[48px] px-6 py-4 text-lg"
  };

  const handleClick = () => {
    if (disabled || loading) return;
    
    // Haptic feedback
    if ('vibrate' in navigator) {
      navigator.vibrate(10);
    }
    
    onClick?.();
  };

  return (
    <motion.button
      className={cn(baseClasses, variantClasses[variant], sizeClasses[size], className)}
      onClick={handleClick}
      disabled={disabled || loading}
      whileTap={disabled || loading ? {} : { scale: 0.98 }}
      transition={{ duration: 0.1 }}
    >
      {loading && (
        <motion.div
          className="w-5 h-5 border-2 border-current border-t-transparent rounded-full mr-2"
          animate={{ rotate: 360 }}
          transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
        />
      )}
      {children}
    </motion.button>
  );
}

// Gesture Recognition Hook
export function useGestures(
  elementRef: React.RefObject<HTMLElement>,
  callbacks: {
    onSwipeLeft?: () => void;
    onSwipeRight?: () => void;
    onSwipeUp?: () => void;
    onSwipeDown?: () => void;
    onPinch?: (scale: number) => void;
    onDoubleTap?: () => void;
  }
) {
  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    let startX = 0;
    let startY = 0;
    let lastTap = 0;
    let pinchDistance = 0;

    const handleTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        pinchDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
      }
    };

    const handleTouchEnd = (e: TouchEvent) => {
      if (e.changedTouches.length === 1) {
        const endX = e.changedTouches[0].clientX;
        const endY = e.changedTouches[0].clientY;
        const deltaX = endX - startX;
        const deltaY = endY - startY;
        const threshold = 50;

        // Check for swipe gestures
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (Math.abs(deltaX) > threshold) {
            if (deltaX > 0) {
              callbacks.onSwipeRight?.();
            } else {
              callbacks.onSwipeLeft?.();
            }
          }
        } else {
          if (Math.abs(deltaY) > threshold) {
            if (deltaY > 0) {
              callbacks.onSwipeDown?.();
            } else {
              callbacks.onSwipeUp?.();
            }
          }
        }

        // Check for double tap
        const now = Date.now();
        if (now - lastTap < 300) {
          callbacks.onDoubleTap?.();
        }
        lastTap = now;
      }
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (e.touches.length === 2 && callbacks.onPinch) {
        const currentDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        const scale = currentDistance / pinchDistance;
        callbacks.onPinch(scale);
      }
    };

    element.addEventListener('touchstart', handleTouchStart, { passive: true });
    element.addEventListener('touchend', handleTouchEnd, { passive: true });
    element.addEventListener('touchmove', handleTouchMove, { passive: true });

    return () => {
      element.removeEventListener('touchstart', handleTouchStart);
      element.removeEventListener('touchend', handleTouchEnd);
      element.removeEventListener('touchmove', handleTouchMove);
    };
  }, [callbacks]);
}

#31: ./src/hooks/useAdminPayments.ts
--------------------------------------------------------------------------------
// src/hooks/useAdminPayments.ts

import { useState, useEffect, useCallback } from 'react';
import { toast } from 'sonner';

// Define the types co-located with the hook for clarity
export interface Payment {
  id: string;
  amount: number;
  currency: string;
  status: string;
  createdAt: string;
  completedAt?: string;
  failureReason?: string;
  paymobOrderId?: string;
  paymobTransactionId?: number;
  user: {
    id: string;
    name: string;
    email: string;
    phone: string;
  };
  course: {
    id: string;
    title: string;
    thumbnailUrl: string;
    professor: {
      name: string;
    };
  };
  lastWebhook?: {
    id: string;
    processedAt: string;
    processingAttempts: number;
    lastError?: string;
  };
}

export interface PaymentSummary {
  total: number;
  completed: number;
  pending: number;
  failed: number;
  cancelled: number;
  totalRevenue: number;
}

export interface UseAdminPaymentsReturn {
  payments: Payment[];
  summary: PaymentSummary | null;
  isLoading: boolean;
  error: string | null;
  pagination: {
    currentPage: number;
    totalPages: number;
    setCurrentPage: (page: number) => void;
  };
  filters: {
    searchTerm: string;
    setSearchTerm: (term: string) => void;
    statusFilter: string;
    setStatusFilter: (status: string) => void;
    dateFrom: string;
    setDateFrom: (date: string) => void;
    dateTo: string;
    setDateTo: (date: string) => void;
  };
  handlePaymentAction: (
    paymentId: string,
    action: string,
    additionalData?: any
  ) => Promise<void>;
  exportPayments: () => Promise<void>;
  refresh: () => void;
}

/**
 * A comprehensive hook to manage the state and logic for the Admin Payment Management dashboard.
 */
export function useAdminPayments(): UseAdminPaymentsReturn {
  const [payments, setPayments] = useState<Payment[]>([]);
  const [summary, setSummary] = useState<PaymentSummary | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Filter and Pagination State
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState('all');
  const [dateFrom, setDateFrom] = useState('');
  const [dateTo, setDateTo] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  // A simple state to trigger refetch
  const [refetchTrigger, setRefetchTrigger] = useState(0);

  const fetchPayments = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const params = new URLSearchParams({
        page: currentPage.toString(),
        limit: '10', // Consistent limit
        ...(statusFilter !== 'all' && { status: statusFilter }),
        ...(searchTerm && { search: searchTerm }),
        ...(dateFrom && { dateFrom }),
        ...(dateTo && { dateTo }),
      });

      const response = await fetch(`/api/admin/payments?${params.toString()}`);
      if (!response.ok) throw new Error('فشل في تحميل المدفوعات من الخادم');

      const result = await response.json();
      if (result.success) {
        setPayments(result.data.payments);
        setSummary(result.data.summary);
        setTotalPages(result.data.pagination.pages);
      } else {
        throw new Error(result.error || 'فشل في تحميل المدفوعات');
      }
    } catch (err) {
      const message =
        err instanceof Error ? err.message : 'حدث خطأ غير متوقع';
      setError(message);
      toast.error(message);
    } finally {
      setIsLoading(false);
    }
  }, [currentPage, statusFilter, searchTerm, dateFrom, dateTo, refetchTrigger]);

  useEffect(() => {
    fetchPayments();
  }, [fetchPayments]);

  const handlePaymentAction = async (
    paymentId: string,
    action: string,
    additionalData?: any
  ) => {
    try {
      const response = await fetch(`/api/admin/payments/${paymentId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action, ...additionalData }),
      });
      const result = await response.json();

      if (result.success) {
        toast.success('تم تحديث المدفوعة بنجاح');
        fetchPayments(); // Refetch data after action
      } else {
        toast.error(result.error?.message || 'فشل في تحديث المدفوعة');
      }
    } catch (err) {
      console.error('Payment action failed:', err);
      toast.error('حدث خطأ في العملية');
    }
  };

  const exportPayments = async () => {
    try {
      const params = new URLSearchParams({
        ...(statusFilter !== 'all' && { status: statusFilter }),
        ...(searchTerm && { search: searchTerm }),
        ...(dateFrom && { dateFrom }),
        ...(dateTo && { dateTo }),
      });

      const response = await fetch(
        `/api/admin/payments/export?${params.toString()}`
      );
      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `payments-export-${new Date()
          .toISOString()
          .split('T')[0]}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
        toast.success('تم تصدير البيانات بنجاح');
      } else {
        toast.error('فشل في تصدير البيانات');
      }
    } catch (err) {
      console.error('Export failed:', err);
      toast.error('حدث خطأ في التصدير');
    }
  };

  const refresh = () => setRefetchTrigger((c) => c + 1);

  return {
    payments,
    summary,
    isLoading,
    error,
    pagination: {
      currentPage,
      totalPages,
      setCurrentPage,
    },
    filters: {
      searchTerm,
      setSearchTerm,
      statusFilter,
      setStatusFilter,
      dateFrom,
      setDateFrom,
      dateTo,
      setDateTo,
    },
    handlePaymentAction,
    exportPayments,
    refresh,
  };
}

#32: ./src/hooks/useAnimations.ts
--------------------------------------------------------------------------------
// Performance-optimized animation hooks
import { useReducedMotion, useInView } from "framer-motion"
import { useEffect, useState, useRef, RefObject } from "react"

// Hook for reduced motion preference
export const useOptimizedMotion = () => {
  const shouldReduceMotion = useReducedMotion()
  
  return {
    shouldReduceMotion,
    // Return instant transitions for reduced motion
    getTransition: (duration: number = 0.3) => 
      shouldReduceMotion ? { duration: 0 } : { duration },
  }
}

// Correct type for the 'margin' property
type MarginType = `${number}px` | `${number}px ${number}px` | `${number}px ${number}px ${number}px` | `${number}px ${number}px ${number}px ${number}px`;

// Hook for intersection observer with performance optimization
export const useInViewOptimized = (options?: {
    root?: RefObject<Element>;
    once?: boolean;
    margin?: MarginType;
    amount?: "some" | "all" | number;
}) => {
  const ref = useRef<HTMLDivElement>(null)
  const isInView = useInView(ref, {
    once: true, // Only trigger once for performance
    margin: options?.margin || "0px 0px -100px 0px", // Trigger before element is visible
    ...options,
  })
  
  return { ref, isInView }
}

// Hook for staggered animations with performance optimization
export const useStaggeredAnimation = (itemCount: number, delay: number = 0.1) => {
  const [visibleItems, setVisibleItems] = useState(0)
  const { shouldReduceMotion } = useOptimizedMotion()
  
  useEffect(() => {
    if (shouldReduceMotion) {
      setVisibleItems(itemCount)
      return
    }
    
    const timer = setInterval(() => {
      setVisibleItems(prev => {
        if (prev >= itemCount) {
          clearInterval(timer)
          return prev
        }
        return prev + 1
      })
    }, delay * 1000)
    
    return () => clearInterval(timer)
  }, [itemCount, delay, shouldReduceMotion])
  
  return visibleItems
}

// Hook for scroll-triggered animations with throttling
export const useScrollAnimation = (threshold: number = 0.1) => {
  const [scrollY, setScrollY] = useState(0)
  const [isScrolling, setIsScrolling] = useState(false)
  
  useEffect(() => {
    let ticking = false
    let scrollTimeout: NodeJS.Timeout
    
    const updateScrollY = () => {
      setScrollY(window.scrollY)
      ticking = false
      
      setIsScrolling(true)
      clearTimeout(scrollTimeout)
      scrollTimeout = setTimeout(() => setIsScrolling(false), 150)
    }
    
    const requestTick = () => {
      if (!ticking) {
        requestAnimationFrame(updateScrollY)
        ticking = true
      }
    }
    
    window.addEventListener('scroll', requestTick, { passive: true })
    
    return () => {
      window.removeEventListener('scroll', requestTick)
      clearTimeout(scrollTimeout)
    }
  }, [])
  
  return { scrollY, isScrolling }
}

// Hook for gesture support with performance optimization
export const useGestures = () => {
  const [isDragging, setIsDragging] = useState(false)
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 })
  
  const dragHandlers = {
    onDragStart: () => setIsDragging(true),
    onDragEnd: () => {
      setIsDragging(false)
      setDragOffset({ x: 0, y: 0 })
    },
    onDrag: (_: any, info: any) => {
      setDragOffset({ x: info.offset.x, y: info.offset.y })
    },
  }
  
  return {
    isDragging,
    dragOffset,
    dragHandlers,
  }
}

// Hook for preloading animations
export const usePreloadAnimations = () => {
  useEffect(() => {
    // Preload common animation styles
    const style = document.createElement('style')
    style.textContent = `
      .will-change-transform { will-change: transform; }
      .will-change-opacity { will-change: opacity; }
      .gpu-accelerated { transform: translateZ(0); }
    `
    document.head.appendChild(style)
    
    return () => {
      document.head.removeChild(style)
    }
  }, [])
}

// Hook for animation performance monitoring
export const useAnimationPerformance = () => {
  const [fps, setFps] = useState(60)
  const frameCount = useRef(0)
  const lastTime = useRef(performance.now())
  
  useEffect(() => {
    let animationId: number
    
    const measureFPS = () => {
      frameCount.current++
      const currentTime = performance.now()
      
      if (currentTime - lastTime.current >= 1000) {
        setFps(Math.round((frameCount.current * 1000) / (currentTime - lastTime.current)))
        frameCount.current = 0
        lastTime.current = currentTime
      }
      
      animationId = requestAnimationFrame(measureFPS)
    }
    
    animationId = requestAnimationFrame(measureFPS)
    
    return () => cancelAnimationFrame(animationId)
  }, [])
  
  return { fps, isPerformant: fps >= 55 }
}

#33: ./src/hooks/useCreateCourseForm.ts
--------------------------------------------------------------------------------
// src/hooks/useCreateCourseForm.ts
"use client";

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';

interface Category {
  id: string;
  name: string;
}

interface Professor {
  id: string;
  name: string;
  email: string;
}

interface CourseFormData {
  title: string;
  description: string;
  categoryId: string;
  professorId: string;
  price: string;
  currency: string;
  thumbnailUrl: string;
  bunnyLibraryId: string;
  isPublished: boolean;
}

export function useCreateCourseForm() {
  const router = useRouter();
  const [formData, setFormData] = useState<CourseFormData>({
    title: '',
    description: '',
    categoryId: '',
    professorId: '',
    price: '',
    currency: 'EGP',
    thumbnailUrl: '',
    bunnyLibraryId: '',
    isPublished: false
  });

  const [categories, setCategories] = useState<Category[]>([]);
  const [professors, setProfessors] = useState<Professor[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [currentStep, setCurrentStep] = useState(1);

  useEffect(() => {
    fetchCategories();
    fetchProfessors();
  }, []);

  const fetchCategories = async () => {
    try {
      const response = await fetch('/api/categories');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Handle the API response structure
      setCategories(data.categories || []);
    } catch (error) {
      console.error('Failed to fetch categories:', error);
      toast.error('فشل في تحميل التصنيفات');
      setCategories([]); // Set empty array as fallback
    }
  };

  const fetchProfessors = async () => {
    try {
      const response = await fetch('/api/users?role=PROFESSOR');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      // Handle the API response structure
      setProfessors(data.data?.users || []);
    } catch (error) {
      console.error('Failed to fetch professors:', error);
      toast.error('فشل في تحميل قائمة المدرسين');
      setProfessors([]); // Set empty array as fallback
    }
  };

  const handleInputChange = (field: keyof CourseFormData, value: string | boolean) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const handleThumbnailUpload = (files: any[]) => {
    if (files.length > 0) {
      setFormData(prev => ({
        ...prev,
        thumbnailUrl: files[0].url
      }));
      toast.success('تم رفع صورة الدورة بنجاح');
    }
  };

  const validateStep = (step: number): boolean => {
    switch (step) {
      case 1:
        return !!(formData.title && formData.description && formData.categoryId);
      case 2:
        return !!(formData.professorId && formData.bunnyLibraryId);
      case 3:
        return !!(formData.thumbnailUrl);
      default:
        return true;
    }
  };

  const handleNext = () => {
    if (validateStep(currentStep)) {
      setCurrentStep(prev => Math.min(4, prev + 1));
    } else {
      toast.error('يرجى إكمال جميع الحقول المطلوبة');
    }
  };

  const handlePrevious = () => {
    setCurrentStep(prev => Math.max(1, prev - 1));
  };

  const handleSubmit = async () => {
    if (!validateStep(1) || !validateStep(2) || !validateStep(3)) {
      toast.error('يرجى إكمال جميع الحقول المطلوبة');
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch('/api/admin/courses', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...formData,
          price: formData.price ? parseFloat(formData.price) : null
        }),
      });

      // Check if response is ok first
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Server error:', errorText);
        toast.error(`خطأ في الخادم: ${response.status}`);
        return;
      }

      // Check if response has content
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        console.error('Invalid response type:', contentType);
        toast.error('استجابة غير صحيحة من الخادم');
        return;
      }

      const result = await response.json();

      if (result.success) {
        toast.success('تم إنشاء الدورة بنجاح');
        router.push(`/admin/courses/${result.course.id}`);
      } else {
        toast.error(result.error || 'فشل في إنشاء الدورة');
      }
    } catch (error) {
      console.error('Course creation error:', error);
      if (error instanceof SyntaxError) {
        toast.error('خطأ في تحليل استجابة الخادم');
      } else {
        toast.error('حدث خطأ في إنشاء الدورة');
      }
    } finally {
      setIsLoading(false);
    }
  };

  return {
    formData,
    categories,
    professors,
    isLoading,
    currentStep,
    handleInputChange,
    handleThumbnailUpload,
    validateStep,
    handleNext,
    handlePrevious,
    handleSubmit
  };
}

export type { CourseFormData, Category, Professor };

#34: ./src/hooks/useProgressTracking.ts
--------------------------------------------------------------------------------
// src/hooks/useProgressTracking.ts
'use client';

import { useEffect, useCallback } from 'react';
// Progress tracking hook for client-side milestone recording

interface UseProgressTrackingProps {
  courseId: string;
  completionRate: number;
  completedLessons: number;
  totalLessons: number;
  isEnrolled: boolean;
}

export function useProgressTracking({
  courseId,
  completionRate,
  completedLessons,
  totalLessons,
  isEnrolled
}: UseProgressTrackingProps) {
  
  const recordMilestone = useCallback(async (
    milestoneType: string, 
    metadata?: any
  ) => {
    try {
      const response = await fetch('/api/progress/milestone', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          courseId,
          milestoneType,
          metadata
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to record milestone');
      }
    } catch (error) {
      console.error('Failed to record milestone:', error);
    }
  }, [courseId]);

  // Track enrollment milestone
  useEffect(() => {
    if (isEnrolled) {
      recordMilestone('COURSE_START', {
        enrollmentDate: new Date().toISOString()
      });
    }
  }, [isEnrolled, recordMilestone]);

  // Track first lesson milestone
  useEffect(() => {
    if (completedLessons === 1) {
      recordMilestone('LESSON_COMPLETE', {
        firstLessonDate: new Date().toISOString()
      });
    }
  }, [completedLessons, recordMilestone]);

  // Track halfway milestone
  useEffect(() => {
    if (completionRate >= 50 && completionRate < 90) {
      recordMilestone('HALFWAY', {
        completionRate,
        completedLessons,
        totalLessons,
        halfwayDate: new Date().toISOString()
      });
    }
  }, [completionRate, completedLessons, totalLessons, recordMilestone]);

  // Track completion milestone
  useEffect(() => {
    if (completionRate >= 90) {
      recordMilestone('COMPLETION', {
        completionRate,
        completedLessons,
        totalLessons,
        completionDate: new Date().toISOString()
      });
    }
  }, [completionRate, completedLessons, totalLessons, recordMilestone]);

  return {
    recordMilestone
  };
}

#35: ./src/lib/animations.ts
--------------------------------------------------------------------------------
// Performance-optimized animation system
import { Variants, Transition } from "framer-motion"

// High-performance spring configuration
export const springConfig: Transition = {
  type: "spring",
  stiffness: 400,
  damping: 30,
  mass: 0.8,
}

// Optimized easing curves
export const easings = {
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
} as const

// Performance-first animation variants
export const fadeInUp: Variants = {
  initial: { 
    opacity: 0, 
    y: 20,
    transition: { duration: 0 } // Instant initial state
  },
  animate: { 
    opacity: 1, 
    y: 0,
    transition: {
      duration: 0.3,
      ease: easings.easeOutCubic,
    }
  },
  exit: { 
    opacity: 0, 
    y: -10,
    transition: {
      duration: 0.2,
      ease: easings.easeInOutCubic,
    }
  }
}

export const scaleIn: Variants = {
  initial: { 
    opacity: 0, 
    scale: 0.95,
    transition: { duration: 0 }
  },
  animate: { 
    opacity: 1, 
    scale: 1,
    transition: {
      duration: 0.2,
      ease: easings.easeOutQuart,
    }
  },
  exit: { 
    opacity: 0, 
    scale: 0.95,
    transition: {
      duration: 0.15,
      ease: easings.easeInOutCubic,
    }
  }
}

export const slideInRight: Variants = {
  initial: { 
    opacity: 0, 
    x: 30,
    transition: { duration: 0 }
  },
  animate: { 
    opacity: 1, 
    x: 0,
    transition: {
      duration: 0.3,
      ease: easings.easeOutCubic,
    }
  },
  exit: { 
    opacity: 0, 
    x: -20,
    transition: {
      duration: 0.2,
      ease: easings.easeInOutCubic,
    }
  }
}

// Button press animation (optimized for 60fps)
export const buttonPress: Variants = {
  initial: { scale: 1 },
  whileTap: { 
    scale: 0.95,
    transition: {
      duration: 0.1,
      ease: easings.easeOutQuart,
    }
  },
  whileHover: { 
    scale: 1.02,
    transition: {
      duration: 0.2,
      ease: easings.easeOutCubic,
    }
  }
}

// Card hover animation (GPU accelerated)
export const cardHover: Variants = {
  initial: { 
    y: 0,
    boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1)",
  },
  whileHover: { 
    y: -8,
    boxShadow: "0 20px 25px -5px rgba(0, 0, 0, 0.1)",
    transition: {
      duration: 0.3,
      ease: easings.easeOutCubic,
    }
  }
}

// Staggered children animation
export const staggerContainer: Variants = {
  initial: {},
  animate: {
    transition: {
      staggerChildren: 0.1,
      delayChildren: 0.1,
    }
  }
}

export const staggerItem: Variants = {
  initial: { 
    opacity: 0, 
    y: 20,
  },
  animate: { 
    opacity: 1, 
    y: 0,
    transition: {
      duration: 0.4,
      ease: easings.easeOutCubic,
    }
  }
}

// Page transition variants (optimized for Next.js)
export const pageTransition: Variants = {
  initial: { 
    opacity: 0,
    scale: 0.98,
  },
  animate: { 
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.3,
      ease: easings.easeOutCubic,
    }
  },
  exit: { 
    opacity: 0,
    scale: 1.02,
    transition: {
      duration: 0.2,
      ease: easings.easeInOutCubic,
    }
  }
}

// Modal/Dialog animations
export const modalBackdrop: Variants = {
  initial: { opacity: 0 },
  animate: { 
    opacity: 1,
    transition: {
      duration: 0.2,
      ease: easings.easeOutCubic,
    }
  },
  exit: { 
    opacity: 0,
    transition: {
      duration: 0.15,
      ease: easings.easeInOutCubic,
    }
  }
}

export const modalContent: Variants = {
  initial: { 
    opacity: 0, 
    scale: 0.95,
    y: 20,
  },
  animate: { 
    opacity: 1, 
    scale: 1,
    y: 0,
    transition: {
      duration: 0.3,
      ease: easings.easeOutCubic,
    }
  },
  exit: { 
    opacity: 0, 
    scale: 0.95,
    y: 10,
    transition: {
      duration: 0.2,
      ease: easings.easeInOutCubic,
    }
  }
}

// Loading spinner (optimized)
export const spinnerRotate: Variants = {
  animate: {
    rotate: 360,
    transition: {
      duration: 1,
      ease: "linear",
      repeat: Infinity,
    }
  }
}

// Reduced motion support
export const getReducedMotionVariants = (variants: Variants): Variants => {
  if (typeof window !== 'undefined' && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    return {
      initial: variants.animate || {},
      animate: variants.animate || {},
      exit: variants.animate || {},
    }
  }
  return variants
}

// Performance monitoring
export const animationConfig = {
  // Enable GPU acceleration
  transformTemplate: ({ x, y, rotate, scale }: any) => 
    `translate3d(${x}, ${y}, 0) rotate(${rotate}) scale(${scale})`,
  
  // Optimize for 60fps
  transition: {
    duration: 0.3,
    ease: easings.easeOutCubic,
  },
  
  // Reduce layout thrashing
  layout: false,
  
  // Enable will-change optimization
  style: {
    willChange: 'transform, opacity',
  }
}

#36: ./src/lib/api/auth.ts
--------------------------------------------------------------------------------
// src/lib/api/auth.ts
// API authentication utilities (different from Next.js middleware)

import { auth } from "@/lib/auth";
import { UserRole } from "@prisma/client";
import { createErrorResponse, ApiErrors } from "@/lib/api-response";

/**
 * Authentication result for API routes
 */
export interface ApiAuthResult {
  user: {
    id: string;
    role: UserRole;
    name: string;
    email?: string;
    phone: string;
  };
}

/**
 * Authenticate user for API routes and check role permissions
 */
export async function authenticateApiUser(
  allowedRoles?: UserRole[]
): Promise<ApiAuthResult | ReturnType<typeof createErrorResponse>> {
  const session = await auth();

  if (!session?.user) {
    return ApiErrors.UNAUTHORIZED.create();
  }

  if (allowedRoles && !allowedRoles.includes(session.user.role as UserRole)) {
    return createErrorResponse(
      ApiErrors.FORBIDDEN.code,
      "غير مصرح لك بالوصول لهذه الخدمة",
      ApiErrors.FORBIDDEN.status
    );
  }

  return {
    user: {
      id: session.user.id,
      role: session.user.role as UserRole,
      name: session.user.name || "",
      email: session.user.email || undefined,
      phone: session.user.phone || "",
    },
  };
}

/**
 * Admin-only API authentication
 */
export async function authenticateAdmin(): Promise<
  ApiAuthResult | ReturnType<typeof createErrorResponse>
> {
  return authenticateApiUser(["ADMIN"]);
}

/**
 * Student-only API authentication
 */
export async function authenticateStudent(): Promise<
  ApiAuthResult | ReturnType<typeof createErrorResponse>
> {
  return authenticateApiUser(["STUDENT"]);
}

/**
 * Professor-only API authentication
 */
export async function authenticateProfessor(): Promise<
  ApiAuthResult | ReturnType<typeof createErrorResponse>
> {
  return authenticateApiUser(["PROFESSOR"]);
}

/**
 * Student or Admin API authentication (for testing/admin access)
 */
export async function authenticateStudentOrAdmin(): Promise<
  ApiAuthResult | ReturnType<typeof createErrorResponse>
> {
  return authenticateApiUser(["STUDENT", "ADMIN"]);
}

/**
 * Check if result is an error response
 */
export function isAuthError(
  result: unknown
): result is ReturnType<typeof createErrorResponse> {
  return !!(result && typeof (result as any).json === "function");
}


#37: ./src/lib/api/courses.ts
--------------------------------------------------------------------------------
// src/lib/api/courses.ts
import { ApiResponse } from '@/lib/api-utils';

export interface Course {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  price: number | null;
  currency: string;
  isPublished: boolean;
  bunnyLibraryId: string;
  categoryId: string;
  professorId: string;
  createdAt: string;
  updatedAt: string;
  
  // Relations
  category: {
    id: string;
    name: string;
    slug: string;
    description?: string;
  };
  professor: {
    id: string;
    name: string;
    bio: string | null;
    expertise?: string[];
  };
  lessons?: Array<{
    id: string;
    title: string;
    order: number;
    duration: number | null;
    bunnyVideoId: string;
    materials: any;
  }>;
  
  // Counts
  _count: {
    enrollments: number;
    lessons: number;
  };
  
  // User-specific data (when authenticated)
  isEnrolled?: boolean;
  userProgress?: {
    id: string;
    enrolledAt: string;
    progressPercent: number;
    completedLessonIds: string[];
    totalWatchTime: number;
    lastAccessedAt: string | null;
  };
  canEdit?: boolean;
}

export interface CreateCourseData {
  title: string;
  description: string;
  thumbnailUrl: string;
  categoryId: string;
  bunnyLibraryId: string;
  price?: number;
  currency?: string;
}

export interface UpdateCourseData {
  title?: string;
  description?: string;
  thumbnailUrl?: string;
  categoryId?: string;
  bunnyLibraryId?: string;
  price?: number | null;
  currency?: string;
  isPublished?: boolean;
}

export interface CourseFilters {
  page?: number;
  limit?: number;
  categoryId?: string;
  professorId?: string;
  search?: string;
  priceFilter?: 'free' | 'paid' | 'all';
  sortBy?: 'created' | 'title' | 'price' | 'enrollments';
  sortOrder?: 'asc' | 'desc';
  publishedOnly?: boolean;
}

export interface CoursesResponse {
  courses: Course[];
  pagination: {
    page: number;
    limit: number;
    totalCount: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
  filters: CourseFilters;
}

class CoursesApi {
  private baseUrl = '/api/courses';

  async getAll(filters: CourseFilters = {}): Promise<CoursesResponse> {
    const params = new URLSearchParams();
    
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        params.append(key, value.toString());
      }
    });

    const url = `${this.baseUrl}${params.toString() ? `?${params.toString()}` : ''}`;
    const response = await fetch(url);
    const data: ApiResponse<CoursesResponse> = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في جلب الدورات');
    }
    
    return data.data!;
  }

  async getById(id: string, includeUnpublished: boolean = false): Promise<Course> {
    const params = includeUnpublished ? '?includeUnpublished=true' : '';
    const response = await fetch(`${this.baseUrl}/${id}${params}`);
    const data: ApiResponse<Course> = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في جلب الدورة');
    }
    
    return data.data!;
  }

  async create(courseData: CreateCourseData): Promise<Course> {
    const response = await fetch(this.baseUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(courseData),
    });
    
    const data: ApiResponse<Course> = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في إنشاء الدورة');
    }
    
    return data.data!;
  }

  async update(id: string, courseData: UpdateCourseData): Promise<Course> {
    const response = await fetch(`${this.baseUrl}/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(courseData),
    });
    
    const data: ApiResponse<Course> = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في تحديث الدورة');
    }
    
    return data.data!;
  }

  async delete(id: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/${id}`, {
      method: 'DELETE',
    });
    
    const data: ApiResponse = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في حذف الدورة');
    }
  }

  async enroll(courseId: string): Promise<any> {
    const response = await fetch(`${this.baseUrl}/${courseId}/enroll`, {
      method: 'POST',
    });
    
    const data: ApiResponse = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في التسجيل في الدورة');
    }
    
    return data.data;
  }

  async unenroll(courseId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/${courseId}/enroll`, {
      method: 'DELETE',
    });
    
    const data: ApiResponse = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في إلغاء التسجيل من الدورة');
    }
  }

  // Utility functions
  formatPrice(course: Course): string {
    if (!course.price || course.price === 0) {
      return 'مجاني';
    }
    
    return new Intl.NumberFormat('ar-EG', {
      style: 'currency',
      currency: course.currency || 'EGP',
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }).format(course.price);
  }

  calculateProgress(course: Course): number {
    if (!course.userProgress || !course.lessons) {
      return 0;
    }
    
    const totalLessons = course.lessons.length;
    const completedLessons = course.userProgress.completedLessonIds.length;
    
    return totalLessons > 0 ? Math.round((completedLessons / totalLessons) * 100) : 0;
  }

  getEnrollmentStatus(course: Course): 'not_enrolled' | 'enrolled' | 'completed' {
    if (!course.isEnrolled) {
      return 'not_enrolled';
    }
    
    const progress = this.calculateProgress(course);
    return progress === 100 ? 'completed' : 'enrolled';
  }

  validateCourseData(data: CreateCourseData | UpdateCourseData): string[] {
    const errors: string[] = [];

    if ('title' in data && data.title !== undefined) {
      if (!data.title || data.title.trim().length === 0) {
        errors.push('عنوان الدورة مطلوب');
      } else if (data.title.length > 200) {
        errors.push('عنوان الدورة طويل جداً (الحد الأقصى 200 حرف)');
      }
    }

    if ('description' in data && data.description !== undefined) {
      if (!data.description || data.description.trim().length === 0) {
        errors.push('وصف الدورة مطلوب');
      } else if (data.description.length > 2000) {
        errors.push('وصف الدورة طويل جداً (الحد الأقصى 2000 حرف)');
      }
    }

    if ('thumbnailUrl' in data && data.thumbnailUrl !== undefined) {
      if (!data.thumbnailUrl || data.thumbnailUrl.trim().length === 0) {
        errors.push('رابط الصورة المصغرة مطلوب');
      } else {
        try {
          new URL(data.thumbnailUrl);
        } catch {
          errors.push('رابط الصورة المصغرة غير صحيح');
        }
      }
    }

    if ('categoryId' in data && data.categoryId !== undefined) {
      if (!data.categoryId || data.categoryId.trim().length === 0) {
        errors.push('فئة الدورة مطلوبة');
      }
    }

    if ('bunnyLibraryId' in data && data.bunnyLibraryId !== undefined) {
      if (!data.bunnyLibraryId || data.bunnyLibraryId.trim().length === 0) {
        errors.push('معرف مكتبة Bunny مطلوب');
      }
    }

    if ('price' in data && data.price !== undefined && data.price !== null) {
      if (data.price < 0) {
        errors.push('السعر لا يمكن أن يكون سالباً');
      }
    }

    return errors;
  }
}

export const coursesApi = new CoursesApi();

#38: ./src/lib/api/database.ts
--------------------------------------------------------------------------------
// src/lib/api/database.ts
// Consolidated database utilities and transaction helpers

import prisma from '@/lib/prisma';
import { Prisma } from '@prisma/client';
import { createErrorResponse, ApiErrors } from '@/lib/api-response';

/**
 * Execute database operation with error handling
 */
export async function executeWithErrorHandling<T>(
  operation: () => Promise<T>,
  errorContext: string = 'Database operation'
): Promise<T | ReturnType<typeof createErrorResponse>> {
  try {
    return await operation();
  } catch (error) {
    console.error(`${errorContext} error:`, error);
    
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // Handle specific Prisma errors
      switch (error.code) {
        case 'P2002':
          return createErrorResponse(
            ApiErrors.DUPLICATE_ERROR.code,
            'البيانات موجودة بالفعل',
            ApiErrors.DUPLICATE_ERROR.status
          );
        case 'P2025':
          return createErrorResponse(
            ApiErrors.NOT_FOUND.code,
            'العنصر غير موجود',
            ApiErrors.NOT_FOUND.status
          );
        default:
          return createErrorResponse(
            ApiErrors.INTERNAL_ERROR.code,
            ApiErrors.INTERNAL_ERROR.message,
            ApiErrors.INTERNAL_ERROR.status,
            error
          );
      }
    }
    
    return createErrorResponse(
      ApiErrors.INTERNAL_ERROR.code,
      ApiErrors.INTERNAL_ERROR.message,
      ApiErrors.INTERNAL_ERROR.status,
      error
    );
  }
}

/**
 * Execute transaction with error handling
 */
export async function executeTransaction<T>(
  operation: (tx: Prisma.TransactionClient) => Promise<T>,
  errorContext: string = 'Transaction'
): Promise<T | ReturnType<typeof createErrorResponse>> {
  return executeWithErrorHandling(
    () => prisma.$transaction(operation, { timeout: 30000 }),
    errorContext
  );
}

/**
 * Check if database result is an error
 */
export function isDatabaseError(result: any): result is ReturnType<typeof createErrorResponse> {
  return result && typeof result.json === 'function';
}

/**
 * Common database queries
 */
export const commonQueries = {
  /**
   * Check if user exists and has specific role
   */
  async checkUserExists(userId: string, role?: string) {
    return executeWithErrorHandling(
      () => prisma.user.findFirst({
        where: {
          id: userId,
          ...(role && { role: role as any })
        },
        select: {
          id: true,
          name: true,
          role: true,
          isActive: true
        }
      }),
      'Check user exists'
    );
  },

  /**
   * Check if course exists and is published
   */
  async checkCourseExists(courseId: string, requirePublished: boolean = false) {
    return executeWithErrorHandling(
      () => prisma.course.findFirst({
        where: {
          id: courseId,
          ...(requirePublished && { isPublished: true })
        },
        select: {
          id: true,
          title: true,
          price: true,
          currency: true,
          isPublished: true,
          professorId: true
        }
      }),
      'Check course exists'
    );
  },

  /**
   * Check if enrollment exists
   */
  async checkEnrollmentExists(userId: string, courseId: string) {
    return executeWithErrorHandling(
      () => prisma.enrollment.findUnique({
        where: {
          userId_courseId: {
            userId,
            courseId
          }
        },
        select: {
          id: true,
          progressPercent: true,
          enrolledAt: true
        }
      }),
      'Check enrollment exists'
    );
  },

  /**
   * Check if category exists
   */
  async checkCategoryExists(categoryId: string) {
    return executeWithErrorHandling(
      () => prisma.category.findUnique({
        where: { id: categoryId },
        select: {
          id: true,
          name: true,
          isActive: true
        }
      }),
      'Check category exists'
    );
  }
};

#39: ./src/lib/api/payments.ts
--------------------------------------------------------------------------------
// src/lib/api/payments.ts
import { ApiResponse } from '@/lib/api-utils';

export interface Payment {
  id: string;
  status: 'PENDING' | 'COMPLETED' | 'FAILED' | 'REFUNDED';
  amount: number;
  currency: string;
  createdAt: string;
  updatedAt: string;
  paymobOrderId: string | null;
  paymobTxnId: string | null;
  course: {
    id: string;
    title: string;
    thumbnailUrl: string;
    professor: {
      name: string;
    };
  };
  isEnrolled?: boolean;
}

export interface PaymentInitiationResponse {
  paymentId: string;
  paymentKey?: string;
  iframeUrl?: string;
  orderId?: number;
  // Mobile wallet specific fields
  transactionId?: number;
  otpUrl?: string;
  walletProvider?: string;
  requiresOTP?: boolean;
  paymentMethod: 'credit-card' | 'e-wallet';
  amount: number;
  currency: string;
  course: {
    id: string;
    title: string;
    thumbnailUrl: string;
    professor: string;
  };
}

class PaymentsApi {
  private baseUrl = '/api/payments';

  /**
   * Initiate payment for a course
   */
  async initiatePayment(
    courseId: string, 
    paymentMethod: 'credit-card' | 'e-wallet' = 'credit-card',
    phoneNumber?: string
  ): Promise<PaymentInitiationResponse> {
    const response = await fetch(`${this.baseUrl}/initiate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ 
        courseId,
        paymentMethod,
        phoneNumber 
      }),
    });
    
    const data: ApiResponse<PaymentInitiationResponse> = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في بدء عملية الدفع');
    }
    
    return data.data!;
  }

  /**
   * Check payment status
   */
  async getPaymentStatus(paymentId: string): Promise<Payment> {
    const response = await fetch(`${this.baseUrl}/${paymentId}/status`);
    const data: ApiResponse<Payment> = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في جلب حالة الدفع');
    }
    
    return data.data!;
  }

  /**
   * Cancel a pending payment
   */
  async cancelPayment(paymentId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/${paymentId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ action: 'cancel' }),
    });
    
    const data: ApiResponse = await response.json();
    
    if (!data.success) {
      throw new Error(data.error?.message || 'فشل في إلغاء عملية الدفع');
    }
  }

  /**
   * Poll payment status until completion or timeout
   */
  async pollPaymentStatus(
    paymentId: string, 
    options: {
      maxAttempts?: number;
      intervalMs?: number;
      onStatusChange?: (status: Payment['status']) => void;
    } = {}
  ): Promise<Payment> {
    const { maxAttempts = 30, intervalMs = 2000, onStatusChange } = options;
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const payment = await this.getPaymentStatus(paymentId);
        
        if (onStatusChange) {
          onStatusChange(payment.status);
        }
        
        // If payment is no longer pending, return the result
        if (payment.status !== 'PENDING') {
          return payment;
        }
        
        // Wait before next attempt
        if (attempt < maxAttempts - 1) {
          await new Promise(resolve => setTimeout(resolve, intervalMs));
        }
      } catch (error) {
        console.error(`Payment status check attempt ${attempt + 1} failed:`, error);
        
        // If it's the last attempt, throw the error
        if (attempt === maxAttempts - 1) {
          throw error;
        }
        
        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, intervalMs));
      }
    }
    
    throw new Error('انتهت مهلة انتظار تأكيد الدفع');
  }

  /**
   * Format payment amount for display
   */
  formatAmount(payment: Payment): string {
    return new Intl.NumberFormat('ar-EG', {
      style: 'currency',
      currency: payment.currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }).format(payment.amount);
  }

  /**
   * Get payment status display text
   */
  getStatusText(status: Payment['status']): string {
    switch (status) {
      case 'PENDING':
        return 'في الانتظار';
      case 'COMPLETED':
        return 'مكتمل';
      case 'FAILED':
        return 'فشل';
      case 'REFUNDED':
        return 'مسترد';
      default:
        return 'غير معروف';
    }
  }

  /**
   * Get payment status color for UI
   */
  getStatusColor(status: Payment['status']): string {
    switch (status) {
      case 'PENDING':
        return 'text-yellow-600 bg-yellow-50 border-yellow-200';
      case 'COMPLETED':
        return 'text-green-600 bg-green-50 border-green-200';
      case 'FAILED':
        return 'text-red-600 bg-red-50 border-red-200';
      case 'REFUNDED':
        return 'text-blue-600 bg-blue-50 border-blue-200';
      default:
        return 'text-gray-600 bg-gray-50 border-gray-200';
    }
  }

  /**
   * Create PayMob iframe for payment
   */
  createPaymentIframe(iframeUrl: string, containerId: string): HTMLIFrameElement {
    const iframe = document.createElement('iframe');
    iframe.src = iframeUrl;
    iframe.width = '100%';
    iframe.height = '600';
    iframe.frameBorder = '0';
    iframe.style.border = 'none';
    iframe.style.borderRadius = '8px';
    
    const container = document.getElementById(containerId);
    if (container) {
      container.innerHTML = '';
      container.appendChild(iframe);
    }
    
    return iframe;
  }

  /**
   * Listen for payment completion messages from iframe
   */
  listenForPaymentCompletion(
    onSuccess: (data: any) => void,
    onError: (error: any) => void
  ): () => void {
    const messageHandler = (event: MessageEvent) => {
      // Verify origin for security
      if (!event.origin.includes('paymob.com')) {
        return;
      }
      
      try {
        const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
        
        if (data.type === 'payment_success') {
          onSuccess(data);
        } else if (data.type === 'payment_error') {
          onError(data);
        }
      } catch (error) {
        console.error('Error parsing payment message:', error);
      }
    };
    
    window.addEventListener('message', messageHandler);
    
    // Return cleanup function
    return () => {
      window.removeEventListener('message', messageHandler);
    };
  }

  /**
   * Validate payment data before initiation
   */
  validatePaymentData(courseId: string): string[] {
    const errors: string[] = [];
    
    if (!courseId || courseId.trim().length === 0) {
      errors.push('معرف الدورة مطلوب');
    }
    
    return errors;
  }

  /**
   * Handle payment errors with user-friendly messages
   */
  handlePaymentError(error: any): string {
    if (error instanceof Error) {
      const message = error.message;
      
      // Map common error messages to Arabic
      if (message.includes('already enrolled')) {
        return 'أنت مسجل في هذه الدورة بالفعل';
      }
      if (message.includes('free course')) {
        return 'هذه الدورة مجانية ولا تحتاج لدفع';
      }
      if (message.includes('pending payment')) {
        return 'لديك عملية دفع معلقة لهذه الدورة';
      }
      if (message.includes('own course')) {
        return 'لا يمكنك شراء دورتك الخاصة';
      }
      if (message.includes('not published')) {
        return 'الدورة غير منشورة حالياً';
      }
      if (message.includes('payment gateway')) {
        return 'حدث خطأ في نظام الدفع. يرجى المحاولة مرة أخرى';
      }
      
      return message;
    }
    
    return 'حدث خطأ غير متوقع';
  }
}

export const paymentsApi = new PaymentsApi();

#40: ./src/lib/api/query-builders.ts
--------------------------------------------------------------------------------
// src/lib/api/query-builders.ts
// Consolidated query building utilities for API routes

import { Prisma } from '@prisma/client';
import { NextRequest } from 'next/server';

/**
 * Common search filters
 */
export interface SearchFilters {
  search?: string;
  dateFrom?: string;
  dateTo?: string;
  status?: string;
  category?: string;
  includeInactive?: boolean;
}

/**
 * Extract search filters from request
 */
export function extractSearchFilters(request: NextRequest): SearchFilters {
  const { searchParams } = new URL(request.url);
  
  return {
    search: searchParams.get('search') || undefined,
    dateFrom: searchParams.get('dateFrom') || undefined,
    dateTo: searchParams.get('dateTo') || undefined,
    status: searchParams.get('status') || undefined,
    category: searchParams.get('category') || undefined,
    includeInactive: searchParams.get('includeInactive') === 'true'
  };
}

/**
 * Build date range filter
 */
export function buildDateRangeFilter(dateFrom?: string, dateTo?: string): Prisma.DateTimeFilter | undefined {
  if (!dateFrom && !dateTo) return undefined;
  
  const filter: Prisma.DateTimeFilter = {};
  
  if (dateFrom) {
    filter.gte = new Date(dateFrom);
  }
  
  if (dateTo) {
    filter.lte = new Date(dateTo + 'T23:59:59.999Z');
  }
  
  return filter;
}

/**
 * Build text search filter for multiple fields
 */
export function buildTextSearchFilter(
  search: string,
  fields: string[]
): any[] {
  return fields.map(field => ({
    [field]: {
      contains: search,
      mode: 'insensitive' as const
    }
  }));
}

/**
 * Build user search where clause
 */
export function buildUserSearchWhere(filters: SearchFilters): Prisma.UserWhereInput {
  const where: Prisma.UserWhereInput = {};
  
  if (filters.search) {
    where.OR = buildTextSearchFilter(filters.search, ['name', 'email', 'phone', 'studentId']) as any;
  }
  
  if (!filters.includeInactive) {
    where.isActive = true;
  }
  
  if (filters.dateFrom || filters.dateTo) {
    where.createdAt = buildDateRangeFilter(filters.dateFrom, filters.dateTo);
  }
  
  return where;
}

/**
 * Build course search where clause
 */
export function buildCourseSearchWhere(filters: SearchFilters): Prisma.CourseWhereInput {
  const where: Prisma.CourseWhereInput = {};
  
  if (filters.search) {
    where.OR = buildTextSearchFilter(filters.search, ['title', 'description']) as any;
  }
  
  if (filters.category) {
    where.categoryId = filters.category;
  }
  
  if (filters.status === 'published') {
    where.isPublished = true;
  } else if (filters.status === 'draft') {
    where.isPublished = false;
  }
  
  if (filters.dateFrom || filters.dateTo) {
    where.createdAt = buildDateRangeFilter(filters.dateFrom, filters.dateTo);
  }
  
  return where;
}

/**
 * Build payment search where clause
 */
export function buildPaymentSearchWhere(filters: SearchFilters): Prisma.PaymentWhereInput {
  const where: Prisma.PaymentWhereInput = {};
  
  if (filters.status && filters.status !== 'all') {
    where.status = filters.status.toUpperCase() as any;
  }
  
  if (filters.search) {
    where.OR = [
      {
        course: {
          title: {
            contains: filters.search,
            mode: 'insensitive'
          }
        }
      },
      {
        user: {
          name: {
            contains: filters.search,
            mode: 'insensitive'
          }
        }
      },
      {
        paymobOrderId: {
          contains: filters.search,
          mode: 'insensitive'
        }
      }
    ];

    // Add transaction ID search if it's a number
    const transactionId = parseInt(filters.search);
    if (!isNaN(transactionId)) {
      where.OR.push({
        paymobTransactionId: BigInt(transactionId)
      });
    }
  }
  
  if (filters.dateFrom || filters.dateTo) {
    where.createdAt = buildDateRangeFilter(filters.dateFrom, filters.dateTo);
  }
  
  return where;
}

#41: ./src/lib/api/validation.ts
--------------------------------------------------------------------------------
// src/lib/api/validation.ts
// Consolidated validation utilities for API routes

import { z } from 'zod';
import { createErrorResponse, ApiErrors } from '@/lib/api-response';

/**
 * Common validation schemas
 */
export const commonSchemas = {
  id: z.string().min(1, 'المعرف مطلوب'),
  email: z.string().email('البريد الإلكتروني غير صحيح').optional(),
  phone: z.string().min(10, 'رقم الهاتف غير صحيح'),
  name: z.string().min(1, 'الاسم مطلوب').max(100, 'الاسم طويل جداً'),
  description: z.string().min(1, 'الوصف مطلوب').max(1000, 'الوصف طويل جداً'),
  url: z.string().url('الرابط غير صحيح').optional().or(z.literal('')),
  price: z.number().min(0, 'السعر يجب أن يكون أكبر من أو يساوي صفر').optional(),
  currency: z.string().default('EGP'),
  boolean: z.boolean().default(false)
};

/**
 * Category validation schema
 */
export const categorySchema = z.object({
  name: z.string().min(1, 'اسم الفئة مطلوب').max(100, 'اسم الفئة طويل جداً'),
  description: z.string().min(1, 'وصف الفئة مطلوب').max(500, 'وصف الفئة طويل جداً'),
  iconUrl: commonSchemas.url,
  slug: z.string().min(1, 'الرابط المختصر مطلوب').max(50, 'الرابط المختصر طويل جداً')
    .regex(/^[a-z0-9-]+$/, 'الرابط المختصر يجب أن يحتوي على أحرف إنجليزية صغيرة وأرقام وشرطات فقط')
});

/**
 * Course validation schema
 */
export const courseSchema = z.object({
  title: commonSchemas.name,
  description: commonSchemas.description,
  categoryId: commonSchemas.id,
  professorId: commonSchemas.id,
  price: commonSchemas.price,
  currency: commonSchemas.currency,
  thumbnailUrl: z.string().min(1, 'رابط الصورة مطلوب'),
  bunnyLibraryId: z.string().min(1, 'معرف مكتبة Bunny مطلوب'),
  isPublished: commonSchemas.boolean
});

/**
 * Payment initiation validation schema
 */
export const paymentInitiateSchema = z.object({
  courseId: commonSchemas.id,
  paymentMethod: z.enum(['credit-card', 'e-wallet']).default('credit-card'),
  phoneNumber: z.string().optional()
});

/**
 * Validate request body against schema
 */
export async function validateRequestBody<T>(
  request: Request,
  schema: z.ZodSchema<T>
): Promise<T | ReturnType<typeof createErrorResponse>> {
  try {
    const body = await request.json();
    const validationResult = schema.safeParse(body);

    if (!validationResult.success) {
      return createErrorResponse(
        ApiErrors.VALIDATION_ERROR.code,
        ApiErrors.VALIDATION_ERROR.message,
        ApiErrors.VALIDATION_ERROR.status,
        validationResult.error.issues
      );
    }

    return validationResult.data;
  } catch (error) {
    return createErrorResponse(
      ApiErrors.VALIDATION_ERROR.code,
      'البيانات المرسلة غير صحيحة',
      ApiErrors.VALIDATION_ERROR.status
    );
  }
}

/**
 * Check if validation result is an error
 */
export function isValidationError(result: any): result is ReturnType<typeof createErrorResponse> {
  return result && typeof result.json === 'function';
}

#42: ./src/lib/api-response.ts
--------------------------------------------------------------------------------
// src/lib/api-response.ts
// Unified API response system to eliminate duplication

import { NextResponse } from 'next/server';

/**
 * Unified API response interface
 */
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  message?: string;
  timestamp: string;
  requestId?: string;
}

/**
 * Create a standardized success response
 */
export function createSuccessResponse<T>(
  data: T, 
  message?: string, 
  status: number = 200
): NextResponse<ApiResponse<T>> {
  const response: ApiResponse<T> = {
    success: true,
    data,
    message,
    timestamp: new Date().toISOString()
  };
  
  return NextResponse.json(response, { status });
}

/**
 * Create a standardized error response
 */
export function createErrorResponse(
  code: string,
  message: string,
  status: number = 500,
  details?: any,
  requestId?: string
): NextResponse<ApiResponse> {
  const response: ApiResponse = {
    success: false,
    error: {
      code,
      message,
      details: process.env.NODE_ENV === 'development' ? details : undefined
    },
    timestamp: new Date().toISOString(),
    requestId
  };
  
  return NextResponse.json(response, { status });
}

/**
 * Comprehensive error codes for all API operations
 */
export const API_ERROR_CODES = {
  // Authentication & Authorization
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  INVALID_TOKEN: 'INVALID_TOKEN',

  // Validation
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  INVALID_PAYLOAD: 'INVALID_PAYLOAD',
  MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',

  // Payment Specific
  PAYMENT_GATEWAY_ERROR: 'PAYMENT_GATEWAY_ERROR',
  PAYMENT_NOT_FOUND: 'PAYMENT_NOT_FOUND',
  PAYMENT_ALREADY_PROCESSED: 'PAYMENT_ALREADY_PROCESSED',
  PAYMENT_EXPIRED: 'PAYMENT_EXPIRED',
  INVALID_PAYMENT_METHOD: 'INVALID_PAYMENT_METHOD',
  INSUFFICIENT_FUNDS: 'INSUFFICIENT_FUNDS',
  DUPLICATE_TRANSACTION: 'DUPLICATE_TRANSACTION',

  // Webhook Specific
  WEBHOOK_SIGNATURE_INVALID: 'WEBHOOK_SIGNATURE_INVALID',
  WEBHOOK_PAYLOAD_INVALID: 'WEBHOOK_PAYLOAD_INVALID',
  WEBHOOK_ALREADY_PROCESSED: 'WEBHOOK_ALREADY_PROCESSED',

  // Course & Enrollment
  COURSE_NOT_FOUND: 'COURSE_NOT_FOUND',
  COURSE_NOT_PUBLISHED: 'COURSE_NOT_PUBLISHED',
  ALREADY_ENROLLED: 'ALREADY_ENROLLED',
  ENROLLMENT_FAILED: 'ENROLLMENT_FAILED',
  ENROLLMENT_NOT_ALLOWED: 'ENROLLMENT_NOT_ALLOWED',
  PAYMENT_REQUIRED: 'PAYMENT_REQUIRED',

  // Database
  DATABASE_ERROR: 'DATABASE_ERROR',
  TRANSACTION_FAILED: 'TRANSACTION_FAILED',
  
  // General
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  RATE_LIMITED: 'RATE_LIMITED',
  MAINTENANCE_MODE: 'MAINTENANCE_MODE',
  DUPLICATE_ERROR: 'DUPLICATE_ERROR'
} as const;

/**
 * User-friendly Arabic error messages
 */
export const ERROR_MESSAGES = {
  // Authentication & Authorization
  [API_ERROR_CODES.UNAUTHORIZED]: 'يجب تسجيل الدخول للوصول لهذه الخدمة',
  [API_ERROR_CODES.FORBIDDEN]: 'غير مصرح لك بالوصول لهذه الخدمة',
  [API_ERROR_CODES.INVALID_TOKEN]: 'الرمز المميز غير صحيح',

  // Validation
  [API_ERROR_CODES.VALIDATION_ERROR]: 'البيانات المُدخلة غير صحيحة',
  [API_ERROR_CODES.INVALID_PAYLOAD]: 'البيانات المرسلة غير صحيحة',
  [API_ERROR_CODES.MISSING_REQUIRED_FIELD]: 'بيانات مطلوبة مفقودة',

  // Payment Specific
  [API_ERROR_CODES.PAYMENT_GATEWAY_ERROR]: 'حدث خطأ في نظام الدفع. يرجى المحاولة مرة أخرى',
  [API_ERROR_CODES.PAYMENT_NOT_FOUND]: 'عملية الدفع غير موجودة',
  [API_ERROR_CODES.PAYMENT_ALREADY_PROCESSED]: 'عملية الدفع تمت معالجتها مسبقاً',
  [API_ERROR_CODES.PAYMENT_EXPIRED]: 'انتهت صلاحية عملية الدفع',
  [API_ERROR_CODES.INVALID_PAYMENT_METHOD]: 'طريقة الدفع غير صحيحة',
  [API_ERROR_CODES.INSUFFICIENT_FUNDS]: 'الرصيد غير كافي',
  [API_ERROR_CODES.DUPLICATE_TRANSACTION]: 'عملية الدفع تمت معالجتها مسبقاً',

  // Webhook Specific
  [API_ERROR_CODES.WEBHOOK_SIGNATURE_INVALID]: 'توقيع الويب هوك غير صحيح',
  [API_ERROR_CODES.WEBHOOK_PAYLOAD_INVALID]: 'بيانات الويب هوك غير صحيحة',
  [API_ERROR_CODES.WEBHOOK_ALREADY_PROCESSED]: 'الويب هوك تم معالجته مسبقاً',

  // Course & Enrollment
  [API_ERROR_CODES.COURSE_NOT_FOUND]: 'الدورة غير موجودة',
  [API_ERROR_CODES.COURSE_NOT_PUBLISHED]: 'الدورة غير منشورة',
  [API_ERROR_CODES.ALREADY_ENROLLED]: 'أنت مسجل في هذه الدورة بالفعل',
  [API_ERROR_CODES.ENROLLMENT_FAILED]: 'فشل في التسجيل بالدورة',
  [API_ERROR_CODES.ENROLLMENT_NOT_ALLOWED]: 'التسجيل غير مسموح',
  [API_ERROR_CODES.PAYMENT_REQUIRED]: 'هذه الدورة مدفوعة. يجب إتمام الدفع أولاً',

  // Database
  [API_ERROR_CODES.DATABASE_ERROR]: 'حدث خطأ في قاعدة البيانات',
  [API_ERROR_CODES.TRANSACTION_FAILED]: 'فشلت العملية',

  // General
  [API_ERROR_CODES.INTERNAL_ERROR]: 'حدث خطأ داخلي. يرجى المحاولة لاحقاً',
  [API_ERROR_CODES.NOT_FOUND]: 'العنصر غير موجود',
  [API_ERROR_CODES.RATE_LIMITED]: 'تم تجاوز الحد المسموح من الطلبات',
  [API_ERROR_CODES.MAINTENANCE_MODE]: 'الموقع في وضع الصيانة حالياً',
  [API_ERROR_CODES.DUPLICATE_ERROR]: 'البيانات موجودة بالفعل'
} as const;

/**
 * Get user-friendly message for error code
 */
export function getErrorMessage(code: keyof typeof API_ERROR_CODES): string {
  return ERROR_MESSAGES[code] || ERROR_MESSAGES.INTERNAL_ERROR;
}

/**
 * Handle API errors with consistent formatting
 */
export function handleApiError(error: any, context: string = 'API'): NextResponse {
  console.error(`${context} error:`, error);
  
  return createErrorResponse(
    API_ERROR_CODES.INTERNAL_ERROR,
    ERROR_MESSAGES.INTERNAL_ERROR,
    500,
    error
  );
}

/**
 * Predefined error responses for common scenarios
 */
export const ApiErrors = {
  UNAUTHORIZED: { 
    code: API_ERROR_CODES.UNAUTHORIZED, 
    message: ERROR_MESSAGES.UNAUTHORIZED, 
    status: 401,
    create: () => createErrorResponse(API_ERROR_CODES.UNAUTHORIZED, ERROR_MESSAGES.UNAUTHORIZED, 401)
  },
  FORBIDDEN: { 
    code: API_ERROR_CODES.FORBIDDEN, 
    message: ERROR_MESSAGES.FORBIDDEN, 
    status: 403,
    create: () => createErrorResponse(API_ERROR_CODES.FORBIDDEN, ERROR_MESSAGES.FORBIDDEN, 403)
  },
  NOT_FOUND: { 
    code: API_ERROR_CODES.NOT_FOUND, 
    message: ERROR_MESSAGES.NOT_FOUND, 
    status: 404,
    create: () => createErrorResponse(API_ERROR_CODES.NOT_FOUND, ERROR_MESSAGES.NOT_FOUND, 404)
  },
  VALIDATION_ERROR: { 
    code: API_ERROR_CODES.VALIDATION_ERROR, 
    message: ERROR_MESSAGES.VALIDATION_ERROR, 
    status: 400,
    create: (details?: any) => createErrorResponse(API_ERROR_CODES.VALIDATION_ERROR, ERROR_MESSAGES.VALIDATION_ERROR, 400, details)
  },
  DUPLICATE_ERROR: { 
    code: API_ERROR_CODES.DUPLICATE_ERROR, 
    message: ERROR_MESSAGES.DUPLICATE_ERROR, 
    status: 409,
    create: () => createErrorResponse(API_ERROR_CODES.DUPLICATE_ERROR, ERROR_MESSAGES.DUPLICATE_ERROR, 409)
  },
  INTERNAL_ERROR: { 
    code: API_ERROR_CODES.INTERNAL_ERROR, 
    message: ERROR_MESSAGES.INTERNAL_ERROR, 
    status: 500,
    create: (details?: any) => createErrorResponse(API_ERROR_CODES.INTERNAL_ERROR, ERROR_MESSAGES.INTERNAL_ERROR, 500, details)
  }
};

#43: ./src/lib/auth-utils.ts
--------------------------------------------------------------------------------
// src/lib/auth-utils.ts
import { UserRole } from "@prisma/client";
import { Session } from "next-auth";

/**
 * Utility functions for role-based access control
 */

export function hasRole(session: Session | null, role: UserRole): boolean {
  return session?.user?.role === role;
}

export function isAdmin(session: Session | null): boolean {
  return hasRole(session, 'ADMIN');
}

export function isProfessor(session: Session | null): boolean {
  return hasRole(session, 'PROFESSOR');
}

export function isStudent(session: Session | null): boolean {
  return hasRole(session, 'STUDENT');
}

export function canManageUsers(session: Session | null): boolean {
  return isAdmin(session);
}

export function canManageCategories(session: Session | null): boolean {
  return isAdmin(session);
}

export function canCreateCourses(session: Session | null): boolean {
  return isAdmin(session) || isProfessor(session);
}

export function canManageCourse(session: Session | null, courseOwnerId?: string): boolean {
  if (isAdmin(session)) return true;
  if (isProfessor(session) && courseOwnerId === session?.user?.id) return true;
  return false;
}

export function canViewAnalytics(session: Session | null, resourceOwnerId?: string): boolean {
  if (isAdmin(session)) return true;
  if (isProfessor(session) && resourceOwnerId === session?.user?.id) return true;
  return false;
}

export function canEnrollInCourses(session: Session | null): boolean {
  return isStudent(session) || isAdmin(session); // Admins can enroll for testing
}

export function getDashboardPath(role: UserRole): string {
  switch (role) {
    case 'ADMIN':
      return '/admin';
    case 'PROFESSOR':
      return '/professor';
    case 'STUDENT':
      return '/profile';
    default:
      return '/profile';
  }
}

export function getRoleDisplayName(role: UserRole): string {
  switch (role) {
    case 'ADMIN':
      return 'مدير النظام';
    case 'PROFESSOR':
      return 'أستاذ';
    case 'STUDENT':
      return 'ملتحق';
    default:
      return 'مستخدم';
  }
}

/**
 * Higher-order function to protect API routes based on roles
 * Note: This is a template - you'll need to import the appropriate auth function
 */
export function withAuth(allowedRoles: UserRole[]) {
  return function (handler: Function) {
    return async function (req: any, res: any, ...args: any[]) {
      // TODO: Import and use the appropriate session getter
      // const session = await getServerSession(req, res, authOptions);
      
      // For now, this is a placeholder - implement based on your auth setup
      throw new Error('withAuth function needs to be implemented with proper session handling');
    };
  };
}

/**
 * Check if user can access a specific resource
 */
export function canAccessResource(
  session: Session | null,
  resourceType: 'course' | 'category' | 'user' | 'payment',
  action: 'create' | 'read' | 'update' | 'delete',
  resourceOwnerId?: string
): boolean {
  if (!session) return false;

  const { role } = session.user;

  // Admin can do everything
  if (role === 'ADMIN') return true;

  switch (resourceType) {
    case 'course':
      if (action === 'create') return role === 'PROFESSOR';
      if (action === 'read') return true; // Everyone can read published courses
      if (action === 'update' || action === 'delete') {
        return role === 'PROFESSOR' && resourceOwnerId === session.user.id;
      }
      break;

    case 'category':
      if (action === 'read') return true; // Everyone can read categories
      return false; // Only admins can manage categories (handled above)

    case 'user':
      if (action === 'read' && resourceOwnerId === session.user.id) return true;
      if (action === 'update' && resourceOwnerId === session.user.id) return true;
      return false; // Only admins can manage other users

    case 'payment':
      if (action === 'create') return role === 'STUDENT';
      if (action === 'read' && resourceOwnerId === session.user.id) return true;
      return false;
  }

  return false;
}

#44: ./src/lib/certificate.ts
--------------------------------------------------------------------------------
// src/lib/certificate.ts
import prisma from '@/lib/prisma';

// Certificate generation utilities
export interface CertificateData {
  id: string;
  certificateCode: string;
  studentName: string;
  courseName: string;
  professorName: string;
  completionDate: Date;
  finalScore?: number;
  validUntil?: Date;
  courseCategory: string;
  courseDuration: number; // in minutes
  totalLessons: number;
}

/**
 * Generate a unique certificate code
 */
function generateCertificateCode(): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 8);
  return `CERT-${timestamp}-${random}`.toUpperCase();
}

/**
 * Check if user is eligible for certificate
 */
export async function checkCertificateEligibility(
  userId: string,
  courseId: string
): Promise<{
  eligible: boolean;
  reason?: string;
  completionRate: number;
  requiredRate: number;
}> {
  try {
    // Get course and enrollment data
    const [course, enrollment] = await Promise.all([
      prisma.course.findUnique({
        where: { id: courseId },
        include: {
          lessons: {
            select: { id: true }
          }
        }
      }),
      prisma.enrollment.findUnique({
        where: {
          userId_courseId: {
            userId,
            courseId
          }
        }
      })
    ]);

    if (!course || !enrollment) {
      return {
        eligible: false,
        reason: 'Course or enrollment not found',
        completionRate: 0,
        requiredRate: 90
      };
    }

    const requiredRate = 90; // 90% completion required
    const completionRate = enrollment.progressPercent;

    if (completionRate < requiredRate) {
      return {
        eligible: false,
        reason: `Completion rate ${completionRate}% is below required ${requiredRate}%`,
        completionRate,
        requiredRate
      };
    }

    // Check if certificate already exists
    const existingCertificate = await prisma.certificate.findUnique({
      where: {
        userId_courseId: {
          userId,
          courseId
        }
      }
    });

    if (existingCertificate && !existingCertificate.isRevoked) {
      return {
        eligible: false,
        reason: 'Certificate already issued',
        completionRate,
        requiredRate
      };
    }

    return {
      eligible: true,
      completionRate,
      requiredRate
    };

  } catch (error) {
    console.error('Error checking certificate eligibility:', error);
    return {
      eligible: false,
      reason: 'Error checking eligibility',
      completionRate: 0,
      requiredRate: 90
    };
  }
}

/**
 * Generate certificate for a user
 */
export async function generateCertificate(
  userId: string,
  courseId: string
): Promise<{
  success: boolean;
  certificate?: CertificateData;
  error?: string;
}> {
  try {
    // Check eligibility first
    const eligibility = await checkCertificateEligibility(userId, courseId);
    
    if (!eligibility.eligible) {
      return {
        success: false,
        error: eligibility.reason || 'Not eligible for certificate'
      };
    }

    // Get detailed course and user data
    const [course, user, enrollment] = await Promise.all([
      prisma.course.findUnique({
        where: { id: courseId },
        include: {
          professor: {
            select: { name: true }
          },
          category: {
            select: { name: true }
          },
          lessons: {
            select: { duration: true }
          }
        }
      }),
      prisma.user.findUnique({
        where: { id: userId },
        select: { name: true }
      }),
      prisma.enrollment.findUnique({
        where: {
          userId_courseId: {
            userId,
            courseId
          }
        }
      })
    ]);

    if (!course || !user || !enrollment) {
      return {
        success: false,
        error: 'Required data not found'
      };
    }

    // Calculate course duration
    const courseDuration = course.lessons.reduce(
      (total, lesson) => total + (lesson.duration || 0),
      0
    ) / 60; // Convert to minutes

    // Generate certificate
    const certificateCode = generateCertificateCode();
    const validUntil = new Date();
    validUntil.setFullYear(validUntil.getFullYear() + 2); // Valid for 2 years

    const certificate = await prisma.certificate.create({
      data: {
        userId,
        courseId,
        certificateCode,
        validUntil,
        studentName: user.name,
        courseName: course.title,
        professorName: course.professor.name,
        completionDate: new Date()
      }
    });

    // Record milestone achievement
    await prisma.progressMilestone.create({
      data: {
        userId,
        courseId,
        milestoneType: 'COURSE_COMPLETE' as any,
        metadata: {
          certificateCode,
          completionRate: enrollment.progressPercent
        }
      }
    });

    const certificateData: CertificateData = {
      id: certificate.id,
      certificateCode: certificate.certificateCode,
      studentName: user.name,
      courseName: course.title,
      professorName: course.professor.name,
      completionDate: certificate.completionDate,
      validUntil: certificate.validUntil || undefined,
      courseCategory: course.category.name,
      courseDuration,
      totalLessons: course.lessons.length
    };

    return {
      success: true,
      certificate: certificateData
    };

  } catch (error) {
    console.error('Error generating certificate:', error);
    return {
      success: false,
      error: 'Failed to generate certificate'
    };
  }
}/*
*
 * Get certificate by code (for verification)
 */
export async function verifyCertificate(certificateCode: string): Promise<{
  valid: boolean;
  certificate?: CertificateData;
  error?: string;
}> {
  try {
    const certificate = await prisma.certificate.findUnique({
      where: { certificateCode },
      include: {
        user: {
          select: { name: true }
        },
        course: {
          include: {
            professor: {
              select: { name: true }
            },
            category: {
              select: { name: true }
            },
            lessons: {
              select: { duration: true }
            }
          }
        }
      }
    });

    if (!certificate) {
      return {
        valid: false,
        error: 'Certificate not found'
      };
    }

    if (certificate.isRevoked) {
      return {
        valid: false,
        error: 'Certificate has been revoked'
      };
    }

    if (certificate.validUntil && certificate.validUntil < new Date()) {
      return {
        valid: false,
        error: 'Certificate has expired'
      };
    }

    const courseDuration = certificate.course.lessons.reduce(
      (total, lesson) => total + (lesson.duration || 0),
      0
    ) / 60;

    const certificateData: CertificateData = {
      id: certificate.id,
      certificateCode: certificate.certificateCode,
      studentName: certificate.user.name,
      courseName: certificate.course.title,
      professorName: certificate.course.professor.name,
      completionDate: certificate.completionDate,
      validUntil: certificate.validUntil || undefined,
      courseCategory: certificate.course.category.name,
      courseDuration,
      totalLessons: certificate.course.lessons.length
    };

    return {
      valid: true,
      certificate: certificateData
    };

  } catch (error) {
    console.error('Error verifying certificate:', error);
    return {
      valid: false,
      error: 'Error verifying certificate'
    };
  }
}

/**
 * Get user's certificates
 */
export async function getUserCertificates(userId: string): Promise<CertificateData[]> {
  try {
    const certificates = await prisma.certificate.findMany({
      where: {
        userId,
        isRevoked: false
      },
      include: {
        user: {
          select: { name: true }
        },
        course: {
          include: {
            professor: {
              select: { name: true }
            },
            category: {
              select: { name: true }
            },
            lessons: {
              select: { duration: true }
            }
          }
        }
      },
      orderBy: {
        completionDate: 'desc'
      }
    });

    return certificates.map(certificate => {
      const courseDuration = certificate.course.lessons.reduce(
        (total, lesson) => total + (lesson.duration || 0),
        0
      ) / 60;

      return {
        id: certificate.id,
        certificateCode: certificate.certificateCode,
        studentName: certificate.user.name,
        courseName: certificate.course.title,
        professorName: certificate.course.professor.name,
        completionDate: certificate.completionDate,
        grade: certificate.grade || undefined,
        validUntil: certificate.validUntil || undefined,
        courseCategory: certificate.course.category.name,
        courseDuration,
        totalLessons: certificate.course.lessons.length
      };
    });

  } catch (error) {
    console.error('Error getting user certificates:', error);
    return [];
  }
}

/**
 * Record progress milestone
 */
export async function recordProgressMilestone(
  userId: string,
  courseId: string,
  milestoneType: any,
  metadata?: any
): Promise<boolean> {
  try {
    await prisma.progressMilestone.upsert({
      where: {
        userId_courseId_milestoneType: {
          userId,
          courseId,
          milestoneType
        }
      },
      update: {
        metadata
      },
      create: {
        userId,
        courseId,
        milestoneType,
        metadata
      }
    });

    return true;
  } catch (error) {
    console.error('Error recording progress milestone:', error);
    return false;
  }
}

#45: ./src/lib/course-utils.ts
--------------------------------------------------------------------------------
// src/lib/course-utils.ts
// Utility functions for course-related operations

import { UserRole } from '@prisma/client';
import { CourseWithMetadata, CourseUserActions, CourseFilters } from '@/types/course';

/**
 * Calculate course duration in minutes from lessons
 */
export function calculateCourseDuration(lessons: { duration: number | null }[]): number {
  return Math.round(
    lessons.reduce((total, lesson) => total + (lesson.duration || 0), 0) / 60
  );
}

/**
 * Calculate course progress percentage
 */
export function calculateCourseProgress(
  totalLessons: number,
  completedLessons: number
): number {
  if (totalLessons === 0) return 0;
  return Math.round((completedLessons / totalLessons) * 100);
}

/**
 * Format course duration for display
 */
export function formatCourseDuration(minutes: number): string {
  if (minutes < 60) {
    return `${minutes} دقيقة`;
  }
  
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  
  if (remainingMinutes === 0) {
    return `${hours} ساعة`;
  }
  
  return `${hours} ساعة و ${remainingMinutes} دقيقة`;
}

/**
 * Format course price for display
 */
export function formatCoursePrice(price: number | null, currency: string = 'EGP'): string {
  if (price === null || price === 0) {
    return 'مجاني';
  }
  
  return `${price.toLocaleString('ar-EG')} ${currency}`;
}

/**
 * Determine user actions for a course based on role and enrollment status
 */
export function getCourseUserActions(
  course: CourseWithMetadata,
  userRole?: UserRole,
  userId?: string
): CourseUserActions {
  const isOwner = userId === course.professor.id;
  const isEnrolled = course.isEnrolled || false;
  
  return {
    canEnroll: !isEnrolled && userRole === 'STUDENT' && course.isPublished,
    canEdit: isOwner || userRole === 'ADMIN',
    canManage: userRole === 'ADMIN',
    isOwner,
    isEnrolled
  };
}

/**
 * Get course status based on progress
 */
export function getCourseStatus(progress: number): 'not_started' | 'in_progress' | 'completed' {
  if (progress === 0) return 'not_started';
  if (progress === 100) return 'completed';
  return 'in_progress';
}

/**
 * Build Prisma where clause for course filtering
 */
export function buildCourseWhereClause(
  filters: CourseFilters,
  excludeEnrolledCourses?: string[]
) {
  const where: any = {
    isPublished: true
  };

  // Exclude enrolled courses if provided
  if (excludeEnrolledCourses && excludeEnrolledCourses.length > 0) {
    where.id = { notIn: excludeEnrolledCourses };
  }

  // Category filter
  if (filters.category && filters.category !== 'all') {
    where.categoryId = filters.category;
  }

  // Price filter
  if (filters.priceRange && filters.priceRange !== 'all') {
    if (filters.priceRange === 'free') {
      where.OR = [
        { price: null },
        { price: 0 }
      ];
    } else if (filters.priceRange === 'paid') {
      where.price = { gt: 0 };
    }
  }

  // Search filter
  if (filters.search) {
    where.OR = [
      { title: { contains: filters.search, mode: 'insensitive' } },
      { description: { contains: filters.search, mode: 'insensitive' } },
      {
        professor: {
          name: { contains: filters.search, mode: 'insensitive' }
        }
      },
      {
        category: {
          name: { contains: filters.search, mode: 'insensitive' }
        }
      }
    ];
  }

  return where;
}

/**
 * Get course sort order based on sort parameter
 */
export function getCourseSortOrder(sort?: string) {
  switch (sort) {
    case 'newest':
      return { createdAt: 'desc' as const };
    case 'oldest':
      return { createdAt: 'asc' as const };
    case 'title':
      return { title: 'asc' as const };
    case 'price_low':
      return { price: 'asc' as const };
    case 'price_high':
      return { price: 'desc' as const };
    default:
      return { createdAt: 'desc' as const };
  }
}

/**
 * Calculate pagination values
 */
export function calculatePagination(
  totalCount: number,
  page: number = 1,
  limit: number = 12
) {
  const totalPages = Math.ceil(totalCount / limit);
  const hasNextPage = page < totalPages;
  const hasPreviousPage = page > 1;
  const skip = (page - 1) * limit;

  return {
    totalPages,
    hasNextPage,
    hasPreviousPage,
    skip,
    take: limit
  };
}

/**
 * Validate course filters
 */
export function validateCourseFilters(filters: any): CourseFilters {
  return {
    category: typeof filters.category === 'string' ? filters.category : undefined,
    priceRange: ['free', 'paid', 'all'].includes(filters.priceRange) 
      ? filters.priceRange 
      : 'all',
    level: ['beginner', 'intermediate', 'advanced', 'all'].includes(filters.level)
      ? filters.level
      : 'all',
    duration: ['short', 'medium', 'long', 'all'].includes(filters.duration)
      ? filters.duration
      : 'all',
    rating: typeof filters.rating === 'number' && filters.rating >= 1 && filters.rating <= 5
      ? filters.rating
      : undefined,
    search: typeof filters.search === 'string' && filters.search.length > 0
      ? filters.search.trim()
      : undefined
  };
}

/**
 * Generate course slug from title
 */
export function generateCourseSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // Remove special characters
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-') // Replace multiple hyphens with single
    .trim();
}

/**
 * Check if user can access course
 */
export function canUserAccessCourse(
  course: CourseWithMetadata,
  userRole?: UserRole,
  userId?: string
): boolean {
  // Public courses are accessible to everyone
  if (!course.isPublished) {
    // Unpublished courses only accessible to owner and admin
    return userId === course.professor.id || userRole === 'ADMIN';
  }

  return true;
}

/**
 * Get course difficulty level based on metadata
 */
export function getCourseDifficultyLevel(
  lessonCount: number,
  duration: number
): 'beginner' | 'intermediate' | 'advanced' {
  if (lessonCount <= 5 && duration <= 120) return 'beginner';
  if (lessonCount <= 15 && duration <= 480) return 'intermediate';
  return 'advanced';
}

/**
 * Calculate course completion time estimate
 */
export function estimateCompletionTime(totalDuration: number): string {
  const days = Math.ceil(totalDuration / 120); // Assuming 2 hours per day
  
  if (days === 1) return 'يوم واحد';
  if (days <= 7) return `${days} أيام`;
  if (days <= 30) return `${Math.ceil(days / 7)} أسابيع`;
  
  return `${Math.ceil(days / 30)} شهور`;
}

#46: ./src/lib/middleware/error-handler.ts
--------------------------------------------------------------------------------
// src/lib/middleware/error-handler.ts

import { NextRequest, NextResponse } from 'next/server';
import { API_ERROR_CODES, createErrorResponse } from '@/lib/api-response';

export class ApiError extends Error {
  public statusCode?: number;
  public code?: string;
  public details?: any;

  constructor(message: string, code?: string, statusCode?: number, details?: any) {
    super(message);
    this.name = 'ApiError';
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}

/**
 * Enhanced error handling middleware for API routes
 */
export function withErrorHandling<T extends any[]>(
  handler: (...args: T) => Promise<NextResponse>
) {
  return async (...args: T): Promise<NextResponse> => {
    try {
      return await handler(...args);
    } catch (error) {
      console.error('API Error:', error);

      // Type guard for ApiError
      if (error instanceof ApiError) {
        return createErrorResponse(
          error.code || API_ERROR_CODES.INTERNAL_ERROR,
          error.message,
          error.statusCode || 500,
          error.details
        );
      }

      // Type guard for regular Error
      if (error instanceof Error) {
        // Handle specific error types
        if (error.message.includes('PayMob')) {
          return createErrorResponse(
            API_ERROR_CODES.PAYMENT_GATEWAY_ERROR,
            'حدث خطأ في نظام الدفع. يرجى المحاولة مرة أخرى.',
            502,
            { originalError: error.message }
          );
        }

        if (error.message.includes('Prisma') || error.message.includes('database')) {
          return createErrorResponse(
            API_ERROR_CODES.DATABASE_ERROR,
            'حدث خطأ في قاعدة البيانات. يرجى المحاولة لاحقاً.',
            500,
            process.env.NODE_ENV === 'development' ? { originalError: error.message } : undefined
          );
        }

        if (error.message.includes('timeout')) {
          return createErrorResponse(
            API_ERROR_CODES.INTERNAL_ERROR,
            'انتهت مهلة معالجة الطلب. يرجى المحاولة مرة أخرى.',
            504,
            { timeout: true }
          );
        }
      }

      // Generic error fallback
      const errorMessage = error instanceof Error ? error.message : String(error);
      return createErrorResponse(
        API_ERROR_CODES.INTERNAL_ERROR,
        'حدث خطأ داخلي غير متوقع',
        500,
        process.env.NODE_ENV === 'development' ? { error: errorMessage } : undefined
      );
    }
  };
}

/**
 * Create a custom API error
 */
export function createApiError(
  message: string,
  code?: string,
  statusCode?: number,
  details?: any
): ApiError {
  return new ApiError(message, code, statusCode, details);
}

/**
 * Validation error helper
 */
export function createValidationError(message: string, issues?: any[]): ApiError {
  return createApiError(
    message,
    API_ERROR_CODES.VALIDATION_ERROR,
    400,
    { validationIssues: issues }
  );
}

/**
 * Payment error helper
 */
export function createPaymentError(message: string, details?: any): ApiError {
  return createApiError(
    message,
    API_ERROR_CODES.PAYMENT_GATEWAY_ERROR,
    502,
    details
  );
}

/**
 * Authentication error helper
 */
export function createAuthError(message?: string): ApiError {
  return createApiError(
    message || 'يجب تسجيل الدخول للوصول لهذه الخدمة',
    API_ERROR_CODES.UNAUTHORIZED,
    401
  );
}


#47: ./src/lib/paymob/client.ts
--------------------------------------------------------------------------------
// src/lib/paymob/client.ts

import { paymobConfig } from "./config";
import {
  PayMobAuthResponse,
  PayMobOrderRequest,
  PayMobOrderResponse,
  PayMobPaymentKeyResponse,
  PayMobBillingData,
} from "./types";
// Import utility functions from utils file
import {
  formatAmountToCents as formatAmount,
  generateMerchantOrderId,
  createBillingData,
} from "./utils";

/**
 * Step 1: Authenticates with PayMob to get an auth token.
 * @returns A promise that resolves to the authentication token.
 */
export async function authenticate(): Promise<string> {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

    const response = await fetch(`${paymobConfig.baseUrl}/auth/tokens`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        api_key: paymobConfig.apiKey,
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`PayMob authentication failed: ${response.statusText}`);
    }

    const data: PayMobAuthResponse = await response.json();
    return data.token;
  } catch (error) {
    console.error("PayMob authentication error:", error);
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error(
        "انتهت مهلة الاتصال بنظام الدفع. يرجى المحاولة مرة أخرى."
      );
    }
    throw new Error("فشل في الاتصال بنظام الدفع");
  }
}

/**
 * Step 2: Creates an order with PayMob.
 * @param authToken - The authentication token from Step 1.
 * @param orderData - The data for the order.
 * @returns A promise that resolves to the created order details.
 */
export async function createOrder(
  authToken: string,
  orderData: PayMobOrderRequest
): Promise<PayMobOrderResponse> {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

    const response = await fetch(`${paymobConfig.baseUrl}/ecommerce/orders`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        auth_token: authToken,
        delivery_needed: false, // Assuming this is always false for digital goods
        ...orderData,
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorBody = await response.text();
      console.error("PayMob order creation failed response:", errorBody);
      throw new Error(`PayMob order creation failed: ${response.statusText}`);
    }

    const data: PayMobOrderResponse = await response.json();
    return data;
  } catch (error) {
    console.error("PayMob order creation error:", error);
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error("انتهت مهلة إنشاء طلب الدفع. يرجى المحاولة مرة أخرى.");
    }
    throw new Error("فشل في إنشاء طلب الدفع");
  }
}

/**
 * Step 3: Gets a payment key for embedding the payment iframe.
 * @param authToken - The authentication token.
 * @param orderId - The ID of the order created in Step 2.
 * @param amountCents - The total amount in cents.
 * @param billingData - The customer's billing information.
 * @param paymentMethod - The payment method to use ('credit-card' or 'e-wallet').
 * @returns A promise that resolves to the payment key token.
 */
export async function getPaymentKey(
  authToken: string,
  orderId: number,
  amountCents: number,
  billingData: PayMobBillingData,
  paymentMethod: "credit-card" | "e-wallet" = "credit-card"
): Promise<string> {
  try {
    // Select the appropriate integration ID based on payment method
    let integrationId: number;
    try {
      integrationId =
        paymentMethod === "e-wallet"
          ? parseInt(paymobConfig.integrationIdMobileWallet)
          : parseInt(paymobConfig.integrationIdOnlineCard);

      if (isNaN(integrationId)) {
        throw new Error(
          `Invalid integration ID for payment method: ${paymentMethod}`
        );
      }
    } catch (error) {
      console.error("PayMob integration ID error:", error);
      throw new Error(`فشل في تكوين طريقة الدفع ${paymentMethod}`);
    }

    console.log(
      `Using integration ID ${integrationId} for payment method: ${paymentMethod}`
    );

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

    const response = await fetch(
      `${paymobConfig.baseUrl}/acceptance/payment_keys`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          auth_token: authToken,
          amount_cents: amountCents,
          expiration: paymobConfig.sessionExpiryMinutes * 60, // Dynamic expiration in seconds
          order_id: orderId,
          billing_data: billingData,
          currency: "EGP",
          integration_id: integrationId,
          lock_order_when_paid: true,
        }),
        signal: controller.signal,
      }
    );

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorBody = await response.text();
      console.error("PayMob payment key failed response:", errorBody);
      throw new Error(
        `PayMob payment key generation failed: ${response.statusText}`
      );
    }

    const data: PayMobPaymentKeyResponse = await response.json();
    return data.token;
  } catch (error) {
    console.error("PayMob payment key error:", error);
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error("انتهت مهلة إنشاء مفتاح الدفع. يرجى المحاولة مرة أخرى.");
    }
    throw new Error("فشل في إنشاء مفتاح الدفع");
  }
}

// Export a service object for backward compatibility
export const payMobService = {
  authenticate,
  createOrder,
  getPaymentKey,
  formatAmount,
  generateMerchantOrderId,
  createBillingData,
  // Import webhook methods
  async validateWebhookPayload(data: any) {
    const { validateWebhookPayload } = await import("./webhook.service");
    return validateWebhookPayload(data);
  },
  async verifyWebhookSignature(webhookObject: any) {
    const { verifyWebhookSignature } = await import("./webhook.service");
    return verifyWebhookSignature(webhookObject);
  },
  async processWebhook(webhookObject: any) {
    const { processWebhook } = await import("./webhook.service");
    return processWebhook(webhookObject);
  },
  async initiatePayment(
    orderData: any,
    courseId?: string,
    paymentMethod: "credit-card" | "e-wallet" = "credit-card"
  ) {
    const { initiatePayment } = await import("./payment.service");
    return initiatePayment(orderData, courseId, paymentMethod);
  },
};


#48: ./src/lib/paymob/mobile-wallet.service.ts
--------------------------------------------------------------------------------
// src/lib/paymob/mobile-wallet.service.ts - Paymob Mobile Wallet Direct API Integration

import { paymobConfig } from "./config";
import { PayMobBillingData } from "./types";

/**
 * The request structure for a direct mobile wallet payment.
 * Note: Authentication is handled via the Authorization header, not in the body.
 */
export interface MobileWalletPaymentRequest {
  source: {
    identifier: string; // Phone number (11 digits for Egypt)
    subtype: "WALLET"; // Always "WALLET" for this payment method
  };
  payment_token: string; // This is the payment key obtained after creating an order
}

/**
 * The response from a successful mobile wallet payment initiation.
 * It contains the URL to redirect the user for OTP verification.
 */
export interface MobileWalletPaymentResponse {
  id: number;
  pending: boolean;
  success: boolean;
  redirect_url: string; // The URL for OTP verification
  // ... and other fields that we can add if needed from the PayMob response
  [key: string]: any;
}

/**
 * Validates the format of an Egyptian phone number.
 * @param phone The phone number string to validate.
 * @returns An object with validation status, the formatted number, and an optional error message.
 */
export function validateEgyptianPhoneNumber(phone: string): {
  isValid: boolean;
  formatted: string;
  error?: string;
} {
  // Remove any non-digit characters
  const cleanPhone = phone.replace(/\D/g, "");

  // Check if it's 11 digits and starts with 01
  if (cleanPhone.length === 11 && cleanPhone.startsWith("01")) {
    return {
      isValid: true,
      formatted: cleanPhone,
    };
  }

  // Check if it's 10 digits starting with 1 (missing leading 0)
  if (cleanPhone.length === 10 && cleanPhone.startsWith("1")) {
    return {
      isValid: true,
      formatted: "0" + cleanPhone,
    };
  }

  return {
    isValid: false,
    formatted: cleanPhone,
    error: "رقم الهاتف يجب أن يكون 11 رقم ويبدأ بـ 01",
  };
}

/**
 * Creates a payment key. This key acts as a one-time token to authorize a payment for a specific order.
 * This is a necessary prerequisite for the direct API call.
 * @param authToken The master authentication token from PayMob.
 * @param orderId The ID of the order.
 * @param amountCents The amount in cents.
 * @param billingData The customer's billing information.
 * @returns A promise that resolves to the payment key token.
 */
async function createPaymentKey(
  authToken: string,
  orderId: number,
  amountCents: number,
  billingData: PayMobBillingData
): Promise<string> {
  const integrationId = parseInt(paymobConfig.integrationIdMobileWallet);
  if (isNaN(integrationId)) {
    throw new Error("معرف تكامل المحفظة الإلكترونية غير صحيح أو غير مُعرَّف");
  }

  const response = await fetch(
    `${paymobConfig.baseUrl}/acceptance/payment_keys`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        auth_token: authToken,
        amount_cents: amountCents,
        expiration: paymobConfig.sessionExpiryMinutes * 60,
        order_id: orderId,
        billing_data: billingData,
        currency: "EGP",
        integration_id: integrationId,
        lock_order_when_paid: true,
      }),
    }
  );

  if (!response.ok) {
    const errorBody = await response.text();
    console.error("Failed to create payment key:", errorBody);
    throw new Error("فشل في إنشاء مفتاح الدفع اللازم لعملية المحفظة الإلكترونية.");
  }

  const data = await response.json();
  return data.token;
}

/**
 * Initiates a mobile wallet payment using the correct direct API endpoint.
 * This function will first obtain a payment key and then use it to make the payment request.
 * @param authToken The master authentication token from PayMob.
 * @param orderId The ID of the order.
 *... (The rest of the parameters)
 * @returns A promise that resolves to the mobile wallet payment response, including the OTP redirect URL.
 */
export async function initiateMobileWalletPayment(
  authToken: string,
  orderId: number,
  amountCents: number,
  phoneNumber: string,
  billingData: PayMobBillingData
): Promise<MobileWalletPaymentResponse> {
  try {
    // Step 1: Validate the phone number format
    const phoneValidation = validateEgyptianPhoneNumber(phoneNumber);
    if (!phoneValidation.isValid) {
      throw new Error(phoneValidation.error || "رقم الهاتف غير صحيح");
    }

    console.log("🔄 Initiating mobile wallet payment (Direct API Flow)...");

    // Step 2: Create a one-time Payment Key for this transaction
    const paymentToken = await createPaymentKey(
      authToken,
      orderId,
      amountCents,
      billingData
    );
    console.log("✅ Payment key created for mobile wallet.");

    // Step 3: Make the actual payment request using the direct `/payments/pay` endpoint
    const paymentRequest: MobileWalletPaymentRequest = {
      source: {
        identifier: phoneValidation.formatted,
        subtype: "WALLET",
      },
      payment_token: paymentToken, // Use the payment key here
    };

    console.log("🚀 Sending request to /acceptance/payments/pay");

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);

    const response = await fetch(
      `${paymobConfig.baseUrl}/acceptance/payments/pay`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          // The direct API requires Bearer token authentication
          Authorization: `Bearer ${authToken}`,
        },
        body: JSON.stringify(paymentRequest),
        signal: controller.signal,
      }
    );

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorBody = await response.text();
      console.error("Mobile wallet payment initiation failed:", {
        status: response.status,
        statusText: response.statusText,
        errorBody,
      });

      // Provide a more helpful error based on the status code
      if (response.status === 401) {
        throw new Error("خطأ في المصادقة مع PayMob. تأكد من صلاحية مفتاح الـ API.");
      }
      throw new Error(`فشل في بدء عملية الدفع بالمحفظة الإلكترونية: ${response.statusText}`);
    }

    const data: MobileWalletPaymentResponse = await response.json();

    console.log("✅ Mobile wallet payment initiated successfully. Redirecting to OTP...");
    console.log({ redirect_url: data.redirect_url });

    return data;
  } catch (error) {
    console.error("Mobile wallet payment initiation error:", error);
    if (error instanceof Error && error.name === "AbortError") {
      throw new Error("انتهت مهلة إنشاء طلب الدفع. يرجى المحاولة مرة أخرى.");
    }
    throw error;
  }
}

/**
 * Extracts the mobile wallet provider from a given phone number based on its prefix.
 * @param phoneNumber The phone number to check.
 * @returns The name of the wallet provider or a generic fallback.
 */
export function getMobileWalletProvider(phoneNumber: string): string {
  const cleanPhone = phoneNumber.replace(/\D/g, "");

  if (cleanPhone.startsWith("010")) return "فودافون كاش";
  if (cleanPhone.startsWith("011")) return "اتصالات كاش";
  if (cleanPhone.startsWith("012")) return "أورنج موني";
  if (cleanPhone.startsWith("015")) return "WE Pay";

  return "محفظة إلكترونية";
}

#49: ./src/lib/paymob/types.ts
--------------------------------------------------------------------------------
// src/lib/paymob/types.ts

export interface PayMobConfig {
  apiKey: string;
  integrationIdOnlineCard: string;
  integrationIdMobileWallet: string;
  iframeId: string;
  iframeIdMobileWallet?: string; // Optional separate iframe ID for mobile wallets
  hmacSecret: string;
  baseUrl: string;
  webhookUrl: string;
  returnUrl: string;
  // Payment timeout configuration
  paymentTimeoutMinutes: number;
  sessionExpiryMinutes: number;
  abandonedPaymentCleanupMinutes: number;
}

export interface PayMobBillingData {
  first_name: string;
  last_name: string;
  email: string;
  phone_number: string;
  country: string;
  state: string;
  city: string;
  street: string;
  building: string;
  floor: string;
  apartment: string;
}

export interface PayMobOrderItem {
  name: string;
  amount_cents: number;
  description: string;
  quantity: number;
}

export interface PayMobOrderRequest {
  amount_cents: number;
  currency: string;
  merchant_order_id: string;
  items: PayMobOrderItem[];
  billing_data: PayMobBillingData;
}

export interface PayMobAuthResponse {
  token: string;
}

export interface PayMobOrderResponse {
  id: number;
  created_at: string;
  delivery_needed: boolean;
  merchant: {
    id: number;
    created_at: string;
    phones: string[];
    company_emails: string[];
    company_name: string;
    state: string;
    country: string;
    city: string;
    postal_code: string;
    street: string;
  };
  collector: any;
  amount_cents: number;
  shipping_data: any;
  currency: string;
  is_payment_locked: boolean;
  is_return: boolean;
  is_cancel: boolean;
  is_returned: boolean;
  is_canceled: boolean;
  merchant_order_id: string;
  wallet_notification: any;
  paid_amount_cents: number;
  notify_user_with_email: boolean;
  items: Array<{
    name: string;
    description: string;
    amount_cents: number;
    quantity: number;
  }>;
  order_url: string;
  commission_fees: number;
  delivery_fees_cents: number;
  delivery_vat_cents: number;
  payment_method: string;
  merchant_staff_tag: any;
  api_source: string;
  data: any;
}

export interface PayMobPaymentKeyResponse {
  token: string;
}

export interface PayMobTransactionResponse {
  id: number;
  pending: boolean;
  amount_cents: number;
  success: boolean;
  is_auth: boolean;
  is_capture: boolean;
  is_standalone_payment: boolean;
  is_voided: boolean;
  is_refunded: boolean;
  is_3d_secure: boolean;
  integration_id: number;
  profile_id: number;
  has_parent_transaction: boolean;
  order: {
    id: number;
    merchant_order_id: string;
    amount_cents: number;
    [key: string]: any;
  };
  created_at: string;
  currency: string;
  source_data: {
    pan: string;
    type: string;
    tenure: any;
    sub_type: string;
  };
  error_occured: boolean;
  is_live: boolean;
  refunded_amount_cents: number;
  source_id: number;
  is_captured: boolean;
  captured_amount: number;
  updated_at: string;
  is_settled: boolean;
  bill_balanced: boolean;
  is_bill: boolean;
  owner: number;
  parent_transaction: any;
  [key: string]: any; // For other potential fields
}

// Enhanced PayMob types for better type safety

export interface PayMobWebhookData {
  type: 'TRANSACTION';
  obj: PayMobTransactionResponse;
}

export interface PayMobApiError {
  detail?: string;
  message?: string;
  errors?: Record<string, string[]>;
  status_code?: number;
}

export interface PayMobPaymentSession {
  paymentKey: string;
  orderId: number;
  iframeUrl: string;
  expiresAt: Date;
  merchantOrderId: string;
}

export interface PayMobWebhookProcessingResult {
  success: boolean;
  transactionId?: number;
  orderId?: number;
  isPaymentSuccess?: boolean;
  amountCents?: number;
  currency?: string;
  merchantOrderId?: string;
  error?: string;
  requiresManualReview?: boolean;
}

// PayMob Configuration with validation
export interface ValidatedPayMobConfig extends PayMobConfig {
  paymentTimeoutMinutes: number;
  sessionExpiryMinutes: number;
  abandonedPaymentCleanupMinutes: number;
}

// Billing data with validation helpers
export interface ValidatedBillingData extends PayMobBillingData {
  isValid: boolean;
  validationErrors?: string[];
}

// Enhanced order request with metadata
export interface EnhancedOrderRequest extends PayMobOrderRequest {
  metadata?: {
    courseId: string;
    userId: string;
    paymentMethod: 'credit-card' | 'e-wallet';
    initiatedAt: string;
  };
}


#50: ./src/lib/paymob/utils.ts
--------------------------------------------------------------------------------
// src/lib/paymob/utils.ts

import { PayMobBillingData } from './types';

/**
 * Convert amount to cents (PayMob requires amounts in cents)
 */
export function formatAmountToCents(amount: number): number {
  return Math.round(amount * 100);
}

/**
 * Generate a unique merchant order ID
 */
export function generateMerchantOrderId(courseId: string, userId: string): string {
  const timestamp = Date.now();
  const randomSuffix = Math.random().toString(36).substring(2, 8);
  return `course_${courseId}_${userId}_${timestamp}_${randomSuffix}`;
}

/**
 * Create standardized billing data for PayMob
 */
export function createBillingData(userData: {
  name: string;
  email?: string;
  phone?: string | null;
}): PayMobBillingData {
  const nameParts = userData.name.split(' ');
  const firstName = nameParts[0] || 'مستخدم';
  const lastName = nameParts.slice(1).join(' ') || 'غير محدد';

  return {
    first_name: firstName,
    last_name: lastName,
    email: userData.email || 'noemail@example.com',
    phone_number: userData.phone || '+201000000000',
    country: 'EG',
    state: 'Cairo',
    city: 'Cairo',
    street: 'N/A',
    building: 'N/A',
    floor: 'N/A',
    apartment: 'N/A',
  };
}

/**
 * Validate PayMob webhook HMAC fields
 */
export function validateHmacFields(data: any): boolean {
  const requiredFields = [
    'amount_cents',
    'created_at',
    'currency',
    'error_occured',
    'has_parent_transaction',
    'id',
    'integration_id',
    'is_3d_secure',
    'is_auth',
    'is_capture',
    'is_refunded',
    'is_standalone_payment',
    'is_voided',
    'order',
    'owner',
    'pending',
    'success',
  ];

  return requiredFields.every(field => field in data);
}

/**
 * Format PayMob error messages for user display
 */
export function formatPayMobError(error: any): string {
  if (typeof error === 'string') {
    return error;
  }

  if (error?.message) {
    // Common PayMob error patterns
    if (error.message.includes('timeout')) {
      return 'انتهت مهلة الاتصال. يرجى المحاولة مرة أخرى.';
    }
    if (error.message.includes('network') || error.message.includes('connection')) {
      return 'مشكلة في الاتصال. تأكد من اتصالك بالإنترنت.';
    }
    if (error.message.includes('invalid') && error.message.includes('key')) {
      return 'خطأ في إعدادات النظام. يرجى التواصل مع الدعم الفني.';
    }
    return error.message;
  }

  return 'حدث خطأ غير متوقع في نظام الدفع';
}

/**
 * Parse PayMob webhook timestamp
 */
export function parsePayMobTimestamp(timestamp: string): Date {
  try {
    return new Date(timestamp);
  } catch {
    return new Date();
  }
}

/**
 * Generate PayMob return URL with course context
 */
export function buildReturnUrl(baseUrl: string, courseId: string, success: boolean = true): string {
  const params = new URLSearchParams({
    course: courseId,
    status: success ? 'success' : 'failed',
    timestamp: Date.now().toString(),
  });

  return `${baseUrl}?${params.toString()}`;
}


#51: ./src/lib/paymob/webhook.service.ts
--------------------------------------------------------------------------------
// src/lib/paymob/webhook.service.ts

import crypto from "crypto";
import { paymobConfig } from "./config";
import { PayMobTransactionResponse } from "./types";

/**
 * Constant-time string comparison to prevent timing attacks.
 */
function constantTimeCompare(a: string, b: string): boolean {
  if (a.length !== b.length) {
    return false;
  }

  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }

  return result === 0;
}

/**
 * Verifies the HMAC signature of a PayMob webhook payload.
 * @param webhookObject - The full object received from the webhook `obj` key.
 * @returns True if the signature is valid, otherwise false.
 */
export function verifyWebhookSignature(
  webhookObject: PayMobTransactionResponse
): boolean {
  try {
    const { hmac, ...data } = webhookObject;

    if (!hmac || typeof hmac !== "string") {
      console.error("HMAC verification failed: Missing or invalid HMAC");
      return false;
    }

    // The fields must be ordered alphabetically by key.
    const orderedKeys = [
      "amount_cents",
      "created_at",
      "currency",
      "error_occured",
      "has_parent_transaction",
      "id",
      "integration_id",
      "is_3d_secure",
      "is_auth",
      "is_capture",
      "is_refunded",
      "is_standalone_payment",
      "is_voided",
      "order",
      "owner",
      "pending",
      "source_data.pan",
      "source_data.sub_type",
      "source_data.type",
      "success",
    ];

    // Build the concatenated string from the data object
    const concatenatedString = orderedKeys
      .map((key) => {
        if (key.startsWith("source_data.")) {
          const subKey = key.split(".")[1];
          return (
            data.source_data?.[subKey as keyof typeof data.source_data] ??
            "false"
          );
        }
        if (key === "order") {
          return data.order?.id;
        }
        return data[key as keyof typeof data];
      })
      .join("");

    // Generate our own HMAC
    const calculatedHmac = crypto
      .createHmac("sha512", paymobConfig.hmacSecret)
      .update(concatenatedString)
      .digest("hex");

    // Compare safely
    return constantTimeCompare(calculatedHmac, hmac);
  } catch (error) {
    console.error("HMAC verification error:", error);
    return false;
  }
}

/**
 * Validates the structure of the incoming webhook payload.
 * @param data - The full webhook data object.
 * @returns True if the payload is valid, false otherwise.
 */
export function validateWebhookPayload(
  data: any
): data is PayMobTransactionResponse {
  if (!data || typeof data !== "object") return false;

  const requiredFields = [
    "id",
    "amount_cents",
    "success",
    "pending",
    "currency",
    "integration_id",
    "order",
    "created_at",
    "hmac",
  ];

  for (const field of requiredFields) {
    if (!(field in data)) {
      console.error(
        `Webhook validation failed: Missing required field '${field}'`
      );
      return false;
    }
  }

  if (!data.order || typeof data.order !== "object" || !("id" in data.order)) {
    console.error(
      "Webhook validation failed: Invalid or missing order object/ID"
    );
    return false;
  }

  return true;
}

/**
 * A processed webhook response with a clear structure.
 */
export interface ProcessedWebhook {
  isValid: boolean;
  transactionId?: number;
  orderId?: number;
  isSuccess?: boolean;
  amountCents?: number;
  currency?: string;
  merchantOrderId?: string;
}

/**
 * Processes the raw webhook data, including signature validation and data extraction.
 * @param webhookObject - The `obj` from the webhook payload.
 * @returns A structured object with the processing result.
 */
export function processWebhook(webhookObject: unknown): ProcessedWebhook {
  if (!validateWebhookPayload(webhookObject)) {
    return { isValid: false };
  }

  const isValid = verifyWebhookSignature(webhookObject);
  if (!isValid) {
    return { isValid: false };
  }

  return {
    isValid: true,
    transactionId: webhookObject.id,
    orderId: webhookObject.order.id,
    isSuccess: webhookObject.success && !webhookObject.error_occured,
    amountCents: webhookObject.amount_cents,
    currency: webhookObject.currency,
    merchantOrderId: webhookObject.order.merchant_order_id,
  };
}


#52: ./src/lib/services/course/index.service.ts
--------------------------------------------------------------------------------
// src/lib/services/course/index.service.ts

import { getCourseById } from './details.service';
import { getEnrolledCourses } from './student.service';
import { getFeaturedCourses, getCourseCatalog } from './public.service';

// Export a unified CourseService class for backward compatibility
export class CourseService {
  static async getCourseById(courseId: string, userId?: string, userRole?: any) {
    return getCourseById(courseId, userId, userRole);
  }

  static async getEnrolledCourses(userId: string) {
    return getEnrolledCourses(userId);
  }

  static async getFeaturedCourses(limit?: number) {
    return getFeaturedCourses(limit);
  }

  static async getCourseCatalog(filters: any, page?: number, limit?: number, sort?: string, userId?: string) {
    return getCourseCatalog(filters, page, limit, sort, userId);
  }
}

// Export individual functions as well
export { getCourseById, getEnrolledCourses, getFeaturedCourses, getCourseCatalog };

#53: ./src/lib/services/course-access.service.ts
--------------------------------------------------------------------------------
// src/lib/services/course-access.service.ts

import { auth } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { CourseAccessResult } from '@/lib/types/course-access';

// Re-export for backward compatibility
export type { CourseAccessResult };

/**
 * Checks if a user has access to a specific course. This is a read-only operation.
 */
export async function checkCourseAccess(
  courseId: string
): Promise<CourseAccessResult> {
  try {
    const session = await auth();
    if (!session?.user) {
      return { hasAccess: false, reason: 'not_authenticated' };
    }

    const course = await prisma.course.findUnique({
      where: { id: courseId },
      select: {
        id: true,
        title: true,
        price: true,
        currency: true,
        isPublished: true,
        professorId: true,
      },
    });

    if (!course) {
      return { hasAccess: false, reason: 'not_found' };
    }

    // Admins and course owners can access unpublished courses
    if (!course.isPublished && session.user.role !== 'ADMIN' && course.professorId !== session.user.id) {
        return { hasAccess: false, reason: 'not_published', course };
    }

    if (session.user.role === 'ADMIN') {
      return { hasAccess: true, reason: 'admin_access', course };
    }
    
    if (course.professorId === session.user.id) {
      return { hasAccess: true, reason: 'professor_owns', course };
    }

    // Check for enrollment for students
    if (session.user.role === 'STUDENT') {
      const enrollment = await prisma.enrollment.findUnique({
        where: { userId_courseId: { userId: session.user.id, courseId } },
        select: { id: true, progressPercent: true, enrolledAt: true },
      });

      if (enrollment) {
        return { hasAccess: true, reason: 'enrolled', course, enrollment };
      }
    }
    
    // If not enrolled, check if the course is free
    if (!course.price || Number(course.price) <= 0) {
      return { hasAccess: true, reason: 'free_course', course };
    }

    // If it's a paid course and the student is not enrolled, they need to pay
    return { hasAccess: false, reason: 'payment_required', course };

  } catch (error) {
    console.error('Course access check error:', error);
    // Default to a secure state
    return { hasAccess: false, reason: 'not_found' };
  }
}

/**
 * Middleware-style function to protect routes by requiring course access.
 * Throws an error if the user does not have access.
 */
export async function requireCourseAccess(courseId: string): Promise<CourseAccessResult> {
  const accessResult = await checkCourseAccess(courseId);

  if (!accessResult.hasAccess) {
    // This error can be caught in API routes or server components to trigger a redirect or an error page.
    throw new Error(`Course access denied: ${accessResult.reason}`);
  }

  return accessResult;
}

/**
 * Get access message based on course access result
 * @deprecated Use getAccessMessage from access-messages.ts instead
 */
export function getAccessMessage(reason: CourseAccessResult['reason']): string {
  // Import the function from access-messages.ts to avoid duplication
  const { getAccessMessage: getDetailedAccessMessage } = require('../access-messages');
  const result = { reason } as CourseAccessResult;
  return getDetailedAccessMessage(result).description;
}

// Export enrollInFreeCourse function for backward compatibility
export { enrollInFreeCourse } from './enrollment/core.service';

#54: ./src/lib/services/course-service.ts
--------------------------------------------------------------------------------
// src/lib/services/course-service.ts
// Backward compatibility layer for the old course service

export { getFeaturedCourses, getCourseCatalog } from './course/public.service';
export { getCourseById as getCourseDetails } from './course/details.service';
export { getEnrolledCourses as getStudentCourses } from './course/student.service';

// Re-export all course-related functions for backward compatibility
export * from './course/public.service';
export * from './course/details.service';
export * from './course/student.service';

// Export a CourseService class for backward compatibility
export class CourseService {
  static async getFeaturedCourses(limit?: number) {
    const { getFeaturedCourses } = await import('./course/public.service');
    return getFeaturedCourses(limit);
  }

  static async getCourseCatalog(filters: any, page?: number, limit?: number, sort?: string, userId?: string) {
    const { getCourseCatalog } = await import('./course/public.service');
    return getCourseCatalog(filters, page, limit, sort, userId);
  }

  static async getCourseDetails(courseId: string) {
    const { getCourseById } = await import('./course/details.service');
    return getCourseById(courseId);
  }

  static async getStudentCourses(userId: string) {
    const { getEnrolledCourses } = await import('./course/student.service');
    return getEnrolledCourses(userId);
  }
}

#55: ./src/lib/services/enrollment/core.service.ts
--------------------------------------------------------------------------------
// src/lib/services/enrollment/core.service.ts

import prisma from '@/lib/prisma';
import { EnrollmentResult } from './types';
// Import webhook service functions
import { 
  createEnrollmentFromPayment as createEnrollmentFromPaymentWebhook,
  handleEnrollmentFailure as handleEnrollmentFailureWebhook
} from './webhook.service';

/**
 * Enroll a user in a free course.
 * @param courseId - The ID of the free course.
 * @param userId - The ID of the user to enroll.
 * @returns A promise that resolves to an EnrollmentResult object.
 */
export async function enrollInFreeCourse(
  courseId: string,
  userId: string
): Promise<EnrollmentResult> {
  try {
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user || user.role !== 'STUDENT') {
      return { success: false, message: 'غير مصرح لك بالتسجيل في الدورات' };
    }

    const course = await prisma.course.findUnique({
      where: { id: courseId },
      select: { isPublished: true, price: true, professorId: true },
    });

    if (!course) {
      return { success: false, message: 'الدورة غير موجودة' };
    }
    if (!course.isPublished) {
      return { success: false, message: 'الدورة غير متاحة حالياً' };
    }
    if (course.professorId === userId) {
      return { success: false, message: 'لا يمكنك التسجيل في دورتك الخاصة' };
    }
    if (course.price && Number(course.price) > 0) {
      return {
        success: false,
        message: 'هذه الدورة مدفوعة وتتطلب دفع',
        requiresPayment: true,
      };
    }

    const existingEnrollment = await prisma.enrollment.findUnique({
      where: { userId_courseId: { userId, courseId } },
    });

    if (existingEnrollment) {
      return {
        success: false,
        message: 'أنت مسجل بالفعل في هذه الدورة',
        enrollmentId: existingEnrollment.id,
      };
    }

    const enrollment = await prisma.enrollment.create({
      data: {
        userId,
        courseId,
        enrolledAt: new Date(),
        progressPercent: 0,
        completedLessonIds: [],
        totalWatchTime: 0,
      },
    });

    return {
      success: true,
      message: 'تم التسجيل في الدورة بنجاح',
      enrollmentId: enrollment.id,
    };
  } catch (error) {
    console.error('Error enrolling in free course:', error);
    return {
      success: false,
      message: 'حدث خطأ أثناء التسجيل',
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Create an enrollment record after a successful payment has been verified.
 * @param courseId - The ID of the course.
 * @param userId - The ID of the user.
 * @param paymentId - The ID of the completed payment record.
 * @returns A promise that resolves to an EnrollmentResult object.
 */
export async function createPaidEnrollment(
  courseId: string,
  userId: string,
  paymentId: string
): Promise<EnrollmentResult> {
  try {
    // Verify payment exists and is completed
    const payment = await prisma.payment.findUnique({
      where: { id: paymentId },
      include: { course: true },
    });

    if (!payment) {
      return {
        success: false,
        message: 'معلومات الدفع غير موجودة',
      };
    }

    if (payment.status !== 'COMPLETED') {
      return {
        success: false,
        message: 'الدفع لم يكتمل بعد',
      };
    }

    if (payment.courseId !== courseId || payment.userId !== userId) {
      return {
        success: false,
        message: 'بيانات الدفع غير متطابقة',
      };
    }

    // Check if already enrolled
    const existingEnrollment = await prisma.enrollment.findUnique({
      where: {
        userId_courseId: {
          userId,
          courseId,
        },
      },
    });

    if (existingEnrollment) {
      return {
        success: true,
        message: 'أنت مسجل بالفعل في هذه الدورة',
        enrollmentId: existingEnrollment.id,
      };
    }

    // Create enrollment
    const enrollment = await prisma.enrollment.create({
      data: {
        userId,
        courseId,
        enrolledAt: new Date(),
      },
    });

    return {
      success: true,
      message: 'تم التسجيل في الدورة بنجاح بعد الدفع',
      enrollmentId: enrollment.id,
    };
  } catch (error) {
    console.error('Error creating paid enrollment:', error);
    return {
      success: false,
      message: 'حدث خطأ أثناء إنشاء التسجيل',
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// Export a service class for backward compatibility
export class EnrollmentService {
  static async enrollInFreeCourse(courseId: string, userId: string) {
    return enrollInFreeCourse(courseId, userId);
  }

  static async createPaidEnrollment(courseId: string, userId: string, paymentId: string) {
    return createPaidEnrollment(courseId, userId, paymentId);
  }

  static async checkCourseAccess(courseId: string, userId?: string, userRole?: any) {
    // Import and use the access service
    const { checkCourseAccess } = await import('../enrollment/access.service');
    return checkCourseAccess(courseId, userId, userRole);
  }

  static async createEnrollmentFromPayment(paymentData: {
    courseId: string;
    userId: string;
    paymentId: string;
  }) {
    return createEnrollmentFromPaymentWebhook(paymentData.paymentId);
  }

  static async handleEnrollmentFailure(paymentId: string, reason: string) {
    await handleEnrollmentFailureWebhook(paymentId, reason);
    return {
      success: false,
      message: `فشل في إنشاء التسجيل: ${reason}`,
    };
  }
}

#56: ./src/lib/services/enrollment/webhook.service.ts
--------------------------------------------------------------------------------
// src/lib/services/enrollment/webhook.service.ts

import prisma from '@/lib/prisma';
import { EnrollmentResult } from './types';

/**
 * Automatically creates an enrollment from a successful payment.
 * Typically called by a payment webhook handler.
 * @param paymentId - The ID of the completed payment.
 * @returns A promise that resolves to an EnrollmentResult object.
 */
export async function createEnrollmentFromPayment(
  paymentId: string
): Promise<EnrollmentResult> {
  try {
    // Get payment details with course and user info
    const payment = await prisma.payment.findUnique({
      where: { id: paymentId },
      include: {
        course: {
          select: {
            id: true,
            title: true,
            isPublished: true,
            price: true,
          },
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    });

    if (!payment) {
      return {
        success: false,
        message: 'Payment record not found',
        error: 'PAYMENT_NOT_FOUND',
      };
    }

    if (payment.status !== 'COMPLETED') {
      return {
        success: false,
        message: 'Payment not completed',
        error: 'PAYMENT_NOT_COMPLETED',
      };
    }

    if (!payment.course.isPublished) {
      return {
        success: false,
        message: 'Course is not published',
        error: 'COURSE_NOT_PUBLISHED',
      };
    }

    // Check if enrollment already exists
    const existingEnrollment = await prisma.enrollment.findUnique({
      where: {
        userId_courseId: {
          userId: payment.userId,
          courseId: payment.courseId,
        },
      },
    });

    if (existingEnrollment) {
      console.log('Enrollment already exists for payment:', paymentId);
      return {
        success: true,
        message: 'User already enrolled',
        enrollmentId: existingEnrollment.id,
      };
    }

    // Create enrollment with transaction to ensure consistency
    const enrollment = await prisma.$transaction(async (tx) => {
      // Create the enrollment
      const newEnrollment = await tx.enrollment.create({
        data: {
          userId: payment.userId,
          courseId: payment.courseId,
          progressPercent: 0,
          completedLessonIds: [],
          totalWatchTime: 0,
          enrolledAt: new Date(),
          lastAccessedAt: null,
        },
      });

      // Create a progress milestone for course start
      await tx.progressMilestone.create({
        data: {
          userId: payment.userId,
          courseId: payment.courseId,
          milestoneType: 'COURSE_START',
          metadata: {
            paymentId: payment.id,
            enrollmentId: newEnrollment.id,
            courseName: payment.course.title,
            amount: Number(payment.amount),
          },
        },
      });

      return newEnrollment;
    });

    console.log('Automatic enrollment created:', {
      enrollmentId: enrollment.id,
      userId: payment.userId,
      courseId: payment.courseId,
      paymentId: payment.id,
    });

    return {
      success: true,
      message: 'تم التسجيل في الدورة تلقائياً بعد الدفع',
      enrollmentId: enrollment.id,
    };
  } catch (error) {
    console.error('Error creating automatic enrollment:', error);
    // If an error occurs, we should handle it to allow for retries
    await handleEnrollmentFailure(
      paymentId,
      error instanceof Error ? error.message : 'Unknown transaction error'
    );
    return {
      success: false,
      message: 'Failed to create automatic enrollment',
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Logs an enrollment failure to the payment record for manual review and retry.
 * @param paymentId - The ID of the payment that failed to create an enrollment.
 * @param error - The error message.
 */
export async function handleEnrollmentFailure(
  paymentId: string,
  error: string
): Promise<void> {
  try {
    // Log the failure for manual review
    console.error(
      'Enrollment failure for payment:',
      paymentId,
      'Error:',
      error
    );

    const payment = await prisma.payment.findUnique({
      where: { id: paymentId },
    });
    
    // Ensure paymobResponse is treated as an object
    const paymobResponse = (payment?.paymobResponse || {}) as any;

    // Update payment record to indicate enrollment failure
    await prisma.payment.update({
      where: { id: paymentId },
      data: {
        paymobResponse: {
          ...paymobResponse,
          enrollmentError: {
            error,
            timestamp: new Date().toISOString(),
            requiresManualReview: true,
          },
        },
      },
    });

    // TODO: Send notification to administrators
    // TODO: Queue for manual enrollment processing
  } catch (dbError) {
    console.error('Failed to log enrollment failure:', dbError);
  }
}

/**
 * Retries a failed enrollment creation process for a given payment.
 * @param paymentId - The ID of the payment to retry.
 * @returns A promise that resolves to an EnrollmentResult.
 */
export async function retryFailedEnrollment(
  paymentId: string
): Promise<EnrollmentResult> {
  try {
    console.log('Retrying failed enrollment for payment:', paymentId);

    const result = await createEnrollmentFromPayment(paymentId);

    if (result.success) {
      const payment = await prisma.payment.findUnique({
        where: { id: paymentId },
      });
      const paymobResponse = (payment?.paymobResponse || {}) as any;
      
      // Clear the enrollment error flag
      await prisma.payment.update({
        where: { id: paymentId },
        data: {
          paymobResponse: {
            ...paymobResponse,
            enrollmentError: null, // Clear the error
            enrollmentRetry: {
              retriedAt: new Date().toISOString(),
              success: true,
            },
          },
        },
      });
    }

    return result;
  } catch (error) {
    console.error('Error retrying enrollment:', error);
    return {
      success: false,
      message: 'Failed to retry enrollment',
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

#57: ./src/lib/services/logging.service.ts
--------------------------------------------------------------------------------
// src/lib/services/logging.service.ts

interface LogContext {
    userId?: string;
    courseId?: string;
    paymentId?: string;
    transactionId?: string | number;
    action?: string;
    metadata?: Record<string, any>;
  }
  
  export class Logger {
    private static formatMessage(level: string, message: string, context?: LogContext): string {
      const timestamp = new Date().toISOString();
      const contextStr = context ? JSON.stringify(context) : '';
      return `[${timestamp}] ${level.toUpperCase()}: ${message} ${contextStr}`;
    }
  
    static info(message: string, context?: LogContext): void {
      console.log(this.formatMessage('info', message, context));
    }
  
    static warn(message: string, context?: LogContext): void {
      console.warn(this.formatMessage('warn', message, context));
    }
  
    static error(message: string, error?: Error, context?: LogContext): void {
      const errorContext = {
        ...context,
        error: error?.message,
        stack: error?.stack,
      };
      console.error(this.formatMessage('error', message, errorContext));
    }
  
    static payment(message: string, context: LogContext): void {
      this.info(`[PAYMENT] ${message}`, context);
    }
  
    static enrollment(message: string, context: LogContext): void {
      this.info(`[ENROLLMENT] ${message}`, context);
    }
  
    static webhook(message: string, context: LogContext): void {
      this.info(`[WEBHOOK] ${message}`, context);
    }
  
    static security(message: string, context?: LogContext): void {
      this.warn(`[SECURITY] ${message}`, context);
    }
  }
  

#58: ./src/lib/types/course-access.ts
--------------------------------------------------------------------------------
// src/lib/types/course-access.ts
// Unified course access types to eliminate duplication

/**
 * Unified course access result interface
 */
export interface CourseAccessResult {
  hasAccess: boolean;
  reason:
    | 'enrolled'
    | 'free_course'
    | 'admin_access'
    | 'professor_owns'
    | 'payment_required'
    | 'not_published'
    | 'not_found'
    | 'not_authenticated';
  course?: {
    id: string;
    title: string;
    price: any;
    currency: string;
    isPublished: boolean;
    professorId: string;
  };
  enrollment?: {
    id: string;
    progressPercent: number;
    enrolledAt: Date;
    lastAccessedAt?: Date | null;
  };
  payment?: {
    id: string;
    status: string;
    amount: any;
  };
  // Additional fields for enhanced access checking
  accessType?: 'free' | 'paid' | 'enrolled' | 'owner' | 'admin';
  message?: string;
  canEnroll?: boolean;
  requiresPayment?: boolean;
}

/**
 * Access message configuration
 */
export interface AccessMessage {
  title: string;
  description: string;
  actionText?: string;
  actionType?: 'login' | 'payment' | 'enrollment' | 'contact';
}

#59: ./src/lib/webhook-processor.ts
--------------------------------------------------------------------------------
// src/lib/webhook-processor.ts
import prisma from "@/lib/prisma";
import crypto from "crypto";

export interface WebhookPayload {
  type: string;
  obj: {
    id: string;
    amount_cents: number;
    currency: string;
    success: boolean;
    pending?: boolean;
    refunded?: boolean;
    order?: {
      merchant_order_id: string;
    };
    source_data?: {
      type: string;
      pan?: string;
    };
  };
}

export async function processWebhookPayload(
  payload: any,
  signature: string
): Promise<void> {
  // Verify signature
  const hmacSecret = process.env.PAYMOB_HMAC_SECRET;
  if (!hmacSecret) {
    throw new Error("PAYMOB_HMAC_SECRET not configured");
  }

  const expectedSignature = crypto
    .createHmac("sha512", hmacSecret)
    .update(JSON.stringify(payload))
    .digest("hex");

  if (signature !== expectedSignature) {
    throw new Error("Invalid webhook signature");
  }

  // Validate payload structure
  if (!payload.type || !payload.obj) {
    throw new Error("Invalid webhook payload structure");
  }

  if (payload.type !== "TRANSACTION") {
    // Ignore non-transaction webhooks
    return;
  }

  const transaction = payload.obj;

  if (!transaction.id || !transaction.order?.merchant_order_id) {
    throw new Error("Missing required transaction data");
  }

  const paymentId = transaction.order.merchant_order_id;

  // Find the payment
  const payment = await prisma.payment.findUnique({
    where: { id: paymentId },
    include: {
      user: true,
      course: true,
    },
  });

  if (!payment) {
    throw new Error(`Payment not found: ${paymentId}`);
  }

  // Determine payment status based on transaction data
  let newStatus: string;
  let failureReason: string | null = null;

  if (transaction.success && !transaction.pending && !transaction.refunded) {
    newStatus = "COMPLETED";
  } else if (transaction.pending) {
    newStatus = "PROCESSING";
  } else if (transaction.refunded) {
    newStatus = "REFUNDED";
  } else {
    newStatus = "FAILED";
    failureReason = "Payment failed at PayMob";
  }

  // Update payment
  const updatedPayment = await prisma.payment.update({
    where: { id: paymentId },
    data: {
      status: newStatus as any,
      paymobTransactionId: transaction.id,
      paymentMethod: transaction.source_data?.type?.toUpperCase() || "CARD",
      failureReason,
      updatedAt: new Date(),
    },
  });

  // Handle enrollment creation for completed payments
  if (newStatus === "COMPLETED" && payment.status !== "COMPLETED") {
    try {
      // Check if enrollment already exists
      const existingEnrollment = await prisma.enrollment.findFirst({
        where: {
          userId: payment.userId,
          courseId: payment.courseId,
        },
      });

      if (!existingEnrollment) {
        await prisma.enrollment.create({
          data: {
            userId: payment.userId,
            courseId: payment.courseId,
          },
        });

        // Course enrollment count is calculated via _count.enrollments
      }
    } catch (enrollmentError) {
      console.error(
        "Failed to create enrollment during webhook processing:",
        enrollmentError
      );
      // Don't throw error as payment was processed successfully
    }
  }

  console.log(
    `Webhook processed successfully for payment ${paymentId}: ${payment.status} -> ${newStatus}`
  );
}


#60: ./src/types/course.ts
--------------------------------------------------------------------------------
// src/types/course.ts
// Comprehensive type definitions for course-related data

import { UserRole } from '@prisma/client';

// Base course interface
export interface Course {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  price: number | null;
  currency: string;
  isPublished: boolean;
  bunnyLibraryId: string;
  createdAt: Date;
  updatedAt: Date;
}

// Course with relationships
export interface CourseWithRelations extends Course {
  category: {
    id: string;
    name: string;
    slug: string;
    description: string;
  };
  professor: {
    id: string;
    name: string;
    expertise: string[];
    bio?: string;
  };
  lessons: Lesson[];
}

// Course with computed metadata
export interface CourseWithMetadata extends CourseWithRelations {
  enrollmentCount: number;
  totalDuration: number; // in minutes
  lessonCount: number;
  averageRating: number;
  reviewCount: number;
  
  // User-specific data (when authenticated)
  isEnrolled?: boolean;
  progress?: number;
  lastAccessedAt?: Date;
  canEdit?: boolean;
  canManage?: boolean;
}

// Featured course for landing page
export interface FeaturedCourse {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  price: number | null;
  currency: string;
  professor: {
    name: string;
  };
  category: {
    name: string;
  };
  enrollmentCount: number;
  totalDuration: number;
  lessonCount: number;
}

// Lesson interface
export interface Lesson {
  id: string;
  title: string;
  order: number;
  bunnyVideoId: string;
  duration: number | null; // in seconds
  materials?: any; // JSON field
}

// Enrollment interface
export interface Enrollment {
  id: string;
  userId: string;
  courseId: string;
  completedLessonIds: string[];
  progressPercent: number;
  totalWatchTime: number;
  lastAccessedAt: Date | null;
  enrolledAt: Date;
  updatedAt: Date;
}

// Course with enrollment data
export interface EnrolledCourse {
  id: string;
  title: string;
  description: string;
  thumbnailUrl: string;
  category: {
    name: string;
  };
  professor: {
    name: string;
  };
  enrolledAt: Date;
  progress: number;
  totalLessons: number;
  completedLessons: number;
  totalDuration: number; // in minutes
  watchedDuration: number; // in minutes
  lastAccessedAt: Date | null;
  nextLesson: {
    id: string;
    title: string;
    order: number;
  } | null;
  certificateEarned: boolean;
  status: 'not_started' | 'in_progress' | 'completed';
}

// User actions for course cards
export interface CourseUserActions {
  canEnroll: boolean;
  canEdit: boolean;
  canManage: boolean;
  isOwner: boolean;
  isEnrolled: boolean;
}

// Course card props
export interface CourseCardProps {
  course: CourseWithMetadata;
  userRole?: UserRole;
  userActions: CourseUserActions;
  onEnroll?: () => void;
  onContinue?: () => void;
  onEdit?: () => void;
  onManage?: () => void;
}

// Course catalog filters
export interface CourseFilters {
  category?: string;
  priceRange?: 'free' | 'paid' | 'all';
  level?: 'beginner' | 'intermediate' | 'advanced' | 'all';
  duration?: 'short' | 'medium' | 'long' | 'all';
  rating?: number;
  search?: string;
}

// Course catalog response
export interface CourseCatalogResponse {
  courses: CourseWithMetadata[];
  totalCount: number;
  totalPages: number;
  currentPage: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

// API response types
export interface APIResponse<T> {
  data?: T;
  error?: string;
  code?: string;
  message?: string;
}

export interface FeaturedCoursesResponse {
  courses: FeaturedCourse[];
}

export interface EnrolledCoursesResponse {
  courses: EnrolledCourse[];
}

// Navigation types
export interface NavigationItem {
  href: string;
  label: string;
  icon?: React.ComponentType<{ className?: string }>;
  isActive?: boolean;
  requiresAuth?: boolean;
  allowedRoles?: UserRole[];
}

export interface NavigationConfig {
  [key: string]: NavigationItem[];
}

// Course action types
export type CourseAction = 'enroll' | 'continue' | 'edit' | 'manage' | 'view';

export interface CourseActionConfig {
  action: CourseAction;
  label: string;
  variant: 'default' | 'outline' | 'secondary' | 'destructive';
  icon?: React.ComponentType<{ className?: string }>;
  requiresAuth: boolean;
  allowedRoles?: UserRole[];
}

